<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LangGraph Agent Analysis</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #111827; color: #d1d5db; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    .header { background-color: #1f2937; padding: 1rem 2rem; border-bottom: 1px solid #374151; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    h1 { color: white; margin: 0; }
    .controls { display: flex; align-items: center; gap: 20px; }
    .legend { display: flex; gap: 20px; font-size: 12px; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .main-container { display: flex; flex-grow: 1; }
    .panel { min-width: 150px; height: 100%; display: flex; flex-direction: column; position: relative; }
    .panel:nth-child(1) { flex: 0 1 15%; }
    .panel:nth-child(3) { flex: 1 1 70%; }
    .panel:nth-child(5) { flex: 0 1 15%; }
    .splitter { width: 6px; background-color: #374151; cursor: col-resize; flex-shrink: 0; z-index: 100; }
    .splitter:hover { background-color: #4b5563; }
    .panel-header { padding: 1rem; text-align: center; border-bottom: 1px solid #374151; background-color: #1f2937; }
    .panel-header h2 { margin: 0; font-size: 1.5rem; }
    .header-r2 { color: #fca5a5; }
    .header-r3 { color: #86efac; }
    .header-r4 { color: #c4b5fd; }
    .canvas { position: relative; width: 100%; flex-grow: 1; overflow: hidden; cursor: grab; }
    .canvas:active { cursor: grabbing; }
    .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .transform-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; z-index: 2; }

    .node { position: absolute; border: 3px solid #4b5563; border-radius: 8px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3); font-family: monospace; width: 280px; cursor: move; z-index: 10; user-select: none; padding-top: 30px; }
    .node h3 { padding: 8px 12px 8px 12px; margin: 0; border-bottom: 1px solid rgba(0,0,0,0.2); border-radius: 8px 8px 0 0; font-size: 14px; color: white; word-break: break-all; }
    .node h3 .path { font-size: 0.8em; color: #9ca3af; display: block; font-weight: normal; }
    .node ul { list-style: none; padding: 0; margin: 0; }
    .node li { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; position: relative; }
    .node li:last-child { border-bottom: none; }
    .node .col-name { font-weight: 500; }
    .node .col-type { margin-left: auto; color: #9ca3af; }

    .db-node { background-color: rgba(196, 181, 253, 0.15); border-color: #a78bfa; }
    .db-node h3 { background-color: #8b5cf6; }

    .ui-node { background-color: rgba(191, 219, 254, 0.15); border-color: #60a5fa; }
    .ui-node h3 { background-color: #3b82f6; }

    .code-node { background-color: rgba(134, 239, 172, 0.1); border-color: #4ade80; }
    .code-node h3 { background-color: #22c55e; }

    .service-node { background-color: rgba(252, 165, 165, 0.1); border-color: #f87171; }
    .service-node h3 { background-color: #ef4444; }

    .icon-display { position: absolute; top: -32px; left: 50%; transform: translateX(-50%); font-size: 64px; z-index: 12; pointer-events: none; opacity: 0.8; }
</style>
</head>
<body>

<div class="header">
    <h1>LangGraph Agent Analysis</h1>
    <div class="controls">
        <div class="legend">
             <div class="legend-item"><svg width="10" height="10" style="background:#3b82f6; border-radius:3px;"></svg> UI / IO</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#22c55e; border-radius:3px;"></svg> Code / Logic</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#8b5cf6; border-radius:3px;"></svg> Data / Schema</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#ef4444; border-radius:3px;"></svg> Service</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="panel">
        <div class="panel-header"><h2 class="header-r2">Raptor 2: Legacy</h2></div>
        <div id="canvas-r2" class="canvas"><svg id="connections-r2" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r3">Multi-Agent Collaboration</h2></div>
        <div id="canvas-r3" class="canvas"><svg id="connections-r3" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r4">Raptor 4: Future</h2></div>
        <div id="canvas-r4" class="canvas"><svg id="connections-r4" class="connections"></svg><div class="transform-container"></div></div>
    </div>
</div>

<script>
// ===================================================================================
//
//  LANGGRAPH ARCHITECTURAL ANALYSIS
//
// ===================================================================================
/*
    ARCHITECTURAL INSIGHTS FOR FUTURE AI ANALYSIS:
    This file visualizes a multi-agent collaboration architecture, specifically a "supervisor" pattern. This is a highly effective way to orchestrate multiple specialized AI agents to solve a complex problem that is beyond the scope of a single agent.

    **Overall Architectural Philosophy:**
    The core idea is to create a team of agents with distinct roles and a supervisor to manage the workflow. The supervisor agent acts as a project manager, breaking down the main task and delegating sub-tasks to the appropriate specialist agent. The specialist agents execute their tasks, potentially using tools, and report back to the supervisor. This cycle of delegation and review continues until the overall goal is achieved. This pattern promotes modularity, specialization, and a clear chain of command, making the system easier to debug and scale.

    **Key Components and Their Roles:**
    - **Code/Logic Components (Green):**
        - `create_agent (Function)`: A factory function that creates individual, specialized agents. Each agent is a chain consisting of a prompt (defining its persona and tools), an LLM, and an output parser. This promotes code reuse and consistency.
        - `agent_node (Function)`: A wrapper that executes a single agent chain within the graph. It takes the current `AgentState`, runs the designated agent, and returns the agent's response.
        - `Supervisor (Agent)`: The central orchestrator of the team. It is a specialized agent created via `create_agent` whose primary "tool" is the ability to route tasks to other agents or finish the process. It's the decision-making hub of the graph.
        - `Researcher (Agent)`: A specialized agent equipped with search tools (e.g., Tavily). Its role is to gather information from external sources.
        - `Writer (Agent)`: A specialized agent whose role is to compose the final response based on the research gathered.
        - `ToolNode`: The component that executes the actual function calls requested by the agents (e.g., performing a web search).
        - `router (Conditional Edge)`: The core routing logic of the supervisor. It inspects the last message in the `AgentState`. If the message contains tool calls, it routes to the `ToolNode`. If it contains a "FINISH" instruction, it routes to `END`. Otherwise, it routes the task to the agent specified in the message's `recipient` field.

    - **Data/Schema Components (Purple):**
        - `AgentState (TypedDict)`: The shared memory and communication bus for the entire team. It holds the `messages` (the conversation history), and the `next` agent to be invoked. The `add_messages` reducer ensures that the conversation history is append-only, preserving the full context of the interaction.

    - **UI/IO Components (Blue):**
        - `User Input`: The initial high-level task or question that kicks off the collaborative process.
        - `Final Output`: The final message from the `Supervisor` when it decides the task is complete.

    - **Service Components (Red):**
        - `LLM`: The language model that powers all the agents (both the supervisor and the specialists). Different models could be used for different agents depending on the complexity of their roles.
        - `Search Tool (Tavily)`: An external API that the `Researcher` agent uses to gather information from the web.

    **The Control and Data Flow:**
    1.  **Invocation:** The user provides a task, which is added to the `AgentState` as the initial `HumanMessage`.
    2.  **Supervisor's Turn:** The graph starts at the `Supervisor` node. The supervisor analyzes the task and the current state and decides which agent should act next. It produces an `AIMessage` with a specific `recipient` (e.g., "Researcher").
    3.  **Routing:** The `router` edge inspects the `AIMessage`. Since it has a `recipient`, it routes control to the corresponding agent node (e.g., `Researcher`).
    4.  **Specialist's Turn:** The `Researcher` agent executes. It might decide it needs to use its search tool. If so, it produces an `AIMessage` containing a `tool_calls` request.
    5.  **Tool Execution:** The `router` now sees the `tool_calls` and routes control to the `ToolNode`. The `ToolNode` executes the search and adds the results to the `AgentState` as a `ToolMessage`.
    6.  **Return to Supervisor:** After the tool is called, control automatically returns to the `Supervisor`.
    7.  **Review and Delegate Again:** The supervisor now sees the research results. It might decide the research is complete and delegate the task of writing the final answer to the `Writer` agent by producing an `AIMessage` with `recipient: "Writer"`.
    8.  **Writing Phase:** The `router` sends control to the `Writer`. The writer composes the final answer and returns it in an `AIMessage`.
    9.  **Final Review:** Control returns to the `Supervisor`. It reviews the writer's work. If satisfied, it produces a final `AIMessage` that includes the special instruction "FINISH".
    10. **Termination:** The `router` sees the "FINISH" instruction and routes the execution to the `END` node, terminating the graph and returning the final state.
*/
const schemaR2 = { tables: [], relationships: [] };
const schemaR4 = { tables: [], relationships: [] };

const schemaR3 = {
    tables: [
        // UI / IO
        { id: 1, name: "User Input", path: "User Interaction", nodeType: "ui", pos: { x: 50, y: 800 }, icon: "ðŸ’¬", columns: [{ name: "High-level Task" }] },
        { id: 2, name: "Final Output", path: "User Interaction", nodeType: "ui", pos: { x: 1850, y: 800 }, icon: "âœ…", columns: [{ name: "Completed Work" }] },

        // Data / Schema
        { id: 10, name: "AgentState", path: "multi_agent_collaboration.ipynb", nodeType: "db", pos: { x: 950, y: 50 }, icon: "ðŸ“‹", columns: [{ name: "messages: Annotated[list, add_messages]" }, { name: "next: str" }] },

        // Code / Logic
        { id: 20, name: "Supervisor (Agent)", path: "Workflow Orchestrator", nodeType: "code", pos: { x: 950, y: 350 }, icon: "ðŸ‘‘", columns: [{ name: "create_agent(tools=[router_tool])" }, { name: "Decides next agent or FINISH" }] },
        { id: 21, name: "Router (Conditional Edge)", path: "Workflow Logic", nodeType: "code", pos: { x: 950, y: 650 }, icon: "ðŸ”€", columns: [{ name: "if tool_calls: route to ToolNode" }, { name: "if recipient: route to agent" }, { name: "if FINISH: route to END" }] },
        { id: 22, name: "Researcher (Agent)", path: "Specialist Agent", nodeType: "code", pos: { x: 350, y: 800 }, icon: "ðŸ”¬", columns: [{ name: "create_agent(tools=[search_tool])" }, { name: "Gathers information" }] },
        { id: 23, name: "Writer (Agent)", path: "Specialist Agent", nodeType: "code", pos: { x: 1550, y: 800 }, icon: "âœï¸", columns: [{ name: "create_agent(tools=[])" }, { name: "Writes final response" }] },
        { id: 24, name: "ToolNode", path: "Tool Executor", nodeType: "code", pos: { x: 950, y: 1200 }, icon: "ðŸ› ï¸", columns: [{ name: "Executes tool calls from agents" }] },
        { id: 25, name: "create_agent (Factory)", path: "Helper Function", nodeType: "code", pos: { x: 50, y: 400 }, icon: "ðŸ­", columns: [{ name: "Creates LLMChain for an agent" }] },

        // Services
        { id: 40, name: "LLM", path: "External Service", nodeType: "service", pos: { x: 50, y: 1200 }, icon: "ðŸ§ ", columns: [{ name: "e.g., GPT-4o" }] },
        { id: 41, name: "Search Tool (Tavily)", path: "External Service", nodeType: "service", pos: { x: 350, y: 1200 }, icon: "ðŸŒ", columns: [{ name: "Web Search API" }] }
    ],
    relationships: [
        // Initialization
        { from: { table: "User Input" }, to: { table: "Supervisor (Agent)" }, type: "flow", label: "Starts process" },
        { from: { table: "create_agent (Factory)" }, to: { table: "Supervisor (Agent)" }, type: "flow", label: "Creates" },
        { from: { table: "create_agent (Factory)" }, to: { table: "Researcher (Agent)" }, type: "flow", label: "Creates" },
        { from: { table: "create_agent (Factory)" }, to: { table: "Writer (Agent)" }, type: "flow", label: "Creates" },

        // Main Loop
        { from: { table: "Supervisor (Agent)" }, to: { table: "AgentState", column: "messages: Annotated[list, add_messages]" }, type: "read", label: "Reads state" },
        { from: { table: "Supervisor (Agent)" }, to: { table: "Router (Conditional Edge)" }, type: "flow", label: "Outputs decision" },
        
        // Routing
        { from: { table: "Router (Conditional Edge)" }, to: { table: "AgentState", column: "next: str" }, type: "read", label: "Checks recipient" },
        { from: { table: "Router (Conditional Edge)" }, to: { table: "Researcher (Agent)" }, type: "flow", label: "Delegates to Researcher" },
        { from: { table: "Router (Conditional Edge)" }, to: { table: "Writer (Agent)" }, type: "flow", label: "Delegates to Writer" },
        { from: { table: "Router (Conditional Edge)" }, to: { table: "ToolNode" }, type: "flow", label: "Routes for tool use" },
        { from: { table: "Router (Conditional Edge)" }, to: { table: "Final Output" }, type: "flow", label: "Routes to END" },

        // Agent Execution
        { from: { table: "Researcher (Agent)" }, to: { table: "AgentState" }, type: "read" },
        { from: { table: "Researcher (Agent)" }, to: { table: "LLM" }, type: "flow" },
        { from: { table: "Researcher (Agent)" }, to: { table: "Router (Conditional Edge)" }, type: "flow", label: "Returns to supervisor" },
        
        { from: { table: "Writer (Agent)" }, to: { table: "AgentState" }, type: "read" },
        { from: { table: "Writer (Agent)" }, to: { table: "LLM" }, type: "flow" },
        { from: { table: "Writer (Agent)" }, to: { table: "Router (Conditional Edge)" }, type: "flow", label: "Returns to supervisor" },
        
        // Tool Execution
        { from: { table: "ToolNode" }, to: { table: "Search Tool (Tavily)" }, type: "flow", label: "Executes search" },
        { from: { table: "ToolNode" }, to: { table: "AgentState", column: "messages: Annotated[list, add_messages]" }, type: "write", label: "Appends tool result" },
        { from: { table: "ToolNode" }, to: { table: "Router (Conditional Edge)" }, type: "flow", label: "Returns to supervisor" }
    ]
};

// ===================================================================================
//  RENDERING LOGIC
// ===================================================================================
function initializeCanvas(canvasId, schema) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const transformContainer = canvas.querySelector('.transform-container');
    const svg = canvas.querySelector('.connections');
    let state = { scale: 0.7, panX: 50, panY: 50, isPanning: false, lastMouse: { x: 0, y: 0 } };

    function render() {
        if (!transformContainer || !svg) return;
        transformContainer.innerHTML = '';
        transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        
        schema.tables.forEach(table => {
            const node = document.createElement('div');
            node.id = `${canvasId}-${table.id}`;
            node.classList.add('node', `${table.nodeType}-node`);
            node.style.left = `${table.pos.x}px`;
            node.style.top = `${table.pos.y}px`;

            const header = document.createElement('h3');
            const pathSpan = table.path ? `<span class="path">${table.path}</span>` : '';
            header.innerHTML = `${pathSpan}${table.name}`;

            const list = document.createElement('ul');
            list.innerHTML = (table.columns || []).map(col => {
                const colName = typeof col === 'string' ? col : col.name;
                const colType = typeof col === 'string' ? '' : col.type;
                const colId = colName.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                return `<li id="${canvasId}-${table.id}-${colId}"><span class="col-name">${colName}</span>${colType ? `<span class="col-type">${colType}</span>` : ''}</li>`;
            }).join('');
            
            if (table.icon) {
                const iconDisplay = document.createElement('div');
                iconDisplay.className = 'icon-display';
                iconDisplay.textContent = table.icon;
                node.appendChild(iconDisplay);
            }

            node.appendChild(header);
            node.appendChild(list);
            transformContainer.appendChild(node);
        });
        updateConnections();
    }
    
    function getElementPortPosition(elId) {
        const el = document.getElementById(elId);
        if (!el) return null;
        const parentNode = el.closest('.node');
        if (!parentNode) return null;
        const isNodeConnection = el.classList.contains('node');
        
        const parentRect = parentNode.getBoundingClientRect();
        const elRect = isNodeConnection ? parentRect : el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        const y = isNodeConnection ? (parentRect.top - canvasRect.top + parentRect.height / 2) : (elRect.top - canvasRect.top + elRect.height / 2);
        const leftX = (parentRect.left - canvasRect.left);
        const rightX = (parentRect.right - canvasRect.left);

        return { left: {x: leftX, y: y}, right: {x: rightX, y: y} };
    }

    function updateConnections() {
        if (!svg) return;
        svg.innerHTML = `<defs>
            <marker id="arrowhead-read-${canvasId}" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#6b7283" /></marker>
            <marker id="arrowhead-write-${canvasId}" markerWidth="12" markerHeight="9" refX="10" refY="4.5" orient="auto"><polygon points="0 0, 12 4.5, 0 9" fill="#86efac" /></marker>
            <marker id="arrowhead-flow-${canvasId}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#9ca3af" /></marker>
        </defs>`;
        
        const idMap = new Map(schema.tables.map(t => [t.name, t.id]));

        schema.relationships.forEach(rel => {
            const fromId = idMap.get(rel.from.table);
            const toId = idMap.get(rel.to.table);
            if(!fromId || !toId) return;

            let fromColName = (rel.from.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            let toColName = (rel.to.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            
            let fromElId = `${canvasId}-${fromId}${fromColName ? '-' + fromColName : ''}`;
            if (!document.getElementById(fromElId)) fromElId = `${canvasId}-${fromId}`;

            let toElId = `${canvasId}-${toId}${toColName ? '-' + toColName : ''}`;
            if (!document.getElementById(toElId)) toElId = `${canvasId}-${toId}`;
            
            const fromPorts = getElementPortPosition(fromElId);
            const toPorts = getElementPortPosition(toElId);
            if (!fromPorts || !toPorts) return;

            const fromPos = toPorts.right.x < fromPorts.left.x ? fromPorts.left : fromPorts.right;
            const toPos = toPorts.right.x < fromPorts.left.x ? toPorts.right : toPorts.left;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);

            if (rel.type === 'write') {
                line.setAttribute('stroke', '#86efac'); line.setAttribute('stroke-width', 4); line.setAttribute('marker-end', `url(#arrowhead-write-${canvasId})`);
            } else if (rel.type === 'flow') {
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2); line.setAttribute('stroke-dasharray', `6,6`); line.setAttribute('marker-end', `url(#arrowhead-flow-${canvasId})`);
            } else { // 'read' is the default
                line.setAttribute('stroke', '#6b7283'); line.setAttribute('stroke-width', 2); line.setAttribute('marker-end', `url(#arrowhead-read-${canvasId})`);
            }
            svg.appendChild(line);
        });
    }

    let activeNode = null, offset = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        const targetNode = e.target.closest('.node');
        if (targetNode) {
            activeNode = targetNode;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (!tableData) return;
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            offset.x = mouseX - tableData.pos.x;
            offset.y = mouseY - tableData.pos.y;
            activeNode.style.zIndex = 11;
        } else {
            state.isPanning = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (activeNode) {
            e.preventDefault();
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (tableData) {
                tableData.pos.x = mouseX - offset.x;
                tableData.pos.y = mouseY - offset.y;
                activeNode.style.left = `${tableData.pos.x}px`;
                activeNode.style.top = `${tableData.pos.y}px`;
                updateConnections();
            }
        } else if (state.isPanning) {
            e.preventDefault();
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.panX += dx;
            state.panY += dy;
            transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            updateConnections();
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (activeNode) { activeNode.style.zIndex = 10; activeNode = null; }
        state.isPanning = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const oldScale = state.scale;
        const zoomFactor = 1.1;
        state.scale *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        state.scale = Math.max(0.1, Math.min(state.scale, 2.5));
        state.panX = mouseX - (mouseX - state.panX) * (state.scale / oldScale);
        state.panY = mouseY - (mouseY - state.panY) * (state.scale / oldScale);
        render();
    });

    render();
    return { render, updateConnections };
}

const canvases = [
    initializeCanvas('canvas-r2', schemaR2),
    initializeCanvas('canvas-r3', schemaR3),
    initializeCanvas('canvas-r4', schemaR4)
];

document.querySelectorAll('.splitter').forEach(splitter => {
    splitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const prevPanel = splitter.previousElementSibling;
        const startX = e.clientX;
        const initialPrevWidth = prevPanel.getBoundingClientRect().width;
        
        const onMouseMove = (moveEvent) => {
            let newPrevWidth = initialPrevWidth + (moveEvent.clientX - startX);
            const MIN_WIDTH = 150;
            if (newPrevWidth < MIN_WIDTH) newPrevWidth = MIN_WIDTH;
            prevPanel.style.flex = `0 0 ${newPrevWidth}px`;
            canvases.forEach(c => c && c.render());
        };
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
});

window.addEventListener('resize', () => {
    canvases.forEach(c => c && c.render());
});
</script>

</body>
</html>