<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LangGraph Agent Analysis</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #111827; color: #d1d5db; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    .header { background-color: #1f2937; padding: 1rem 2rem; border-bottom: 1px solid #374151; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    h1 { color: white; margin: 0; }
    .controls { display: flex; align-items: center; gap: 20px; }
    .legend { display: flex; gap: 20px; font-size: 12px; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .main-container { display: flex; flex-grow: 1; }
    .panel { min-width: 150px; height: 100%; display: flex; flex-direction: column; position: relative; }
    .panel:nth-child(1) { flex: 0 1 15%; }
    .panel:nth-child(3) { flex: 1 1 70%; }
    .panel:nth-child(5) { flex: 0 1 15%; }
    .splitter { width: 6px; background-color: #374151; cursor: col-resize; flex-shrink: 0; z-index: 100; }
    .splitter:hover { background-color: #4b5563; }
    .panel-header { padding: 1rem; text-align: center; border-bottom: 1px solid #374151; background-color: #1f2937; }
    .panel-header h2 { margin: 0; font-size: 1.5rem; }
    .header-r2 { color: #fca5a5; }
    .header-r3 { color: #86efac; }
    .header-r4 { color: #c4b5fd; }
    .canvas { position: relative; width: 100%; flex-grow: 1; overflow: hidden; cursor: grab; }
    .canvas:active { cursor: grabbing; }
    .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .transform-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; z-index: 2; }

    .node { position: absolute; border: 3px solid #4b5563; border-radius: 8px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3); font-family: monospace; width: 280px; cursor: move; z-index: 10; user-select: none; padding-top: 30px; }
    .node h3 { padding: 8px 12px 8px 12px; margin: 0; border-bottom: 1px solid rgba(0,0,0,0.2); border-radius: 8px 8px 0 0; font-size: 14px; color: white; word-break: break-all; }
    .node h3 .path { font-size: 0.8em; color: #9ca3af; display: block; font-weight: normal; }
    .node ul { list-style: none; padding: 0; margin: 0; }
    .node li { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; position: relative; }
    .node li:last-child { border-bottom: none; }
    .node .col-name { font-weight: 500; }
    .node .col-type { margin-left: auto; color: #9ca3af; }

    .db-node { background-color: rgba(196, 181, 253, 0.15); border-color: #a78bfa; }
    .db-node h3 { background-color: #8b5cf6; }

    .ui-node { background-color: rgba(191, 219, 254, 0.15); border-color: #60a5fa; }
    .ui-node h3 { background-color: #3b82f6; }

    .code-node { background-color: rgba(134, 239, 172, 0.1); border-color: #4ade80; }
    .code-node h3 { background-color: #22c55e; }

    .service-node { background-color: rgba(252, 165, 165, 0.1); border-color: #f87171; }
    .service-node h3 { background-color: #ef4444; }

    .icon-display { position: absolute; top: -32px; left: 50%; transform: translateX(-50%); font-size: 64px; z-index: 12; pointer-events: none; opacity: 0.8; }
</style>
</head>
<body>

<div class="header">
    <h1>LangGraph Agent Analysis</h1>
    <div class="controls">
        <div class="legend">
             <div class="legend-item"><svg width="10" height="10" style="background:#3b82f6; border-radius:3px;"></svg> UI / IO</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#22c55e; border-radius:3px;"></svg> Code / Logic</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#8b5cf6; border-radius:3px;"></svg> Data / Schema</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#ef4444; border-radius:3px;"></svg> Service</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="panel">
        <div class="panel-header"><h2 class="header-r2">Raptor 2: Legacy</h2></div>
        <div id="canvas-r2" class="canvas"><svg id="connections-r2" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r3">Self-RAG Agent</h2></div>
        <div id="canvas-r3" class="canvas"><svg id="connections-r3" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r4">Raptor 4: Future</h2></div>
        <div id="canvas-r4" class="canvas"><svg id="connections-r4" class="connections"></svg><div class="transform-container"></div></div>
    </div>
</div>

<script>
// ===================================================================================
//
//  LANGGRAPH ARCHITECTURAL ANALYSIS
//
// ===================================================================================
/*
    ARCHITECTURAL INSIGHTS FOR FUTURE AI ANALYSIS:
    This file visualizes the architecture of a "Self-RAG" (Self-Reflective Retrieval-Augmented Generation) agent, as implemented in the provided LangGraph examples. This pattern demonstrates a sophisticated, cyclical agent capable of self-correction and reflection, which is a significant step beyond simple, linear RAG pipelines.

    **Overall Architectural Philosophy:**
    The Self-RAG agent uses a graph structure to implement a loop of retrieval, generation, and self-evaluation. Instead of blindly trusting retrieved documents and generating an answer, it critically assesses the relevance of the documents and the quality of its own generation. If it fails its own checks, it can either rewrite the query and try again (if documents are irrelevant) or re-generate the answer (if the answer is a hallucination or doesn't address the question). This creates a robust, stateful system that can recover from common RAG pitfalls.

    **Key Components and Their Roles:**
    - **Code/Logic Components (Green):**
        - `StateGraph Definition`: The entry point where the `StateGraph` is initialized with the `GraphState` schema. This is where nodes and edges are added to define the workflow.
        - `retrieve (Node)`: The first active step. It takes the current question from the state, invokes the `Retriever` service, and adds the retrieved documents to the state.
        - `grade_documents (Node)`: A self-reflection step. It iterates through the retrieved documents, using the `retrieval_grader` to score each one for relevance to the question. It then filters out irrelevant documents, updating the state with only the relevant ones.
        - `decide_to_generate (Conditional Edge)`: The first major decision point. Based on the outcome of `grade_documents`, it routes the execution. If any relevant documents remain, it proceeds to `generate`. If all documents were irrelevant, it routes to `transform_query` to attempt self-correction.
        - `transform_query (Node)`: A self-correction step. It takes the original, failed question and uses the `question_rewriter` chain to create a new, potentially better version of the question. It then updates the state with this new question and loops back to the `retrieve` node.
        - `generate (Node)`: The generation step. It takes the relevant documents and the question, invokes the main `rag_chain` to produce an answer, and adds this `generation` to the state.
        - `grade_generation (Conditional Edge)`: The final and most critical self-reflection step. It uses two separate graders (`hallucination_grader` and `answer_grader`) to evaluate the generated answer. It first checks if the generation is "grounded" in the provided documents (not a hallucination). If it is, it then checks if the answer actually addresses the user's question. Based on this two-part evaluation, it makes a final routing decision:
            - "useful": The answer is good. Route to `END`.
            - "not supported": The answer is a hallucination. Route back to `generate` to try again.
            - "not useful": The answer is grounded but irrelevant. Route to `transform_query` to restart the process with a better question.

    - **Data/Schema Components (Purple):**
        - `GraphState (TypedDict)`: The central nervous system of the agent. It holds the `question`, the list of `documents`, and the final `generation`. All nodes read from and write to this shared state.
        - `Pydantic Grader Models`: Classes like `GradeDocuments`, `GradeHallucinations`, and `GradeAnswer` define the expected structured output from the LLM-based graders (e.g., a `binary_score: 'yes' or 'no'`). This ensures the grading steps are reliable and their outputs can be easily parsed by the conditional edges.

    - **UI/IO Components (Blue):**
        - `User Input / Final Output`: The start and end points of the user interaction.
        - `LangSmith Trace`: Provides essential observability for this complex, cyclical graph, allowing developers to trace the path of execution, inspect the state at each step, and debug the decision-making of the conditional edges.

    - **Service Components (Red):**
        - `LLM`: One or more Large Language Models (e.g., GPT-4o-mini, GPT-3.5-Turbo) serve as the "brains" for all generation and grading steps. Notably, different models can be used for different tasks (e.g., a cheaper model for grading, a more powerful one for generation).
        - `Retriever`: An interface to a `Vectorstore` (like Chroma or Pinecone) that fetches documents based on the current question.

    **The Control and Data Flow:**
    1.  **Invocation:** The graph starts with a user's `question`.
    2.  **Retrieve & Grade Docs:** It retrieves documents, then immediately grades them for relevance.
    3.  **First Decision:**
        - If docs are relevant -> proceed to `generate`.
        - If docs are irrelevant -> go to `transform_query`, rewrite the question, and loop back to `retrieve`.
    4.  **Generate:** An answer is generated using the filtered, relevant documents.
    5.  **Second Decision (Multi-part):**
        - The answer is checked for hallucinations against the documents. If it's a hallucination -> go back to `generate` and try again.
        - If it's grounded, it's then checked for usefulness against the question. If it's not useful -> go to `transform_query` to start over with a new question.
        - If it's grounded AND useful -> proceed to `END` and return the answer to the user.

    This self-correcting loop structure makes the agent far more resilient than a simple one-shot RAG pipeline.
*/
const schemaR2 = { tables: [], relationships: [] };
const schemaR4 = { tables: [], relationships: [] };

const schemaR3 = {
    tables: [
        // UI / IO
        { id: 1, name: "User Input", path: "User Interaction", nodeType: "ui", pos: { x: 50, y: 500 }, icon: "ðŸ’¬", columns: [ { name: "question: str" } ] },
        { id: 2, name: "Final Answer", path: "User Interaction", nodeType: "ui", pos: { x: 1850, y: 850 }, icon: "âœ…", columns: [ { name: "generation: str" } ] },
        { id: 3, name: "LangSmith Trace", path: "Observability", nodeType: "ui", pos: { x: 950, y: 1400 }, icon: "ðŸ“Š", columns: [ { name: "Visualizes all steps" } ] },

        // Data / Schema
        { id: 10, name: "GraphState", path: "langgraph_self_rag.ipynb", nodeType: "db", pos: { x: 350, y: 150 }, icon: "ðŸ“‹", columns: [ { name: "question: str" }, { name: "generation: str" }, { name: "documents: List[str]" } ] },
        { id: 11, name: "GradeDocuments", path: "Pydantic Model", nodeType: "db", pos: { x: 950, y: 150 }, icon: "ðŸ“", columns: [ { name: "binary_score: 'yes'|'no'" } ] },
        { id: 12, name: "GradeHallucinations", path: "Pydantic Model", nodeType: "db", pos: { x: 1250, y: 150 }, icon: "ðŸ“", columns: [ { name: "binary_score: 'yes'|'no'" } ] },
        { id: 13, name: "GradeAnswer", path: "Pydantic Model", nodeType: "db", pos: { x: 1550, y: 150 }, icon: "ðŸ“", columns: [ { name: "binary_score: 'yes'|'no'" } ] },

        // Code / Logic
        { id: 20, name: "StateGraph Definition", path: "langgraph.graph.StateGraph", nodeType: "code", pos: { x: 50, y: 200 }, icon: " G ", columns: [ { name: ".add_node()" }, { name: ".add_edge()" }, { name: ".add_conditional_edges()" } ] },
        { id: 21, name: "retrieve (Node)", path: "Workflow Logic", nodeType: "code", pos: { x: 350, y: 500 }, icon: "âš™ï¸", columns: [ { name: "get_relevant_documents()" } ] },
        { id: 22, name: "grade_documents (Node)", path: "Workflow Logic", nodeType: "code", pos: { x: 650, y: 500 }, icon: "âš–ï¸", columns: [ { name: "retrieval_grader.invoke()" } ] },
        { id: 23, name: "decide_to_generate (Edge)", path: "Workflow Logic", nodeType: "code", pos: { x: 950, y: 500 }, icon: "ðŸ”€", columns: [ { name: "if not filtered_documents" } ] },
        { id: 24, name: "generate (Node)", path: "Workflow Logic", nodeType: "code", pos: { x: 1250, y: 500 }, icon: "âš™ï¸", columns: [ { name: "rag_chain.invoke()" } ] },
        { id: 25, name: "grade_generation (Edge)", path: "Workflow Logic", nodeType: "code", pos: { x: 1550, y: 500 }, icon: "ðŸ”€", columns: [ { name: "hallucination_grader.invoke()" }, { name: "answer_grader.invoke()" } ] },
        { id: 26, name: "transform_query (Node)", path: "Workflow Logic (Correction Loop)", nodeType: "code", pos: { x: 950, y: 850 }, icon: "âœï¸", columns: [ { name: "question_rewriter.invoke()" } ] },
        { id: 27, name: "retrieval_grader (Chain)", path: "LLM Chain", nodeType: "code", pos: { x: 950, y: 300 }, icon: "ðŸ”—", columns: [ { name: "grade_prompt | llm" } ] },
        { id: 28, name: "hallucination_grader (Chain)", path: "LLM Chain", nodeType: "code", pos: { x: 1250, y: 300 }, icon: "ðŸ”—", columns: [ { name: "hallucination_prompt | llm" } ] },
        { id: 29, name: "answer_grader (Chain)", path: "LLM Chain", nodeType: "code", pos: { x: 1550, y: 300 }, icon: "ðŸ”—", columns: [ { name: "answer_prompt | llm" } ] },
        { id: 30, name: "question_rewriter (Chain)", path: "LLM Chain", nodeType: "code", pos: { x: 950, y: 1050 }, icon: "ðŸ”—", columns: [ { name: "re_write_prompt | llm" } ] },

        // Services
        { id: 40, name: "LLM", path: "gpt-4o-mini / gpt-3.5-turbo", nodeType: "service", pos: { x: 1250, y: 1150 }, icon: "ðŸ§ ", columns: [ { name: ".with_structured_output()" }, { name: ".invoke()" } ] },
        { id: 41, name: "Retriever", path: "Vectorstore Interface", nodeType: "service", pos: { x: 350, y: 850 }, icon: "ðŸ”", columns: [ { name: ".as_retriever()" } ] },
        { id: 42, name: "Vectorstore", path: "Chroma / Pinecone", nodeType: "service", pos: { x: 350, y: 1150 }, icon: "ðŸ“š", columns: [ { name: "from_documents()" } ] },
        { id: 43, name: "Web Loader", path: "langchain_community.document_loaders", nodeType: "service", pos: { x: 50, y: 1150 }, icon: "ðŸŒ", columns: [ { name: "WebBaseLoader.load()" } ] }
    ],
    relationships: [
        // Initialization
        { from: { table: "User Input", column: "question: str" }, to: { table: "StateGraph Definition", column: ".add_node()" }, type: "flow" },
        { from: { table: "StateGraph Definition", column: ".add_node()" }, to: { table: "GraphState", column: "question: str" }, type: "write" },

        // Main path
        { from: { table: "StateGraph Definition", column: ".add_edge()" }, to: { table: "retrieve (Node)", column: "get_relevant_documents()" }, type: "flow" },
        { from: { table: "retrieve (Node)", column: "get_relevant_documents()" }, to: { table: "GraphState", column: "question: str" }, type: "read" },
        { from: { table: "retrieve (Node)", column: "get_relevant_documents()" }, to: { table: "Retriever", column: ".as_retriever()" }, type: "flow" },
        { from: { table: "Retriever", column: ".as_retriever()" }, to: { table: "Vectorstore", column: "from_documents()" }, type: "flow" },
        { from: { table: "Web Loader", column: "WebBaseLoader.load()" }, to: { table: "Vectorstore", column: "from_documents()" }, type: "write" },
        { from: { table: "retrieve (Node)", column: "get_relevant_documents()" }, to: { table: "GraphState", column: "documents: List[str]" }, type: "write" },

        { from: { table: "retrieve (Node)", column: "get_relevant_documents()" }, to: { table: "grade_documents (Node)", column: "retrieval_grader.invoke()" }, type: "flow" },
        { from: { table: "grade_documents (Node)", column: "retrieval_grader.invoke()" }, to: { table: "GraphState", column: "documents: List[str]" }, type: "read" },
        { from: { table: "grade_documents (Node)", column: "retrieval_grader.invoke()" }, to: { table: "retrieval_grader (Chain)", column: "grade_prompt | llm" }, type: "flow" },
        { from: { table: "retrieval_grader (Chain)", column: "grade_prompt | llm" }, to: { table: "GradeDocuments", column: "binary_score: 'yes'|'no'" }, type: "write" },
        { from: { table: "retrieval_grader (Chain)", column: "grade_prompt | llm" }, to: { table: "LLM", column: ".with_structured_output()" }, type: "flow" },
        { from: { table: "grade_documents (Node)", column: "retrieval_grader.invoke()" }, to: { table: "GraphState", column: "documents: List[str]" }, type: "write" },

        { from: { table: "grade_documents (Node)", column: "retrieval_grader.invoke()" }, to: { table: "decide_to_generate (Edge)", column: "if not filtered_documents" }, type: "flow" },
        { from: { table: "decide_to_generate (Edge)", column: "if not filtered_documents" }, to: { table: "GraphState", column: "documents: List[str]" }, type: "read" },
        
        // Happy path
        { from: { table: "decide_to_generate (Edge)", column: "if not filtered_documents" }, to: { table: "generate (Node)", column: "rag_chain.invoke()" }, type: "flow" },
        { from: { table: "generate (Node)", column: "rag_chain.invoke()" }, to: { table: "GraphState", column: "documents: List[str]" }, type: "read" },
        { from: { table: "generate (Node)", column: "rag_chain.invoke()" }, to: { table: "LLM", column: ".invoke()" }, type: "flow" },
        { from: { table: "generate (Node)", column: "rag_chain.invoke()" }, to: { table: "GraphState", column: "generation: str" }, type: "write" },

        { from: { table: "generate (Node)", column: "rag_chain.invoke()" }, to: { table: "grade_generation (Edge)", column: "hallucination_grader.invoke()" }, type: "flow" },
        { from: { table: "grade_generation (Edge)", column: "hallucination_grader.invoke()" }, to: { table: "GraphState", column: "generation: str" }, type: "read" },
        { from: { table: "grade_generation (Edge)", column: "hallucination_grader.invoke()" }, to: { table: "hallucination_grader (Chain)", column: "hallucination_prompt | llm" }, type: "flow" },
        { from: { table: "hallucination_grader (Chain)", column: "hallucination_prompt | llm" }, to: { table: "GradeHallucinations", column: "binary_score: 'yes'|'no'" }, type: "write" },
        { from: { table: "hallucination_grader (Chain)", column: "hallucination_prompt | llm" }, to: { table: "LLM", column: ".with_structured_output()" }, type: "flow" },

        { from: { table: "grade_generation (Edge)", column: "answer_grader.invoke()" }, to: { table: "answer_grader (Chain)", column: "answer_prompt | llm" }, type: "flow" },
        { from: { table: "answer_grader (Chain)", column: "answer_prompt | llm" }, to: { table: "GradeAnswer", column: "binary_score: 'yes'|'no'" }, type: "write" },
        { from: { table: "answer_grader (Chain)", column: "answer_prompt | llm" }, to: { table: "LLM", column: ".with_structured_output()" }, type: "flow" },

        { from: { table: "grade_generation (Edge)", column: "hallucination_grader.invoke()" }, to: { table: "Final Answer", column: "generation: str" }, type: "flow" },

        // Correction loop
        { from: { table: "decide_to_generate (Edge)", column: "if not filtered_documents" }, to: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, type: "flow" },
        { from: { table: "grade_generation (Edge)", column: "answer_grader.invoke()" }, to: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, type: "flow" },
        { from: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, to: { table: "GraphState", column: "question: str" }, type: "read" },
        { from: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, to: { table: "question_rewriter (Chain)", column: "re_write_prompt | llm" }, type: "flow" },
        { from: { table: "question_rewriter (Chain)", column: "re_write_prompt | llm" }, to: { table: "LLM", column: ".invoke()" }, type: "flow" },
        { from: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, to: { table: "GraphState", column: "question: str" }, type: "write" },
        { from: { table: "transform_query (Node)", column: "question_rewriter.invoke()" }, to: { table: "retrieve (Node)", column: "get_relevant_documents()" }, type: "flow" },

        // Hallucination loop
        { from: { table: "grade_generation (Edge)", column: "hallucination_grader.invoke()" }, to: { table: "generate (Node)", column: "rag_chain.invoke()" }, type: "flow" },
        
        // Tracing
        { from: { table: "StateGraph Definition", column: ".add_node()" }, to: { table: "LangSmith Trace", column: "Visualizes all steps" }, type: "flow" }
    ]
};

// ===================================================================================
//  RENDERING LOGIC
// ===================================================================================
function initializeCanvas(canvasId, schema) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const transformContainer = canvas.querySelector('.transform-container');
    const svg = canvas.querySelector('.connections');
    let state = { scale: 0.7, panX: 50, panY: 50, isPanning: false, lastMouse: { x: 0, y: 0 } };

    function render() {
        if (!transformContainer || !svg) return;
        transformContainer.innerHTML = '';
        transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        
        schema.tables.forEach(table => {
            const node = document.createElement('div');
            node.id = `${canvasId}-${table.id}`;
            node.classList.add('node', `${table.nodeType}-node`);
            node.style.left = `${table.pos.x}px`;
            node.style.top = `${table.pos.y}px`;

            const header = document.createElement('h3');
            const pathSpan = table.path ? `<span class="path">${table.path}</span>` : '';
            header.innerHTML = `${pathSpan}${table.name}`;

            const list = document.createElement('ul');
            list.innerHTML = (table.columns || []).map(col => {
                const colName = typeof col === 'string' ? col : col.name;
                const colType = typeof col === 'string' ? '' : col.type;
                const colId = colName.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                return `<li id="${canvasId}-${table.id}-${colId}"><span class="col-name">${colName}</span>${colType ? `<span class="col-type">${colType}</span>` : ''}</li>`;
            }).join('');
            
            if (table.icon) {
                const iconDisplay = document.createElement('div');
                iconDisplay.className = 'icon-display';
                iconDisplay.textContent = table.icon;
                node.appendChild(iconDisplay);
            }

            node.appendChild(header);
            node.appendChild(list);
            transformContainer.appendChild(node);
        });
        updateConnections();
    }
    
    function getElementPortPosition(elId) {
        const el = document.getElementById(elId);
        if (!el) return null;
        const parentNode = el.closest('.node');
        if (!parentNode) return null;
        const isNodeConnection = el.classList.contains('node');
        
        const parentRect = parentNode.getBoundingClientRect();
        const elRect = isNodeConnection ? parentRect : el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        const y = isNodeConnection ? (parentRect.top - canvasRect.top + parentRect.height / 2) : (elRect.top - canvasRect.top + elRect.height / 2);
        const leftX = (parentRect.left - canvasRect.left);
        const rightX = (parentRect.right - canvasRect.left);

        return { left: {x: leftX, y: y}, right: {x: rightX, y: y} };
    }

    function updateConnections() {
        if (!svg) return;
        svg.innerHTML = `<defs>
            <marker id="arrowhead-read-${canvasId}" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#6b7283" /></marker>
            <marker id="arrowhead-write-${canvasId}" markerWidth="12" markerHeight="9" refX="10" refY="4.5" orient="auto"><polygon points="0 0, 12 4.5, 0 9" fill="#86efac" /></marker>
            <marker id="arrowhead-flow-${canvasId}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#9ca3af" /></marker>
        </defs>`;
        
        const idMap = new Map(schema.tables.map(t => [t.name, t.id]));

        schema.relationships.forEach(rel => {
            const fromId = idMap.get(rel.from.table);
            const toId = idMap.get(rel.to.table);
            if(!fromId || !toId) return;

            let fromColName = rel.from.column || "";
            let toColName = rel.to.column || "";
            
            let fromElId = `${canvasId}-${fromId}${fromColName ? '-' + fromColName.replace(/\s+/g, '-').replace(/[^\w-]/g, '') : ''}`;
            if (!document.getElementById(fromElId)) fromElId = `${canvasId}-${fromId}`;

            let toElId = `${canvasId}-${toId}${toColName ? '-' + toColName.replace(/\s+/g, '-').replace(/[^\w-]/g, '') : ''}`;
            if (!document.getElementById(toElId)) toElId = `${canvasId}-${toId}`;
            
            const fromPorts = getElementPortPosition(fromElId);
            const toPorts = getElementPortPosition(toElId);
            if (!fromPorts || !toPorts) return;

            const fromPos = toPorts.right.x < fromPorts.left.x ? fromPorts.left : fromPorts.right;
            const toPos = toPorts.right.x < fromPorts.left.x ? toPorts.right : toPorts.left;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);

            if (rel.type === 'write') {
                line.setAttribute('stroke', '#86efac'); line.setAttribute('stroke-width', 4); line.setAttribute('marker-end', `url(#arrowhead-write-${canvasId})`);
            } else if (rel.type === 'flow') {
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2); line.setAttribute('stroke-dasharray', `6,6`); line.setAttribute('marker-end', `url(#arrowhead-flow-${canvasId})`);
            } else { // 'read' is the default
                line.setAttribute('stroke', '#6b7283'); line.setAttribute('stroke-width', 2); line.setAttribute('marker-end', `url(#arrowhead-read-${canvasId})`);
            }
            svg.appendChild(line);
        });
    }

    let activeNode = null, offset = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        const targetNode = e.target.closest('.node');
        if (targetNode) {
            activeNode = targetNode;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (!tableData) return;
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            offset.x = mouseX - tableData.pos.x;
            offset.y = mouseY - tableData.pos.y;
            activeNode.style.zIndex = 11;
        } else {
            state.isPanning = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (activeNode) {
            e.preventDefault();
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (tableData) {
                tableData.pos.x = mouseX - offset.x;
                tableData.pos.y = mouseY - offset.y;
                activeNode.style.left = `${tableData.pos.x}px`;
                activeNode.style.top = `${tableData.pos.y}px`;
                updateConnections();
            }
        } else if (state.isPanning) {
            e.preventDefault();
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.panX += dx;
            state.panY += dy;
            transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            updateConnections();
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (activeNode) { activeNode.style.zIndex = 10; activeNode = null; }
        state.isPanning = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const oldScale = state.scale;
        const zoomFactor = 1.1;
        state.scale *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        state.scale = Math.max(0.1, Math.min(state.scale, 2.5));
        state.panX = mouseX - (mouseX - state.panX) * (state.scale / oldScale);
        state.panY = mouseY - (mouseY - state.panY) * (state.scale / oldScale);
        render();
    });

    render();
    return { render, updateConnections };
}

const canvases = [
    initializeCanvas('canvas-r2', schemaR2),
    initializeCanvas('canvas-r3', schemaR3),
    initializeCanvas('canvas-r4', schemaR4)
];

document.querySelectorAll('.splitter').forEach(splitter => {
    splitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const prevPanel = splitter.previousElementSibling;
        const startX = e.clientX;
        const initialPrevWidth = prevPanel.getBoundingClientRect().width;
        
        const onMouseMove = (moveEvent) => {
            let newPrevWidth = initialPrevWidth + (moveEvent.clientX - startX);
            const MIN_WIDTH = 150;
            if (newPrevWidth < MIN_WIDTH) newPrevWidth = MIN_WIDTH;
            prevPanel.style.flex = `0 0 ${newPrevWidth}px`;
            canvases.forEach(c => c && c.render());
        };
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
});

window.addEventListener('resize', () => {
    canvases.forEach(c => c && c.render());
});
</script>

</body>
</html>