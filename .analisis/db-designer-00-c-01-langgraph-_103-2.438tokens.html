<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LangGraph Agent Analysis</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #111827; color: #d1d5db; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    .header { background-color: #1f2937; padding: 1rem 2rem; border-bottom: 1px solid #374151; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    h1 { color: white; margin: 0; }
    .controls { display: flex; align-items: center; gap: 20px; }
    .legend { display: flex; gap: 20px; font-size: 12px; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .main-container { display: flex; flex-grow: 1; }
    .panel { min-width: 150px; height: 100%; display: flex; flex-direction: column; position: relative; }
    .panel:nth-child(1) { flex: 0 1 15%; }
    .panel:nth-child(3) { flex: 1 1 70%; }
    .panel:nth-child(5) { flex: 0 1 15%; }
    .splitter { width: 6px; background-color: #374151; cursor: col-resize; flex-shrink: 0; z-index: 100; }
    .splitter:hover { background-color: #4b5563; }
    .panel-header { padding: 1rem; text-align: center; border-bottom: 1px solid #374151; background-color: #1f2937; }
    .panel-header h2 { margin: 0; font-size: 1.5rem; }
    .header-r2 { color: #fca5a5; }
    .header-r3 { color: #86efac; }
    .header-r4 { color: #c4b5fd; }
    .canvas { position: relative; width: 100%; flex-grow: 1; overflow: hidden; cursor: grab; }
    .canvas:active { cursor: grabbing; }
    .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .transform-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; z-index: 2; }

    .node { position: absolute; border: 3px solid #4b5563; border-radius: 8px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3); font-family: monospace; width: 280px; cursor: move; z-index: 10; user-select: none; padding-top: 30px; }
    .node h3 { padding: 8px 12px 8px 12px; margin: 0; border-bottom: 1px solid rgba(0,0,0,0.2); border-radius: 8px 8px 0 0; font-size: 14px; color: white; word-break: break-all; }
    .node h3 .path { font-size: 0.8em; color: #9ca3af; display: block; font-weight: normal; }
    .node ul { list-style: none; padding: 0; margin: 0; }
    .node li { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; position: relative; }
    .node li:last-child { border-bottom: none; }
    .node .col-name { font-weight: 500; }
    .node .col-type { margin-left: auto; color: #9ca3af; }

    .db-node { background-color: rgba(196, 181, 253, 0.15); border-color: #a78bfa; }
    .db-node h3 { background-color: #8b5cf6; }

    .ui-node { background-color: rgba(191, 219, 254, 0.15); border-color: #60a5fa; }
    .ui-node h3 { background-color: #3b82f6; }

    .code-node { background-color: rgba(134, 239, 172, 0.1); border-color: #4ade80; }
    .code-node h3 { background-color: #22c55e; }

    .service-node { background-color: rgba(252, 165, 165, 0.1); border-color: #f87171; }
    .service-node h3 { background-color: #ef4444; }

    .icon-display { position: absolute; top: -32px; left: 50%; transform: translateX(-50%); font-size: 64px; z-index: 12; pointer-events: none; opacity: 0.8; }
</style>
</head>
<body>

<div class="header">
    <h1>LangGraph Agent Analysis</h1>
    <div class="controls">
        <div class="legend">
             <div class="legend-item"><svg width="10" height="10" style="background:#3b82f6; border-radius:3px;"></svg> UI / IO</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#22c55e; border-radius:3px;"></svg> Code / Logic</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#8b5cf6; border-radius:3px;"></svg> Data / Schema</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#ef4444; border-radius:3px;"></svg> Service</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="panel">
        <div class="panel-header"><h2 class="header-r2">Raptor 2: Legacy</h2></div>
        <div id="canvas-r2" class="canvas"><svg id="connections-r2" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r3">Database Checkpointing</h2></div>
        <div id="canvas-r3" class="canvas"><svg id="connections-r3" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r4">Raptor 4: Future</h2></div>
        <div id="canvas-r4" class="canvas"><svg id="connections-r4" class="connections"></svg><div class="transform-container"></div></div>
    </div>
</div>

<script>
// ===================================================================================
//
//  LANGGRAPH ARCHITECTURAL ANALYSIS
//
// ===================================================================================
/*
    ARCHITECTURAL INSIGHTS FOR FUTURE AI ANALYSIS:
    This file visualizes the database checkpointing architecture of LangGraph, which provides the persistence layer for agent states. The design is modular, with separate, swappable backends for different databases (primarily Postgres and SQLite) and a clear separation between synchronous and asynchronous operations.

    **Overall Architectural Philosophy:**
    The checkpointing system is designed to make LangGraph agents durable and stateful. By saving the state of the graph at each step, it enables key features like memory (resuming conversations), time-travel debugging, and human-in-the-loop interactions. The architecture clearly distinguishes between the high-level `CheckpointSaver` interface, which LangGraph's engine interacts with, and the lower-level `Store` interface, which handles the actual key-value and vector storage.

    **Key Components and Their Roles:**
    - **Code/Logic Components (Green):**
        - `LangGraph Engine`: The core execution engine of LangGraph. It interacts with a `BaseCheckpointSaver` to save and load agent states.
        - `PostgresSaver` / `AsyncPostgresSaver`: The primary checkpointer implementations for PostgreSQL. They handle the logic of serializing a `Checkpoint` object and storing its components (channel values, versions, metadata) in the appropriate database tables. They manage connections, transactions, and database migrations. The async version (`AsyncPostgresSaver`) is crucial for non-blocking I/O in async applications.
        - `SqliteSaver` / `AsyncSqliteSaver`: Lighter-weight checkpointer implementations for SQLite. They serve a similar role to the Postgres savers but are intended for smaller-scale applications, local development, and testing.
        - `PostgresStore` / `SqliteStore`: These are the underlying key-value and vector stores. They abstract the direct database interactions, providing methods like `put`, `get`, and `search`. The checkpointers use these stores to persist data. They are also responsible for managing TTL (Time-To-Live) data expiration and vector indexing.

    - **Data/Schema Components (Purple):**
        - `Checkpoint (TypedDict)`: The in-memory representation of a graph's state at a single point in time. It contains channel values, version information, and seen versions. This object is what gets serialized and saved to the database.
        - `Checkpoints Table (DB Schema)`: The main database table where core checkpoint data (ID, timestamp, versions, metadata) is stored, usually in a JSONB or similar column.
        - `Checkpoint Blobs Table (DB Schema)`: A separate table to store larger, non-primitive values from the channels to avoid bloating the main checkpoints table.
        - `Checkpoint Writes Table (DB Schema)`: Stores pending writes from nodes that completed successfully in a step where another node failed, enabling resilient resumption.
        - `JsonPlusSerializer (Serde)`: The default serializer used to convert Python objects within a checkpoint into a format (a mix of msgpack and json) that can be stored in the database and safely deserialized later.

    - **Service Components (Red):**
        - `PostgreSQL / SQLite Database`: The underlying database service where the checkpoint data is physically stored.
        - `psycopg / aiosqlite`: The Python database drivers used to connect to and interact with PostgreSQL and SQLite, respectively.
        - `pgvector / sqlite-vec`: Database extensions that provide vector storage and search capabilities, enabling semantic search directly within the database for `Store` implementations.

    **The Checkpointing Flow:**
    1.  **Graph Step:** The `LangGraph Engine` completes a step of execution for a given `thread_id`.
    2.  **Serialize & Save:** The engine calls the `.put()` or `.aput()` method of the configured `CheckpointSaver` (e.g., `PostgresSaver`).
    3.  **Data Separation:** The saver takes the `Checkpoint` object. It separates primitive values (which will be stored directly in the main `checkpoints` table) from large or complex objects.
    4.  **Blob Storage:** The large/complex objects are serialized and stored in the `checkpoint_blobs` table, keyed by their channel and version.
    5.  **Main Checkpoint Write:** The main `Checkpoint` object (now containing only primitives and references to blobs) is serialized and written to the `checkpoints` table. The operation is typically an "UPSERT" to handle both new checkpoints and updates.
    6.  **Connection Management:** The saver manages the database connection, using a connection pool (`psycopg_pool`) for efficiency in high-concurrency environments.
    7.  **Retrieval:** When the graph is invoked again with the same `thread_id`, the engine calls `.get_tuple()` or `.aget_tuple()`. The saver reads the latest entry from the `checkpoints` table, retrieves any associated blobs from the `checkpoint_blobs` table, deserializes all components, and reconstructs the full `Checkpoint` object to resume the graph's state.
*/
const schemaR2 = { tables: [], relationships: [] };
const schemaR4 = { tables: [], relationships: [] };

const schemaR3 = {
    tables: [
        // UI / IO
        { id: 1, name: "LangGraph Engine", path: "Core Logic", nodeType: "ui", pos: { x: 50, y: 600 }, icon: "âš™ï¸", columns: [{ name: "Executes Graph" }] },
        
        // Data / Schema
        { id: 10, name: "Checkpoint", path: "In-Memory State", nodeType: "db", pos: { x: 350, y: 200 }, icon: "ðŸ“‹", columns: [{ name: "channel_values" }, { name: "channel_versions" }, { name: "versions_seen" }] },
        { id: 11, name: "Checkpoints Table", path: "DB Schema", nodeType: "db", pos: { x: 1250, y: 200 }, icon: "ðŸ—„ï¸", columns: [{ name: "thread_id (PK)" }, { name: "checkpoint_id (PK)" }, { name: "checkpoint (JSONB)" }, { name: "metadata (JSONB)" }] },
        { id: 12, name: "Checkpoint Blobs Table", path: "DB Schema", nodeType: "db", pos: { x: 1250, y: 500 }, icon: "ðŸ—„ï¸", columns: [{ name: "channel (PK)" }, { name: "version (PK)" }, { name: "blob (BYTEA)" }] },
        { id: 13, name: "Checkpoint Writes Table", path: "DB Schema", nodeType: "db", pos: { x: 1250, y: 800 }, icon: "ðŸ—„ï¸", columns: [{ name: "task_id (PK)" }, { name: "channel" }, { name: "value (BLOB)" }] },
        
        // Code / Logic
        { id: 20, name: "BaseCheckpointSaver", path: "langgraph.checkpoint.base", nodeType: "code", pos: { x: 350, y: 600 }, icon: "ðŸ’¾", columns: [{ name: ".put()" }, { name: ".get_tuple()" }, { name: ".list()" }] },
        { id: 21, name: "PostgresSaver", path: "langgraph.checkpoint.postgres", nodeType: "code", pos: { x: 650, y: 350 }, icon: "ðŸ˜", columns: [{ name: "Sync Operations" }, { name: ".setup()" }] },
        { id: 22, name: "AsyncPostgresSaver", path: "langgraph.checkpoint.postgres.aio", nodeType: "code", pos: { x: 650, y: 550 }, icon: "ðŸ˜", columns: [{ name: "Async Operations" }, { name: ".setup()" }] },
        { id: 23, name: "SqliteSaver", path: "langgraph.checkpoint.sqlite", nodeType: "code", pos: { x: 650, y: 750 }, icon: "ðŸª¶", columns: [{ name: "Sync Operations" }, { name: ".setup()" }] },
        { id: 24, name: "AsyncSqliteSaver", path: "langgraph.checkpoint.sqlite.aio", nodeType: "code", pos: { x: 650, y: 950 }, icon: "ðŸª¶", columns: [{ name: "Async Operations" }, { name: ".setup()" }] },
        { id: 25, "name": "JsonPlusSerializer", "path": "langgraph.checkpoint.serde", "nodeType": "code", "pos": { "x": 350, "y": 950 }, "icon": "ðŸ“¦", "columns": [{ "name": ".dumps_typed()" }, { "name": ".loads_typed()" }] },
        { id: 26, name: "PostgresStore / SqliteStore", path: "langgraph.store", nodeType: "code", pos: { x: 950, y: 1200 }, icon: "ðŸ—ƒï¸", columns: [{ name: ".put()" }, { name: ".get()" }, { name: ".search()" }, { name: ".sweep_ttl()" }] },
        
        // Services
        { id: 40, name: "PostgreSQL", path: "Database Service", nodeType: "service", pos: { x: 1550, y: 500 }, icon: "ðŸ˜", columns: [] },
        { id: 41, name: "SQLite", path: "Database Service", nodeType: "service", pos: { x: 1550, y: 800 }, icon: "ðŸª¶", columns: [] },
        { id: 42, name: "psycopg / psycopg-pool", path: "DB Driver", nodeType: "service", pos: { x: 950, y: 450 }, icon: "ðŸ”Œ", columns: [{ name: "Sync & Async PG Driver" }] },
        { id: 43, name: "aiosqlite", path: "DB Driver", nodeType: "service", pos: { x: 950, y: 850 }, icon: "ðŸ”Œ", columns: [{ name: "Async SQLite Driver" }] },
        { id: 44, name: "pgvector / sqlite-vec", path: "DB Extension", nodeType: "service", pos: { x: 1250, y: 1200 }, icon: "ðŸ”", columns: [{ name: "Vector Search" }] }
    ],
    relationships: [
        { from: { table: "LangGraph Engine" }, to: { table: "BaseCheckpointSaver" }, type: "flow", label: "Uses" },
        { from: { table: "BaseCheckpointSaver" }, to: { table: "Checkpoint" }, type: "read", label: "Receives" },
        { from: { table: "BaseCheckpointSaver" }, to: { table: "JsonPlusSerializer" }, type: "flow", label: "Uses" },
        
        { from: { table: "PostgresSaver" }, to: { table: "BaseCheckpointSaver" }, type: "flow", label: "Implements" },
        { from: { table: "AsyncPostgresSaver" }, to: { table: "BaseCheckpointSaver" }, type: "flow", label: "Implements" },
        { from: { table: "SqliteSaver" }, to: { table: "BaseCheckpointSaver" }, type: "flow", label: "Implements" },
        { from: { table: "AsyncSqliteSaver" }, to: { table: "BaseCheckpointSaver" }, type: "flow", label: "Implements" },
        
        { from: { table: "PostgresSaver" }, to: { table: "psycopg / psycopg-pool" }, type: "flow", label: "Uses" },
        { from: { table: "AsyncPostgresSaver" }, to: { table: "psycopg / psycopg-pool" }, type: "flow", label: "Uses" },
        { from: { table: "SqliteSaver" }, to: { table: "SQLite" }, type: "flow", label: "Uses Driver For" },
        { from: { table: "AsyncSqliteSaver" }, to: { table: "aiosqlite" }, type: "flow", label: "Uses" },

        { from: { table: "psycopg / psycopg-pool" }, to: { table: "PostgreSQL" }, type: "flow", label: "Connects to" },
        { from: { table: "aiosqlite" }, to: { table: "SQLite" }, type: "flow", label: "Connects to" },
        
        { from: { table: "PostgresSaver" }, to: { table: "Checkpoints Table" }, type: "write", label: "Writes to" },
        { from: { table: "PostgresSaver" }, to: { table: "Checkpoint Blobs Table" }, type: "write", label: "Writes to" },
        { from: { table: "PostgresSaver" }, to: { table: "Checkpoint Writes Table" }, type: "write", label: "Writes to" },
        
        { from: { table: "Checkpoints Table" }, to: { table: "PostgreSQL" }, type: "flow", label: "Lives in" },
        { from: { table: "Checkpoint Blobs Table" }, to: { table: "PostgreSQL" }, type: "flow", label: "Lives in" },
        { from: { table: "Checkpoint Writes Table" }, to: { table: "PostgreSQL" }, type: "flow", label: "Lives in" },

        { from: { table: "SqliteSaver" }, to: { table: "SQLite" }, type: "write", label: "Writes Schema to" },

        { from: { table: "PostgresStore / SqliteStore" }, to: { table: "psycopg / psycopg-pool" }, type: "flow" },
        { from: { table: "PostgresStore / SqliteStore" }, to: { table: "aiosqlite" }, type: "flow" },
        { from: { table: "PostgresStore / SqliteStore" }, to: { table: "pgvector / sqlite-vec" }, type: "flow", label: "Uses" },
        { from: { table: "pgvector / sqlite-vec" }, to: { table: "PostgreSQL" }, type: "flow" },
        { from: { table: "pgvector / sqlite-vec" }, to: { table: "SQLite" }, type: "flow" }
    ]
};

// ===================================================================================
//  RENDERING LOGIC
// ===================================================================================
function initializeCanvas(canvasId, schema) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const transformContainer = canvas.querySelector('.transform-container');
    const svg = canvas.querySelector('.connections');
    let state = { scale: 0.7, panX: 50, panY: 50, isPanning: false, lastMouse: { x: 0, y: 0 } };

    function render() {
        if (!transformContainer || !svg) return;
        transformContainer.innerHTML = '';
        transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        
        schema.tables.forEach(table => {
            const node = document.createElement('div');
            node.id = `${canvasId}-${table.id}`;
            node.classList.add('node', `${table.nodeType}-node`);
            node.style.left = `${table.pos.x}px`;
            node.style.top = `${table.pos.y}px`;

            const header = document.createElement('h3');
            const pathSpan = table.path ? `<span class="path">${table.path}</span>` : '';
            header.innerHTML = `${pathSpan}${table.name}`;

            const list = document.createElement('ul');
            list.innerHTML = (table.columns || []).map(col => {
                const colName = typeof col === 'string' ? col : col.name;
                const colType = typeof col === 'string' ? '' : col.type;
                const colId = colName.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                return `<li id="${canvasId}-${table.id}-${colId}"><span class="col-name">${colName}</span>${colType ? `<span class="col-type">${colType}</span>` : ''}</li>`;
            }).join('');
            
            if (table.icon) {
                const iconDisplay = document.createElement('div');
                iconDisplay.className = 'icon-display';
                iconDisplay.textContent = table.icon;
                node.appendChild(iconDisplay);
            }

            node.appendChild(header);
            node.appendChild(list);
            transformContainer.appendChild(node);
        });
        updateConnections();
    }
    
    function getElementPortPosition(elId) {
        const el = document.getElementById(elId);
        if (!el) return null;
        const parentNode = el.closest('.node');
        if (!parentNode) return null;
        const isNodeConnection = el.classList.contains('node');
        
        const parentRect = parentNode.getBoundingClientRect();
        const elRect = isNodeConnection ? parentRect : el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        const y = isNodeConnection ? (parentRect.top - canvasRect.top + parentRect.height / 2) : (elRect.top - canvasRect.top + elRect.height / 2);
        const leftX = (parentRect.left - canvasRect.left);
        const rightX = (parentRect.right - canvasRect.left);

        return { left: {x: leftX, y: y}, right: {x: rightX, y: y} };
    }

    function updateConnections() {
        if (!svg) return;
        svg.innerHTML = `<defs>
            <marker id="arrowhead-read-${canvasId}" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#6b7283" /></marker>
            <marker id="arrowhead-write-${canvasId}" markerWidth="12" markerHeight="9" refX="10" refY="4.5" orient="auto"><polygon points="0 0, 12 4.5, 0 9" fill="#86efac" /></marker>
            <marker id="arrowhead-flow-${canvasId}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#9ca3af" /></marker>
        </defs>`;
        
        const idMap = new Map(schema.tables.map(t => [t.name, t.id]));

        schema.relationships.forEach(rel => {
            const fromId = idMap.get(rel.from.table);
            const toId = idMap.get(rel.to.table);
            if(!fromId || !toId) return;

            let fromColName = (rel.from.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            let toColName = (rel.to.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            
            let fromElId = `${canvasId}-${fromId}${fromColName ? '-' + fromColName : ''}`;
            if (!document.getElementById(fromElId)) fromElId = `${canvasId}-${fromId}`;

            let toElId = `${canvasId}-${toId}${toColName ? '-' + toColName : ''}`;
            if (!document.getElementById(toElId)) toElId = `${canvasId}-${toId}`;
            
            const fromPorts = getElementPortPosition(fromElId);
            const toPorts = getElementPortPosition(toElId);
            if (!fromPorts || !toPorts) return;

            const fromPos = toPorts.right.x < fromPorts.left.x ? fromPorts.left : fromPorts.right;
            const toPos = toPorts.right.x < fromPorts.left.x ? toPorts.right : toPorts.left;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);

            if (rel.type === 'write') {
                line.setAttribute('stroke', '#86efac'); line.setAttribute('stroke-width', 4); line.setAttribute('marker-end', `url(#arrowhead-write-${canvasId})`);
            } else if (rel.type === 'flow') {
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2); line.setAttribute('stroke-dasharray', `6,6`); line.setAttribute('marker-end', `url(#arrowhead-flow-${canvasId})`);
            } else { // 'read' is the default
                line.setAttribute('stroke', '#6b7283'); line.setAttribute('stroke-width', 2); line.setAttribute('marker-end', `url(#arrowhead-read-${canvasId})`);
            }
            svg.appendChild(line);
        });
    }

    let activeNode = null, offset = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        const targetNode = e.target.closest('.node');
        if (targetNode) {
            activeNode = targetNode;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (!tableData) return;
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            offset.x = mouseX - tableData.pos.x;
            offset.y = mouseY - tableData.pos.y;
            activeNode.style.zIndex = 11;
        } else {
            state.isPanning = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (activeNode) {
            e.preventDefault();
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (tableData) {
                tableData.pos.x = mouseX - offset.x;
                tableData.pos.y = mouseY - offset.y;
                activeNode.style.left = `${tableData.pos.x}px`;
                activeNode.style.top = `${tableData.pos.y}px`;
                updateConnections();
            }
        } else if (state.isPanning) {
            e.preventDefault();
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.panX += dx;
            state.panY += dy;
            transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            updateConnections();
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (activeNode) { activeNode.style.zIndex = 10; activeNode = null; }
        state.isPanning = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const oldScale = state.scale;
        const zoomFactor = 1.1;
        state.scale *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        state.scale = Math.max(0.1, Math.min(state.scale, 2.5));
        state.panX = mouseX - (mouseX - state.panX) * (state.scale / oldScale);
        state.panY = mouseY - (mouseY - state.panY) * (state.scale / oldScale);
        render();
    });

    render();
    return { render, updateConnections };
}

const canvases = [
    initializeCanvas('canvas-r2', schemaR2),
    initializeCanvas('canvas-r3', schemaR3),
    initializeCanvas('canvas-r4', schemaR4)
];

document.querySelectorAll('.splitter').forEach(splitter => {
    splitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const prevPanel = splitter.previousElementSibling;
        const startX = e.clientX;
        const initialPrevWidth = prevPanel.getBoundingClientRect().width;
        
        const onMouseMove = (moveEvent) => {
            let newPrevWidth = initialPrevWidth + (moveEvent.clientX - startX);
            const MIN_WIDTH = 150;
            if (newPrevWidth < MIN_WIDTH) newPrevWidth = MIN_WIDTH;
            prevPanel.style.flex = `0 0 ${newPrevWidth}px`;
            canvases.forEach(c => c && c.render());
        };
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
});

window.addEventListener('resize', () => {
    canvases.forEach(c => c && c.render());
});
</script>

</body>
</html>