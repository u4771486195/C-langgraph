<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LangGraph Agent Analysis</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: #111827; color: #d1d5db; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    .header { background-color: #1f2937; padding: 1rem 2rem; border-bottom: 1px solid #374151; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
    h1 { color: white; margin: 0; }
    .controls { display: flex; align-items: center; gap: 20px; }
    .legend { display: flex; gap: 20px; font-size: 12px; align-items: center; }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .main-container { display: flex; flex-grow: 1; }
    .panel { min-width: 150px; height: 100%; display: flex; flex-direction: column; position: relative; }
    .panel:nth-child(1) { flex: 0 1 15%; }
    .panel:nth-child(3) { flex: 1 1 70%; }
    .panel:nth-child(5) { flex: 0 1 15%; }
    .splitter { width: 6px; background-color: #374151; cursor: col-resize; flex-shrink: 0; z-index: 100; }
    .splitter:hover { background-color: #4b5563; }
    .panel-header { padding: 1rem; text-align: center; border-bottom: 1px solid #374151; background-color: #1f2937; }
    .panel-header h2 { margin: 0; font-size: 1.5rem; }
    .header-r2 { color: #fca5a5; }
    .header-r3 { color: #86efac; }
    .header-r4 { color: #c4b5fd; }
    .canvas { position: relative; width: 100%; flex-grow: 1; overflow: hidden; cursor: grab; }
    .canvas:active { cursor: grabbing; }
    .connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .transform-container { position: absolute; top: 0; left: 0; transform-origin: 0 0; z-index: 2; }

    .node { position: absolute; border: 3px solid #4b5563; border-radius: 8px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3); font-family: monospace; width: 280px; cursor: move; z-index: 10; user-select: none; padding-top: 30px; }
    .node h3 { padding: 8px 12px 8px 12px; margin: 0; border-bottom: 1px solid rgba(0,0,0,0.2); border-radius: 8px 8px 0 0; font-size: 14px; color: white; word-break: break-all; }
    .node h3 .path { font-size: 0.8em; color: #9ca3af; display: block; font-weight: normal; }
    .node ul { list-style: none; padding: 0; margin: 0; }
    .node li { display: flex; align-items: center; padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; position: relative; }
    .node li:last-child { border-bottom: none; }
    .node .col-name { font-weight: 500; }
    .node .col-type { margin-left: auto; color: #9ca3af; }

    .db-node { background-color: rgba(196, 181, 253, 0.15); border-color: #a78bfa; }
    .db-node h3 { background-color: #8b5cf6; }

    .ui-node { background-color: rgba(191, 219, 254, 0.15); border-color: #60a5fa; }
    .ui-node h3 { background-color: #3b82f6; }

    .code-node { background-color: rgba(134, 239, 172, 0.1); border-color: #4ade80; }
    .code-node h3 { background-color: #22c55e; }

    .service-node { background-color: rgba(252, 165, 165, 0.1); border-color: #f87171; }
    .service-node h3 { background-color: #ef4444; }

    .icon-display { position: absolute; top: -32px; left: 50%; transform: translateX(-50%); font-size: 64px; z-index: 12; pointer-events: none; opacity: 0.8; }
</style>
</head>
<body>

<div class="header">
    <h1>LangGraph Agent Analysis</h1>
    <div class="controls">
        <div class="legend">
             <div class="legend-item"><svg width="10" height="10" style="background:#3b82f6; border-radius:3px;"></svg> UI / IO</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#22c55e; border-radius:3px;"></svg> Code / Logic</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#8b5cf6; border-radius:3px;"></svg> Data / Schema</div>
            <div class="legend-item"><svg width="10" height="10" style="background:#ef4444; border-radius:3px;"></svg> Service</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="panel">
        <div class="panel-header"><h2 class="header-r2">Raptor 2: Legacy</h2></div>
        <div id="canvas-r2" class="canvas"><svg id="connections-r2" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r3">Code Assistant Agent</h2></div>
        <div id="canvas-r3" class="canvas"><svg id="connections-r3" class="connections"></svg><div class="transform-container"></div></div>
    </div>
    <div class="splitter"></div>
    <div class="panel">
        <div class="panel-header"><h2 class="header-r4">Raptor 4: Future</h2></div>
        <div id="canvas-r4" class="canvas"><svg id="connections-r4" class="connections"></svg><div class="transform-container"></div></div>
    </div>
</div>

<script>
// ===================================================================================
//
//  LANGGRAPH ARCHITECTURAL ANALYSIS
//
// ===================================================================================
/*
    ARCHITECTURAL INSIGHTS FOR FUTURE AI ANALYSIS:
    This file visualizes a "Code Assistant" agent architecture. This pattern showcases how a language model can be augmented with tools to both write and execute code, creating a powerful problem-solving loop. It is a specific and highly practical application of the ReAct (Reason, Act) paradigm.

    **Overall Architectural Philosophy:**
    The agent's goal is to fulfill a user's request by generating and running Python code. It operates in a stateful loop: the agent node (powered by an LLM) generates a snippet of code, which is then passed to an executor node. The result of the execution (either the output or an error) is fed back into the agent's state. The agent can then analyze this feedback to debug the code, generate new code, or decide that the task is complete and provide the final answer. This iterative process of generation, execution, and reflection is what allows the agent to build complex solutions and self-correct.

    **Key Components and Their Roles:**
    - **Code/Logic Components (Green):**
        - `Graph Definition`: The entry point where the `StateGraph` is defined with the `AgentState` schema. This is where the two primary nodes (`agent` and `action`) and the conditional edge (`should_continue`) are registered, establishing the workflow logic.
        - `agent (Node)`: The core reasoning engine. It takes the full `AgentState` (including the user prompt and any previous code execution history) and invokes the LLM. The LLM's role is to decide what to do next: either generate a `tool_calls` message to have code executed or provide the final answer to the user.
        - `action (ToolNode)`: The execution engine. This pre-built `ToolNode` is specifically designed to handle `tool_calls` from the `agent` node. It parses the tool call, invokes the corresponding tool (in this case, the `python_repl`), and captures the `stdout`, `stderr`, or a rendered image from the execution.
        - `should_continue (Conditional Edge)`: The router that directs the flow of the graph. After the `agent` node runs, this edge checks the last message in the state.
            - If the message contains `tool_calls`, it routes control to the `action` node for execution.
            - If the message does not contain tool calls, it determines the agent is finished and routes to `END`.

    - **Data/Schema Components (Purple):**
        - `AgentState (TypedDict)`: The shared memory that persists across the agent's execution loop. It contains a list of `messages` which tracks the entire conversation history, including `HumanMessage` (the prompt), `AIMessage` (the agent's thoughts and tool calls), and `ToolMessage` (the results of code execution).

    - **UI/IO Components (Blue):**
        - `User Input`: The initial prompt from the user, such as "Plot a sine wave and show me the image."
        - `Final Output`: The result returned by the agent when it routes to `END`. This could be a text summary or, in this specific example, a rendered image file.

    - **Service Components (Red):**
        - `LLM (GPT-4)`: A large language model with strong code generation and tool-calling capabilities. It is the "brain" behind the `agent` node.
        - `Python REPL (Tool)`: A sandboxed Python execution environment. It is the "hands" of the agent, allowing it to run the code it generates and interact with a file system to save outputs like images.

    **The Control and Data Flow:**
    1.  **Invocation:** The user provides a prompt, which is added to the `AgentState` as a `HumanMessage`.
    2.  **Reasoning (Agent Node):** The `agent` node is called. The LLM analyzes the prompt and the message history. For the initial turn, it will generate an `AIMessage` containing a `tool_calls` request with the Python code needed to solve the problem (e.g., code to generate a sine wave plot using matplotlib).
    3.  **Routing (Conditional Edge):** The `should_continue` edge inspects the `AIMessage`. Since it finds a `tool_calls` request, it directs the graph to the `action` node.
    4.  **Action (ToolNode):** The `action` node receives the tool call and executes the Python code using the `Python REPL` tool. The tool returns the result (e.g., "Image saved to plot.png"). This result is wrapped in a `ToolMessage`.
    5.  **State Update:** The new `AIMessage` (with the tool call) and the `ToolMessage` (with the execution result) are appended to the `messages` list in `AgentState`.
    6.  **Loop & Reflection:** Control returns to the `agent` node. The LLM now sees the original prompt, the code it wrote, and the successful execution result. It determines the task is complete.
    7.  **Final Routing:** The `agent` node now produces a final `AIMessage` without any `tool_calls`, perhaps saying "Here is the plot you requested." The `should_continue` edge sees no tool calls and routes to `END`.
    8.  **Output:** The final state, including the path to the generated image, is returned to the user. If an error had occurred in Step 4, the `ToolMessage` would contain the error traceback, and in Step 6, the agent would attempt to debug and generate corrected code, continuing the loop.
*/
const schemaR2 = { tables: [], relationships: [] };
const schemaR4 = { tables: [], relationships: [] };

const schemaR3 = {
    tables: [
        // UI / IO
        { id: 1, name: "User Input", path: "User Interaction", nodeType: "ui", pos: { x: 50, y: 500 }, icon: "ðŸ’¬", columns: [{ name: "Prompt" }, { name: "'Plot a sine wave...'" }] },
        { id: 2, name: "Final Output", path: "User Interaction", nodeType: "ui", pos: { x: 1550, y: 500 }, icon: "ðŸ–¼ï¸", columns: [{ name: "Image File" }, { name: "'plot.png'" }] },

        // Data / Schema
        { id: 10, name: "AgentState", path: "TypedDict", nodeType: "db", pos: { x: 500, y: 150 }, icon: "ðŸ“‹", columns: [{ name: "messages: List[BaseMessage]" }] },
        
        // Code / Logic
        { id: 20, name: "Graph Definition", path: "langgraph.graph.StateGraph", nodeType: "code", pos: { x: 50, y: 200 }, icon: " G ", columns: [{ name: ".add_node('agent', ...)" }, { name: ".add_node('action', ...)" }, { name: ".add_conditional_edges(...)" }] },
        { id: 21, name: "Agent (Node)", path: "Workflow Logic: Reason", nodeType: "code", pos: { x: 500, y: 500 }, icon: "ðŸ§ ", columns: [{ name: "model.invoke(state)" }, { name: "Returns: AIMessage" }, { name: "with tool_calls" }] },
        { id: 22, name: "should_continue (Edge)", path: "Workflow Logic: Router", nodeType: "code", pos: { x: 950, y: 500 }, icon: "ðŸ”€", columns: [{ name: "if last_message has tool_calls:" }, { name: "  return 'action'" }, { name: "else: return END" }] },
        { id: 23, name: "Code Executor (ToolNode)", path: "Workflow Logic: Act", nodeType: "code", pos: { x: 500, y: 800 }, icon: "âš™ï¸", columns: [{ name: "tool_executor.invoke(tool_call)" }, { name: "Returns: ToolMessage" }] },

        // Services
        { id: 40, name: "LLM", path: "OpenAI GPT-4", nodeType: "service", pos: { x: 950, y: 200 }, icon: "ðŸ¤–", columns: [{ name: ".bind_tools([python_repl])" }] },
        { id: 41, name: "Python REPL", path: "Tool", nodeType: "service", pos: { x: 950, y: 800 }, icon: "ðŸ", columns: [{ name: "Executes Python code" }] },
    ],
    relationships: [
        // Initial call
        { from: { table: "User Input" }, to: { table: "AgentState" }, type: "write", label: "Populates messages" },
        { from: { table: "Graph Definition" }, to: { table: "Agent (Node)" }, type: "flow", label: "Sets entry point" },
        
        // Main Agent Loop
        { from: { table: "AgentState" }, to: { table: "Agent (Node)" }, type: "read", label: "Reads history" },
        { from: { table: "Agent (Node)" }, to: { table: "LLM" }, type: "flow", label: "Invokes model" },
        { from: { table: "LLM" }, to: { table: "Agent (Node)" }, type: "flow", label: "Returns AIMessage" },
        { from: { table: "Agent (Node)" }, to: { table: "AgentState" }, type: "write", label: "Appends AIMessage (w/ tool call)" },
        
        // Routing
        { from: { table: "Agent (Node)" }, to: { table: "should_continue (Edge)" }, type: "flow", label: "Triggers decision" },
        { from: { table: "should_continue (Edge)" }, to: { table: "AgentState" }, type: "read", label: "Checks last message" },
        { from: { table: "should_continue (Edge)" }, to: { table: "Code Executor (ToolNode)" }, type: "flow", label: "Routes to action" },
        
        // Tool Execution
        { from: { table: "Code Executor (ToolNode)" }, to: { table: "AgentState" }, type: "read", label: "Gets tool call" },
        { from: { table: "Code Executor (ToolNode)" }, to: { table: "Python REPL" }, type: "flow", label: "Executes code" },
        { from: { table: "Python REPL" }, to: { table: "Code Executor (ToolNode)" }, type: "flow", label: "Returns result/error" },
        { from: { table: "Code Executor (ToolNode)" }, to: { table: "AgentState" }, type: "write", label: "Appends ToolMessage (result)" },
        
        // Loop back
        { from: { table: "Code Executor (ToolNode)" }, to: { table: "Agent (Node)" }, type: "flow", label: "Continues loop" },
        
        // Finish
        { from: { table: "should_continue (Edge)" }, to: { table: "Final Output" }, type: "flow", label: "Routes to END" },
        { from: { table: "Python REPL" }, to: { table: "Final Output" }, type: "write", label: "Saves image file" }
    ]
};

// ===================================================================================
//  RENDERING LOGIC
// ===================================================================================
function initializeCanvas(canvasId, schema) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const transformContainer = canvas.querySelector('.transform-container');
    const svg = canvas.querySelector('.connections');
    let state = { scale: 0.7, panX: 50, panY: 50, isPanning: false, lastMouse: { x: 0, y: 0 } };

    function render() {
        if (!transformContainer || !svg) return;
        transformContainer.innerHTML = '';
        transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        
        schema.tables.forEach(table => {
            const node = document.createElement('div');
            node.id = `${canvasId}-${table.id}`;
            node.classList.add('node', `${table.nodeType}-node`);
            node.style.left = `${table.pos.x}px`;
            node.style.top = `${table.pos.y}px`;

            const header = document.createElement('h3');
            const pathSpan = table.path ? `<span class="path">${table.path}</span>` : '';
            header.innerHTML = `${pathSpan}${table.name}`;

            const list = document.createElement('ul');
            list.innerHTML = (table.columns || []).map(col => {
                const colName = typeof col === 'string' ? col : col.name;
                const colType = typeof col === 'string' ? '' : col.type;
                const colId = colName.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
                return `<li id="${canvasId}-${table.id}-${colId}"><span class="col-name">${colName}</span>${colType ? `<span class="col-type">${colType}</span>` : ''}</li>`;
            }).join('');
            
            if (table.icon) {
                const iconDisplay = document.createElement('div');
                iconDisplay.className = 'icon-display';
                iconDisplay.textContent = table.icon;
                node.appendChild(iconDisplay);
            }

            node.appendChild(header);
            node.appendChild(list);
            transformContainer.appendChild(node);
        });
        updateConnections();
    }
    
    function getElementPortPosition(elId) {
        const el = document.getElementById(elId);
        if (!el) return null;
        const parentNode = el.closest('.node');
        if (!parentNode) return null;
        const isNodeConnection = el.classList.contains('node');
        
        const parentRect = parentNode.getBoundingClientRect();
        const elRect = isNodeConnection ? parentRect : el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        const y = isNodeConnection ? (parentRect.top - canvasRect.top + parentRect.height / 2) : (elRect.top - canvasRect.top + elRect.height / 2);
        const leftX = (parentRect.left - canvasRect.left);
        const rightX = (parentRect.right - canvasRect.left);

        return { left: {x: leftX, y: y}, right: {x: rightX, y: y} };
    }

    function updateConnections() {
        if (!svg) return;
        svg.innerHTML = `<defs>
            <marker id="arrowhead-read-${canvasId}" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#6b7283" /></marker>
            <marker id="arrowhead-write-${canvasId}" markerWidth="12" markerHeight="9" refX="10" refY="4.5" orient="auto"><polygon points="0 0, 12 4.5, 0 9" fill="#86efac" /></marker>
            <marker id="arrowhead-flow-${canvasId}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#9ca3af" /></marker>
        </defs>`;
        
        const idMap = new Map(schema.tables.map(t => [t.name, t.id]));

        schema.relationships.forEach(rel => {
            const fromId = idMap.get(rel.from.table);
            const toId = idMap.get(rel.to.table);
            if(!fromId || !toId) return;

            let fromColName = (rel.from.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            let toColName = (rel.to.column || "").replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            
            let fromElId = `${canvasId}-${fromId}${fromColName ? '-' + fromColName : ''}`;
            if (!document.getElementById(fromElId)) fromElId = `${canvasId}-${fromId}`;

            let toElId = `${canvasId}-${toId}${toColName ? '-' + toColName : ''}`;
            if (!document.getElementById(toElId)) toElId = `${canvasId}-${toId}`;
            
            const fromPorts = getElementPortPosition(fromElId);
            const toPorts = getElementPortPosition(toElId);
            if (!fromPorts || !toPorts) return;

            const fromPos = toPorts.right.x < fromPorts.left.x ? fromPorts.left : fromPorts.right;
            const toPos = toPorts.right.x < fromPorts.left.x ? toPorts.right : toPorts.left;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromPos.x); line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x); line.setAttribute('y2', toPos.y);

            if (rel.type === 'write') {
                line.setAttribute('stroke', '#86efac'); line.setAttribute('stroke-width', 4); line.setAttribute('marker-end', `url(#arrowhead-write-${canvasId})`);
            } else if (rel.type === 'flow') {
                line.setAttribute('stroke', '#9ca3af'); line.setAttribute('stroke-width', 2); line.setAttribute('stroke-dasharray', `6,6`); line.setAttribute('marker-end', `url(#arrowhead-flow-${canvasId})`);
            } else { // 'read' is the default
                line.setAttribute('stroke', '#6b7283'); line.setAttribute('stroke-width', 2); line.setAttribute('marker-end', `url(#arrowhead-read-${canvasId})`);
            }
            svg.appendChild(line);
        });
    }

    let activeNode = null, offset = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        const targetNode = e.target.closest('.node');
        if (targetNode) {
            activeNode = targetNode;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (!tableData) return;
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            offset.x = mouseX - tableData.pos.x;
            offset.y = mouseY - tableData.pos.y;
            activeNode.style.zIndex = 11;
        } else {
            state.isPanning = true;
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (activeNode) {
            e.preventDefault();
            const mouseX = (e.clientX - canvas.getBoundingClientRect().left - state.panX) / state.scale;
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top - state.panY) / state.scale;
            const tableData = schema.tables.find(t => `${canvasId}-${t.id}` === activeNode.id);
            if (tableData) {
                tableData.pos.x = mouseX - offset.x;
                tableData.pos.y = mouseY - offset.y;
                activeNode.style.left = `${tableData.pos.x}px`;
                activeNode.style.top = `${tableData.pos.y}px`;
                updateConnections();
            }
        } else if (state.isPanning) {
            e.preventDefault();
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.panX += dx;
            state.panY += dy;
            transformContainer.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
            updateConnections();
            state.lastMouse.x = e.clientX;
            state.lastMouse.y = e.clientY;
        }
    });
    
    document.addEventListener('mouseup', () => {
        if (activeNode) { activeNode.style.zIndex = 10; activeNode = null; }
        state.isPanning = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const oldScale = state.scale;
        const zoomFactor = 1.1;
        state.scale *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
        state.scale = Math.max(0.1, Math.min(state.scale, 2.5));
        state.panX = mouseX - (mouseX - state.panX) * (state.scale / oldScale);
        state.panY = mouseY - (mouseY - state.panY) * (state.scale / oldScale);
        render();
    });

    render();
    return { render, updateConnections };
}

const canvases = [
    initializeCanvas('canvas-r2', schemaR2),
    initializeCanvas('canvas-r3', schemaR3),
    initializeCanvas('canvas-r4', schemaR4)
];

document.querySelectorAll('.splitter').forEach(splitter => {
    splitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const prevPanel = splitter.previousElementSibling;
        const startX = e.clientX;
        const initialPrevWidth = prevPanel.getBoundingClientRect().width;
        
        const onMouseMove = (moveEvent) => {
            let newPrevWidth = initialPrevWidth + (moveEvent.clientX - startX);
            const MIN_WIDTH = 150;
            if (newPrevWidth < MIN_WIDTH) newPrevWidth = MIN_WIDTH;
            prevPanel.style.flex = `0 0 ${newPrevWidth}px`;
            canvases.forEach(c => c && c.render());
        };
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    });
});

window.addEventListener('resize', () => {
    canvases.forEach(c => c && c.render());
});
</script>

</body>
</html>