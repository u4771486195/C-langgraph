    { url = "https://files.pythonhosted.org/packages/27/1a/199f9587e8cb08a0658f9c30f3799244307614148ffe8b1e3aa22f324dea/greenlet-3.2.3-cp313-cp313-win_amd64.whl", hash = "sha256:5195fb1e75e592dd04ce79881c8a22becdfa3e6f500e7feb059b1e6fdd54d3e3", size = 297603, upload-time = "2025-06-05T16:20:12.651Z" },
    { url = "https://files.pythonhosted.org/packages/d8/ca/accd7aa5280eb92b70ed9e8f7fd79dc50a2c21d8c73b9a0856f5b564e222/greenlet-3.2.3-cp314-cp314-macosx_11_0_universal2.whl", hash = "sha256:3d04332dddb10b4a211b68111dabaee2e1a073663d117dc10247b5b1642bac86", size = 271479, upload-time = "2025-06-05T16:10:47.525Z" },
    { url = "https://files.pythonhosted.org/packages/55/71/01ed9895d9eb49223280ecc98a557585edfa56b3d0e965b9fa9f7f06b6d9/greenlet-3.2.3-cp314-cp314-manylinux2014_aarch64.manylinux_2_17_aarch64.whl", hash = "sha256:8186162dffde068a465deab08fc72c767196895c39db26ab1c17c0b77a6d8b97", size = 683952, upload-time = "2025-06-05T16:38:55.125Z" },
    { url = "https://files.pythonhosted.org/packages/ea/61/638c4bdf460c3c678a0a1ef4c200f347dff80719597e53b5edb2fb27ab54/greenlet-3.2.3-cp314-cp314-manylinux2014_ppc64le.manylinux_2_17_ppc64le.whl", hash = "sha256:f4bfbaa6096b1b7a200024784217defedf46a07c2eee1a498e94a1b5f8ec5728", size = 696917, upload-time = "2025-06-05T16:41:38.959Z" },
    { url = "https://files.pythonhosted.org/packages/22/cc/0bd1a7eb759d1f3e3cc2d1bc0f0b487ad3cc9f34d74da4b80f226fde4ec3/greenlet-3.2.3-cp314-cp314-manylinux2014_s390x.manylinux_2_17_s390x.whl", hash = "sha256:ed6cfa9200484d234d8394c70f5492f144b20d4533f69262d530a1a082f6ee9a", size = 692443, upload-time = "2025-06-05T16:48:23.113Z" },
    { url = "https://files.pythonhosted.org/packages/67/10/b2a4b63d3f08362662e89c103f7fe28894a51ae0bc890fabf37d1d780e52/greenlet-3.2.3-cp314-cp314-manylinux2014_x86_64.manylinux_2_17_x86_64.whl", hash = "sha256:02b0df6f63cd15012bed5401b47829cfd2e97052dc89da3cfaf2c779124eb892", size = 692995, upload-time = "2025-06-05T16:13:07.972Z" },
    { url = "https://files.pythonhosted.org/packages/5a/c6/ad82f148a4e3ce9564056453a71529732baf5448ad53fc323e37efe34f66/greenlet-3.2.3-cp314-cp314-manylinux_2_24_x86_64.manylinux_2_28_x86_64.whl", hash = "sha256:86c2d68e87107c1792e2e8d5399acec2487a4e993ab76c792408e59394d52141", size = 655320, upload-time = "2025-06-05T16:12:53.453Z" },
    { url = "https://files.pythonhosted.org/packages/5c/4f/aab73ecaa6b3086a4c89863d94cf26fa84cbff63f52ce9bc4342b3087a06/greenlet-3.2.3-cp314-cp314-win_amd64.whl", hash = "sha256:8c47aae8fbbfcf82cc13327ae802ba13c9c36753b67e760023fd116bc124a62a", size = 301236, upload-time = "2025-06-05T16:15:20.111Z" },
]

[[package]]
name = "griffe"
version = "1.7.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a9/3e/5aa9a61f7c3c47b0b52a1d930302992229d191bf4bc76447b324b731510a/griffe-1.7.3.tar.gz", hash = "sha256:52ee893c6a3a968b639ace8015bec9d36594961e156e23315c8e8e51401fa50b", size = 395137, upload-time = "2025-04-23T11:29:09.147Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/58/c6/5c20af38c2a57c15d87f7f38bee77d63c1d2a3689f74fefaf35915dd12b2/griffe-1.7.3-py3-none-any.whl", hash = "sha256:c6b3ee30c2f0f17f30bcdef5068d6ab7a2a4f1b8bf1a3e74b56fffd21e1c5f75", size = 129303, upload-time = "2025-04-23T11:29:07.145Z" },
]

[[package]]
name = "grpcio"
version = "1.73.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/79/e8/b43b851537da2e2f03fa8be1aef207e5cbfb1a2e014fbb6b40d24c177cd3/grpcio-1.73.1.tar.gz", hash = "sha256:7fce2cd1c0c1116cf3850564ebfc3264fba75d3c74a7414373f1238ea365ef87", size = 12730355, upload-time = "2025-06-26T01:53:24.622Z" }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e4/41/921565815e871d84043e73e2c0e748f0318dab6fa9be872cd042778f14a9/grpcio-1.73.1-cp311-cp311-linux_armv7l.whl", hash = "sha256:ba2cea9f7ae4bc21f42015f0ec98f69ae4179848ad744b210e7685112fa507a1", size = 5363853, upload-time = "2025-06-26T01:52:05.5Z" },
    { url = "https://files.pythonhosted.org/packages/b0/cc/9c51109c71d068e4d474becf5f5d43c9d63038cec1b74112978000fa72f4/grpcio-1.73.1-cp311-cp311-macosx_11_0_universal2.whl", hash = "sha256:d74c3f4f37b79e746271aa6cdb3a1d7e4432aea38735542b23adcabaaee0c097", size = 10621476, upload-time = "2025-06-26T01:52:07.211Z" },
    { url = "https://files.pythonhosted.org/packages/8f/d3/33d738a06f6dbd4943f4d377468f8299941a7c8c6ac8a385e4cef4dd3c93/grpcio-1.73.1-cp311-cp311-manylinux_2_17_aarch64.whl", hash = "sha256:5b9b1805a7d61c9e90541cbe8dfe0a593dfc8c5c3a43fe623701b6a01b01d710", size = 5807903, upload-time = "2025-06-26T01:52:09.466Z" },
    { url = "https://files.pythonhosted.org/packages/5d/47/36deacd3c967b74e0265f4c608983e897d8bb3254b920f8eafdf60e4ad7e/grpcio-1.73.1-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:b3215f69a0670a8cfa2ab53236d9e8026bfb7ead5d4baabe7d7dc11d30fda967", size = 6448172, upload-time = "2025-06-26T01:52:11.459Z" },
    { url = "https://files.pythonhosted.org/packages/0e/64/12d6dc446021684ee1428ea56a3f3712048a18beeadbdefa06e6f8814a6e/grpcio-1.73.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bc5eccfd9577a5dc7d5612b2ba90cca4ad14c6d949216c68585fdec9848befb1", size = 6044226, upload-time = "2025-06-26T01:52:12.987Z" },
    { url = "https://files.pythonhosted.org/packages/72/4b/6bae2d88a006000f1152d2c9c10ffd41d0131ca1198e0b661101c2e30ab9/grpcio-1.73.1-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:dc7d7fd520614fce2e6455ba89791458020a39716951c7c07694f9dbae28e9c0", size = 6135690, upload-time = "2025-06-26T01:52:14.92Z" },
    { url = "https://files.pythonhosted.org/packages/38/64/02c83b5076510784d1305025e93e0d78f53bb6a0213c8c84cfe8a00c5c48/grpcio-1.73.1-cp311-cp311-musllinux_1_1_i686.whl", hash = "sha256:105492124828911f85127e4825d1c1234b032cb9d238567876b5515d01151379", size = 6775867, upload-time = "2025-06-26T01:52:16.446Z" },
    { url = "https://files.pythonhosted.org/packages/42/72/a13ff7ba6c68ccffa35dacdc06373a76c0008fd75777cba84d7491956620/grpcio-1.73.1-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:610e19b04f452ba6f402ac9aa94eb3d21fbc94553368008af634812c4a85a99e", size = 6308380, upload-time = "2025-06-26T01:52:18.417Z" },
    { url = "https://files.pythonhosted.org/packages/65/ae/d29d948021faa0070ec33245c1ae354e2aefabd97e6a9a7b6dcf0fb8ef6b/grpcio-1.73.1-cp311-cp311-win32.whl", hash = "sha256:d60588ab6ba0ac753761ee0e5b30a29398306401bfbceffe7d68ebb21193f9d4", size = 3679139, upload-time = "2025-06-26T01:52:20.171Z" },
    { url = "https://files.pythonhosted.org/packages/af/66/e1bbb0c95ea222947f0829b3db7692c59b59bcc531df84442e413fa983d9/grpcio-1.73.1-cp311-cp311-win_amd64.whl", hash = "sha256:6957025a4608bb0a5ff42abd75bfbb2ed99eda29d5992ef31d691ab54b753643", size = 4342558, upload-time = "2025-06-26T01:52:22.137Z" },
    { url = "https://files.pythonhosted.org/packages/b8/41/456caf570c55d5ac26f4c1f2db1f2ac1467d5bf3bcd660cba3e0a25b195f/grpcio-1.73.1-cp312-cp312-linux_armv7l.whl", hash = "sha256:921b25618b084e75d424a9f8e6403bfeb7abef074bb6c3174701e0f2542debcf", size = 5334621, upload-time = "2025-06-26T01:52:23.602Z" },
    { url = "https://files.pythonhosted.org/packages/2a/c2/9a15e179e49f235bb5e63b01590658c03747a43c9775e20c4e13ca04f4c4/grpcio-1.73.1-cp312-cp312-macosx_11_0_universal2.whl", hash = "sha256:277b426a0ed341e8447fbf6c1d6b68c952adddf585ea4685aa563de0f03df887", size = 10601131, upload-time = "2025-06-26T01:52:25.691Z" },
    { url = "https://files.pythonhosted.org/packages/0c/1d/1d39e90ef6348a0964caa7c5c4d05f3bae2c51ab429eb7d2e21198ac9b6d/grpcio-1.73.1-cp312-cp312-manylinux_2_17_aarch64.whl", hash = "sha256:96c112333309493c10e118d92f04594f9055774757f5d101b39f8150f8c25582", size = 5759268, upload-time = "2025-06-26T01:52:27.631Z" },
    { url = "https://files.pythonhosted.org/packages/8a/2b/2dfe9ae43de75616177bc576df4c36d6401e0959833b2e5b2d58d50c1f6b/grpcio-1.73.1-cp312-cp312-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:f48e862aed925ae987eb7084409a80985de75243389dc9d9c271dd711e589918", size = 6409791, upload-time = "2025-06-26T01:52:29.711Z" },
    { url = "https://files.pythonhosted.org/packages/6e/66/e8fe779b23b5a26d1b6949e5c70bc0a5fd08f61a6ec5ac7760d589229511/grpcio-1.73.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:83a6c2cce218e28f5040429835fa34a29319071079e3169f9543c3fbeff166d2", size = 6003728, upload-time = "2025-06-26T01:52:31.352Z" },
    { url = "https://files.pythonhosted.org/packages/a9/39/57a18fcef567784108c4fc3f5441cb9938ae5a51378505aafe81e8e15ecc/grpcio-1.73.1-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:65b0458a10b100d815a8426b1442bd17001fdb77ea13665b2f7dc9e8587fdc6b", size = 6103364, upload-time = "2025-06-26T01:52:33.028Z" },
    { url = "https://files.pythonhosted.org/packages/c5/46/28919d2aa038712fc399d02fa83e998abd8c1f46c2680c5689deca06d1b2/grpcio-1.73.1-cp312-cp312-musllinux_1_1_i686.whl", hash = "sha256:0a9f3ea8dce9eae9d7cb36827200133a72b37a63896e0e61a9d5ec7d61a59ab1", size = 6749194, upload-time = "2025-06-26T01:52:34.734Z" },
    { url = "https://files.pythonhosted.org/packages/3d/56/3898526f1fad588c5d19a29ea0a3a4996fb4fa7d7c02dc1be0c9fd188b62/grpcio-1.73.1-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:de18769aea47f18e782bf6819a37c1c528914bfd5683b8782b9da356506190c8", size = 6283902, upload-time = "2025-06-26T01:52:36.503Z" },
    { url = "https://files.pythonhosted.org/packages/dc/64/18b77b89c5870d8ea91818feb0c3ffb5b31b48d1b0ee3e0f0d539730fea3/grpcio-1.73.1-cp312-cp312-win32.whl", hash = "sha256:24e06a5319e33041e322d32c62b1e728f18ab8c9dbc91729a3d9f9e3ed336642", size = 3668687, upload-time = "2025-06-26T01:52:38.678Z" },
    { url = "https://files.pythonhosted.org/packages/3c/52/302448ca6e52f2a77166b2e2ed75f5d08feca4f2145faf75cb768cccb25b/grpcio-1.73.1-cp312-cp312-win_amd64.whl", hash = "sha256:303c8135d8ab176f8038c14cc10d698ae1db9c480f2b2823f7a987aa2a4c5646", size = 4334887, upload-time = "2025-06-26T01:52:40.743Z" },
    { url = "https://files.pythonhosted.org/packages/37/bf/4ca20d1acbefabcaba633ab17f4244cbbe8eca877df01517207bd6655914/grpcio-1.73.1-cp313-cp313-linux_armv7l.whl", hash = "sha256:b310824ab5092cf74750ebd8a8a8981c1810cb2b363210e70d06ef37ad80d4f9", size = 5335615, upload-time = "2025-06-26T01:52:42.896Z" },
    { url = "https://files.pythonhosted.org/packages/75/ed/45c345f284abec5d4f6d77cbca9c52c39b554397eb7de7d2fcf440bcd049/grpcio-1.73.1-cp313-cp313-macosx_11_0_universal2.whl", hash = "sha256:8f5a6df3fba31a3485096ac85b2e34b9666ffb0590df0cd044f58694e6a1f6b5", size = 10595497, upload-time = "2025-06-26T01:52:44.695Z" },
    { url = "https://files.pythonhosted.org/packages/a4/75/bff2c2728018f546d812b755455014bc718f8cdcbf5c84f1f6e5494443a8/grpcio-1.73.1-cp313-cp313-manylinux_2_17_aarch64.whl", hash = "sha256:052e28fe9c41357da42250a91926a3e2f74c046575c070b69659467ca5aa976b", size = 5765321, upload-time = "2025-06-26T01:52:46.871Z" },
    { url = "https://files.pythonhosted.org/packages/70/3b/14e43158d3b81a38251b1d231dfb45a9b492d872102a919fbf7ba4ac20cd/grpcio-1.73.1-cp313-cp313-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1c0bf15f629b1497436596b1cbddddfa3234273490229ca29561209778ebe182", size = 6415436, upload-time = "2025-06-26T01:52:49.134Z" },
    { url = "https://files.pythonhosted.org/packages/e5/3f/81d9650ca40b54338336fd360f36773be8cb6c07c036e751d8996eb96598/grpcio-1.73.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0ab860d5bfa788c5a021fba264802e2593688cd965d1374d31d2b1a34cacd854", size = 6007012, upload-time = "2025-06-26T01:52:51.076Z" },
    { url = "https://files.pythonhosted.org/packages/55/f4/59edf5af68d684d0f4f7ad9462a418ac517201c238551529098c9aa28cb0/grpcio-1.73.1-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:ad1d958c31cc91ab050bd8a91355480b8e0683e21176522bacea225ce51163f2", size = 6105209, upload-time = "2025-06-26T01:52:52.773Z" },
    { url = "https://files.pythonhosted.org/packages/e4/a8/700d034d5d0786a5ba14bfa9ce974ed4c976936c2748c2bd87aa50f69b36/grpcio-1.73.1-cp313-cp313-musllinux_1_1_i686.whl", hash = "sha256:f43ffb3bd415c57224c7427bfb9e6c46a0b6e998754bfa0d00f408e1873dcbb5", size = 6753655, upload-time = "2025-06-26T01:52:55.064Z" },
    { url = "https://files.pythonhosted.org/packages/1f/29/efbd4ac837c23bc48e34bbaf32bd429f0dc9ad7f80721cdb4622144c118c/grpcio-1.73.1-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:686231cdd03a8a8055f798b2b54b19428cdf18fa1549bee92249b43607c42668", size = 6287288, upload-time = "2025-06-26T01:52:57.33Z" },
    { url = "https://files.pythonhosted.org/packages/d8/61/c6045d2ce16624bbe18b5d169c1a5ce4d6c3a47bc9d0e5c4fa6a50ed1239/grpcio-1.73.1-cp313-cp313-win32.whl", hash = "sha256:89018866a096e2ce21e05eabed1567479713ebe57b1db7cbb0f1e3b896793ba4", size = 3668151, uplo
```
> [truncated]

---
https://github.com/langchain-ai/langgraph/blob/main/docs/vercel.json
```json
{
  "buildCommand": "yarn build",
  "outputDirectory": "site"
}

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/yarn.lock
```lock
# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 8
  cacheKey: 10c0

"@cfworker/json-schema@npm:^4.0.2":
  version: 4.1.1
  resolution: "@cfworker/json-schema@npm:4.1.1"
  checksum: 10c0/b5253486d346b7de6feec9c73954f612b11019dacb9023d710a5666df2f5fc145dd88b6b913c88726c6d97e2e258a515fa2cab177f58b18da6bac3738cbc4739
  languageName: node
  linkType: hard

"@langchain/core@npm:^0.3.38":
  version: 0.3.38
  resolution: "@langchain/core@npm:0.3.38"
  dependencies:
    "@cfworker/json-schema": "npm:^4.0.2"
    ansi-styles: "npm:^5.0.0"
    camelcase: "npm:6"
    decamelize: "npm:1.2.0"
    js-tiktoken: "npm:^1.0.12"
    langsmith: "npm:>=0.2.8 <0.4.0"
    mustache: "npm:^4.2.0"
    p-queue: "npm:^6.6.2"
    p-retry: "npm:4"
    uuid: "npm:^10.0.0"
    zod: "npm:^3.22.4"
    zod-to-json-schema: "npm:^3.22.3"
  checksum: 10c0/3b2f042f6550cb818a33b0649110c9ef7f645b0bc23507d2d5a63b98dd4dcd28692d4a6ead70a936e4d46dd39224cc74e4bfb0389b124a183f29bbdf0b069ab0
  languageName: node
  linkType: hard

"@langchain/openai@npm:^0.4.2":
  version: 0.4.2
  resolution: "@langchain/openai@npm:0.4.2"
  dependencies:
    js-tiktoken: "npm:^1.0.12"
    openai: "npm:^4.77.0"
    zod: "npm:^3.22.4"
    zod-to-json-schema: "npm:^3.22.3"
  peerDependencies:
    "@langchain/core": ">=0.3.29 <0.4.0"
  checksum: 10c0/0a17803c9a74e3b95f77a86e45705e32f0a76fdc9bbdb6d17f64ff6fa052356bc7067f0dccb57479087f236434f4aebf6731618c616331cab3bf48bf55a376c3
  languageName: node
  linkType: hard

"@mswjs/interceptors@npm:^0.37.3":
  version: 0.37.6
  resolution: "@mswjs/interceptors@npm:0.37.6"
  dependencies:
    "@open-draft/deferred-promise": "npm:^2.2.0"
    "@open-draft/logger": "npm:^0.3.0"
    "@open-draft/until": "npm:^2.0.0"
    is-node-process: "npm:^1.2.0"
    outvariant: "npm:^1.4.3"
    strict-event-emitter: "npm:^0.5.1"
  checksum: 10c0/74f52c09c84fcbba9f1a06e462aa25b1567cf078ed27d396c76a8059c002fa9c361e711dcada0ac2aad4298f247d8e236a4fcc861c08ddf6e2ce0889368596fd
  languageName: node
  linkType: hard

"@open-draft/deferred-promise@npm:^2.2.0":
  version: 2.2.0
  resolution: "@open-draft/deferred-promise@npm:2.2.0"
  checksum: 10c0/eafc1b1d0fc8edb5e1c753c5e0f3293410b40dde2f92688211a54806d4136887051f39b98c1950370be258483deac9dfd17cf8b96557553765198ef2547e4549
  languageName: node
  linkType: hard

"@open-draft/logger@npm:^0.3.0":
  version: 0.3.0
  resolution: "@open-draft/logger@npm:0.3.0"
  dependencies:
    is-node-process: "npm:^1.2.0"
    outvariant: "npm:^1.4.0"
  checksum: 10c0/90010647b22e9693c16258f4f9adb034824d1771d3baa313057b9a37797f571181005bc50415a934eaf7c891d90ff71dcd7a9d5048b0b6bb438f31bef2c7c5c1
  languageName: node
  linkType: hard

"@open-draft/until@npm:^2.0.0":
  version: 2.1.0
  resolution: "@open-draft/until@npm:2.1.0"
  checksum: 10c0/61d3f99718dd86bb393fee2d7a785f961dcaf12f2055f0c693b27f4d0cd5f7a03d498a6d9289773b117590d794a43cd129366fd8e99222e4832f67b1653d54cf
  languageName: node
  linkType: hard

"@tsconfig/recommended@npm:^1.0.8":
  version: 1.0.8
  resolution: "@tsconfig/recommended@npm:1.0.8"
  checksum: 10c0/bd6517e3f69cf96108ab8b7d2ee70a7e64ee457bb72326524acdef6e2219813b298654e9aa57ce2f8899901c9b8fd66388b036b9ca0aa062952a83adb59bec17
  languageName: node
  linkType: hard

"@types/msgpack-lite@npm:^0.1.11":
  version: 0.1.11
  resolution: "@types/msgpack-lite@npm:0.1.11"
  dependencies:
    "@types/node": "npm:*"
  checksum: 10c0/d51a47a20ef5ff9b8b61d33ca3d10c992bbf10c4d4dbcbb7d1f1f9cdb2c8c1a302de36b00e1f11ef954b1bc4730add11b610996cd6ee767624b2bdd572e7b647
  languageName: node
  linkType: hard

"@types/nock@npm:^11.1.0":
  version: 11.1.0
  resolution: "@types/nock@npm:11.1.0"
  dependencies:
    nock: "npm:*"
  checksum: 10c0/d13596983b909b86c03d031220a478a4a4759a006586c02d2b6bbb7751386df04026223ccbe66289d0d4edaf5b66c7a401c62999a5e4ec3c2a242f5ec1a0433b
  languageName: node
  linkType: hard

"@types/node-fetch@npm:^2.6.4":
  version: 2.6.12
  resolution: "@types/node-fetch@npm:2.6.12"
  dependencies:
    "@types/node": "npm:*"
    form-data: "npm:^4.0.0"
  checksum: 10c0/7693acad5499b7df2d1727d46cff092a63896dc04645f36b973dd6dd754a59a7faba76fcb777bdaa35d80625c6a9dd7257cca9c401a4bab03b04480cda7fd1af
  languageName: node
  linkType: hard

"@types/node@npm:*, @types/node@npm:^22.13.1":
  version: 22.13.1
  resolution: "@types/node@npm:22.13.1"
  dependencies:
    undici-types: "npm:~6.20.0"
  checksum: 10c0/d4e56d41d8bd53de93da2651c0a0234e330bd7b1b6d071b1a94bd3b5ee2d9f387519e739c52a15c1faa4fb9d97e825b848421af4b2e50e6518011e7adb4a34b7
  languageName: node
  linkType: hard

"@types/node@npm:^18.11.18":
  version: 18.19.75
  resolution: "@types/node@npm:18.19.75"
  dependencies:
    undici-types: "npm:~5.26.4"
  checksum: 10c0/6a78833071d23dcd4010507d0a232da1cb6e939eb5b62023a01ab5f91eecb90223bda3e34aa536f02cd5c3bdf7962c754b7e2a051a8224aed5886788fce88fbf
  languageName: node
  linkType: hard

"@types/retry@npm:0.12.0":
  version: 0.12.0
  resolution: "@types/retry@npm:0.12.0"
  checksum: 10c0/7c5c9086369826f569b83a4683661557cab1361bac0897a1cefa1a915ff739acd10ca0d62b01071046fe3f5a3f7f2aec80785fe283b75602dc6726781ea3e328
  languageName: node
  linkType: hard

"@types/uuid@npm:^10.0.0":
  version: 10.0.0
  resolution: "@types/uuid@npm:10.0.0"
  checksum: 10c0/9a1404bf287164481cb9b97f6bb638f78f955be57c40c6513b7655160beb29df6f84c915aaf4089a1559c216557dc4d2f79b48d978742d3ae10b937420ddac60
  languageName: node
  linkType: hard

"abort-controller@npm:^3.0.0":
  version: 3.0.0
  resolution: "abort-controller@npm:3.0.0"
  dependencies:
    event-target-shim: "npm:^5.0.0"
  checksum: 10c0/90ccc50f010250152509a344eb2e71977fbf8db0ab8f1061197e3275ddf6c61a41a6edfd7b9409c664513131dd96e962065415325ef23efa5db931b382d24ca5
  languageName: node
  linkType: hard

"agentkeepalive@npm:^4.2.1":
  version: 4.6.0
  resolution: "agentkeepalive@npm:4.6.0"
  dependencies:
    humanize-ms: "npm:^1.2.1"
  checksum: 10c0/235c182432f75046835b05f239708107138a40103deee23b6a08caee5136873709155753b394ec212e49e60e94a378189562cb01347765515cff61b692c69187
  languageName: node
  linkType: hard

"ansi-styles@npm:^4.1.0":
  version: 4.3.0
  resolution: "ansi-styles@npm:4.3.0"
  dependencies:
    color-convert: "npm:^2.0.1"
  checksum: 10c0/895a23929da416f2bd3de7e9cb4eabd340949328ab85ddd6e484a637d8f6820d485f53933446f5291c3b760cbc488beb8e88573dd0f9c7daf83dccc8fe81b041
  languageName: node
  linkType: hard

"ansi-styles@npm:^5.0.0":
  version: 5.2.0
  resolution: "ansi-styles@npm:5.2.0"
  checksum: 10c0/9c4ca80eb3c2fb7b33841c210d2f20807f40865d27008d7c3f707b7f95cab7d67462a565e2388ac3285b71cb3d9bb2173de8da37c57692a362885ec34d6e27df
  languageName: node
  linkType: hard

"asynckit@npm:^0.4.0":
  version: 0.4.0
  resolution: "asynckit@npm:0.4.0"
  checksum: 10c0/d73e2ddf20c4eb9337e1b3df1a0f6159481050a5de457c55b14ea2e5cb6d90bb69e004c9af54737a5ee0917fcf2c9e25de67777bbe58261847846066ba75bc9d
  languageName: node
  linkType: hard

"base64-js@npm:^1.5.1":
  version: 1.5.1
  resolution: "base64-js@npm:1.5.1"
  checksum: 10c0/f23823513b63173a001030fae4f2dabe283b99a9d324ade3ad3d148e218134676f1ee8568c877cd79ec1c53158dcf2d2ba527a97c606618928ba99dd930102bf
  languageName: node
  linkType: hard

"call-bind-apply-helpers@npm:^1.0.1, call-bind-apply-helpers@npm:^1.0.2":
  version: 1.0.2
  resolution: "call-bind-apply-helpers@npm:1.0.2"
  dependencies:
    es-errors: "npm:^1.3.0"
    function-bind: "npm:^1.1.2"
  checksum: 10c0/47bd9901d57b857590431243fea704ff18078b16890a6b3e021e12d279bbf211d039155e27d7566b374d49ee1f8189344bac9833dec7a20cdec370506361c938
  languageName: node
  linkType: hard

"camelcase@npm:6":
  version: 6.3.0
  resolution: "camelcase@npm:6.3.0"
  checksum: 10c0/0d701658219bd3116d12da3eab31acddb3f9440790c0792e0d398f0a520a6a4058018e546862b6fba89d7ae990efaeb97da71e1913e9ebf5a8b5621a3d55c710
  languageName: node
  linkType: hard

"chalk@npm:^4.1.2":
  version: 4.1.2
  resolution: "chalk@npm:4.1.2"
  dependencies:
    ansi-styles: "npm:^4.1.0"
    supports-color: "npm:^7.1.0"
  checksum: 10c0/4a3fef5cc34975c898ffe77141450f679721df9dde00f6c304353fa9c8b571929123b26a0e4617bde5018977eb655b31970c297b91b63ee83bb82aeb04666880
  languageName: node
  linkType: hard

"color-convert@npm:^2.0.1":
  version: 2.0.1
  resolution: "color-convert@npm:2.0.1"
  dependencies:
    color-name: "npm:~1.1.4"
  checksum: 10c0/37e1150172f2e311fe1b2df62c6293a342ee7380da7b9cfdba67ea539909afbd74da27033208d01d6d5cfc65ee7868a22e18d7e7648e004425441c0f8a15a7d7
  languageName: node
  linkType: hard

"color-name@npm:~1.1.4":
  version: 1.1.4
  resolution: "color-name@npm:1.1.4"
  checksum: 10c0/a1a3f914156960902f46f7f56bc62effc6c94e84b2cae157a526b1c1f74b677a47ec602bf68a61abfa2b42d15b7c5651c6dbe72a43af720bc588dff885b10f95
  languageName: node
  linkType: hard

"combined-stream@npm:^1.0.8":
  version: 1.0.8
  resolution: "combined-stream@npm:1.0.8"
  dependencies:
    delayed-stream: "npm:~1.0.0"
  checksum: 10c0/0dbb829577e1b1e839fa82b40c07ffaf7de8a09b935cadd355a73652ae70a88b4320db322f6634a4ad93424292fa80973ac6480986247f1734a1137debf271d5
  languageName: node
  linkType: hard

"console-table-printer@npm:^2.12.1":
  version: 2.12.1
  resolution: "console-table-printer@npm:2.12.1"
  dependencies:
    simple-wcswidth: "npm:^1.0.1"
  checksum: 10c0/8f28e9c0ae5df77f5d60da3da002ecd95ebe1812b0b9e0a6d2795c81b5121b39774f32506bccf68830a838ca4d8fbb2ab8824e729dba2c5e30cdeb9df4dd5f2b
  languageName: node
  linkType: hard

"decamelize@npm:1.2.0":
  version: 1.2.0
  resolution: "decamelize@npm:1.2.0"
  checksum: 10c0/85c39fe8fbf0482d4a1e224ef0119db5c1897f8503bcef8b826adff7a1b11414972f6fef2d7dec2ee0b4be3863cf64ac1439137ae9e6af23a3d8dcbe26a5b4b2
  languageName: node
  linkType: hard

"delayed-stream@npm:~1.0.0":
  version: 1.0.0
  resolution: "delayed-stream@npm:1.0.0"
  checksum: 10c0/d758899da03392e6712f042bec80aa293bbe9e9ff1b2634baae6a360113e708b91326594c8a486d475c69d6259afb7efacdc3537bfcda1c6c648e390ce601b19
  languageName: node
  linkType: hard

"docs@workspace:.":
  version: 0.0.0-use.local
  resolution: "docs@workspace:."
  dependencies:
    "@langchain/core": "npm:^0.3.38"
    "@langchain/openai": "npm:^0.4.2"
    "@tsconfig/recommended": "npm:^1.0.8"
    "@types/msgpack-lite": "npm:^0.1.11"
    "@types/nock": "npm:^11.1.0"
    "@types/node": "npm:^22.13.1"
    he: "npm:^1.2.0"
    msgpack-lite: "npm:^0.1.26"
    nock: "npm:^14.0.1"
  languageName: unknown
  linkType: soft

"dunder-proto@npm:^1.0.1":
  version: 1.0.1
  resolution: "dunder-proto@npm:1.0.1"
  dependencies:
    call-bind-apply-helpers: "npm:^1.0.1"
    es-errors: "npm:^1.3.0"
    gopd: "npm:^1.2.0"
  checksum: 10c0/199f2a0c1c16593ca0a145dbf76a962f8033ce3129f01284d48c45ed4e14fea9bbacd7b3610b6cdc33486cef20385ac054948fefc6272fcce645c09468f93031
  languageName: node
  linkType: hard

"es-define-property@npm:^1.0.1":
  version: 1.0.1
  resolution: "es-define-property@npm:1.0.1"
  checksum: 10c0/3f54eb49c16c18707949ff25a1456728c883e81259f045003499efba399c08bad00deebf65cccde8c0e07908c1a225c9d472b7107e558f2a48e28d530e34527c
  languageName: node
  linkType: hard

"es-errors@npm:^1.3.0":
  version: 1.3.0
  resolution: "es-errors@npm:1.3.0"
  checksum: 10c0/0a61325670072f98d8ae3b914edab3559b6caa980f08054a3b872052640d91da01d38df55df797fcc916389d77fc92b8d5906cf028f4db46d7e3003abecbca85
  languageName: node
  linkType: hard

"es-object-atoms@npm:^1.0.0, es-object-atoms@npm:^1.1.1":
  version: 1.1.1
  resolution: "es-object-atoms@npm:1.1.1"
  dependencies:
    es-errors: "npm:^1.3.0"
  checksum: 10c0/65364812ca4daf48eb76e2a3b7a89b3f6a2e62a1c420766ce9f692665a29d94fe41fe88b65f24106f449859549711e4b40d9fb8002d862dfd7eb1c512d10be0c
  languageName: node
  linkType: hard

"es-set-tostringtag@npm:^2.1.0":
  version: 2.1.0
  resolution: "es-set-tostringtag@npm:2.1.0"
  dependencies:
    es-errors: "npm:^1.3.0"
    get-intrinsic: "npm:^1.2.6"
    has-tostringtag: "npm:^1.0.2"
    hasown: "npm:^2.0.2"
  checksum: 10c0/ef2ca9ce49afe3931cb32e35da4dcb6d86ab02592cfc2ce3e49ced199d9d0bb5085fc7e73e06312213765f5efa47cc1df553a6a5154584b21448e9fb8355b1af
  languageName: node
  linkType: hard

"event-lite@npm:^0.1.1":
  version: 0.1.3
  resolution: "event-lite@npm:0.1.3"
  checksum: 10c0/68d11a1e9001d713d673866fe07f6c310fa9054fc0a936dd5eacc37a793aa6b3331ddb1d85dbcb88ddbe6b04944566a0f1c5b515118e1ec2e640ffcb30858b3f
  languageName: node
  linkType: hard

"event-target-shim@npm:^5.0.0":
  version: 5.0.1
  resolution: "event-target-shim@npm:5.0.1"
  checksum: 10c0/0255d9f936215fd206156fd4caa9e8d35e62075d720dc7d847e89b417e5e62cf1ce6c9b4e0a1633a9256de0efefaf9f8d26924b1f3c8620cffb9db78e7d3076b
  languageName: node
  linkType: hard

"eventemitter3@npm:^4.0.4":
  version: 4.0.7
  resolution: "eventemitter3@npm:4.0.7"
  checksum: 10c0/5f6d97cbcbac47be798e6355e3a7639a84ee1f7d9b199a07017f1d2f1e2fe236004d14fa5dfaeba661f94ea57805385e326236a6debbc7145c8877fbc0297c6b
  languageName: node
  linkType: hard

"form-data-encoder@npm:1.7.2":
  version: 1.7.2
  resolution: "form-data-encoder@npm:1.7.2"
  checksum: 10c0/56553768037b6d55d9de524f97fe70555f0e415e781cb56fc457a68263de3d40fadea2304d4beef2d40b1a851269bd7854e42c362107071892cb5238debe9464
  languageName: node
  linkType: hard

"form-data@npm:^4.0.0":
  version: 4.0.4
  resolution: "form-data@npm:4.0.4"
  dependencies:
    asynckit: "npm:^0.4.0"
    combined-stream: "npm:^1.0.8"
    es-set-tostringtag: "npm:^2.1.0"
    hasown: "npm:^2.0.2"
    mime-types: "npm:^2.1.12"
  checksum: 10c0/373525a9a034b9d57073e55eab79e501a714ffac02e7a9b01be1c820780652b16e4101819785e1e18f8d98f0aee866cc654d660a435c378e16a72f2e7cac9695
  languageName: node
  linkType: hard

"formdata-node@npm:^4.3.2":
  version: 4.4.1
  resolution: "formdata-node@npm:4.4.1"
  dependencies:
    node-domexception: "npm:1.0.0"
    web-streams-polyfill: "npm:4.0.0-beta.3"
  checksum: 10c0/74151e7b228ffb33b565cec69182694ad07cc3fdd9126a8240468bb70a8ba66e97e097072b60bcb08729b24c7ce3fd3e0bd7f1f80df6f9f662b9656786e76f6a
  languageName: node
  linkType: hard

"function-bind@npm:^1.1.2":
  version: 1.1.2
  resolution: "function-bind@npm:1.1.2"
  checksum: 10c0/d8680ee1e5fcd4c197e4ac33b2b4dce03c71f4d91717292785703db200f5c21f977c568d28061226f9b5900cbcd2c84463646134fd5337e7925e0942bc3f46d5
  languageName: node
  linkType: hard

"get-intrinsic@npm:^1.2.6":
  version: 1.3.0
  resolution: "get-intrinsic@npm:1.3.0"
  dependencies:
    call-bind-apply-helpers: "npm:^1.0.2"
    es-define-property: "npm:^1.0.1"
    es-errors: "npm:^1.3.0"
    es-object-atoms: "npm:^1.1.1"
    function-bind: "npm:^1.1.2"
    get-proto: "npm:^1.0.1"
    gopd: "npm:^1.2.0"
    has-symbols: "npm:^1.1.0"
    hasown: "npm:^2.0.2"
    math-intrinsics: "npm:^1.1.0"
  checksum: 10c0/52c81808af9a8130f581e6a6a83e1ba4a9f703359e7a438d1369a5267a25412322f03dcbd7c549edaef0b6214a0630a28511d7df0130c93cfd380f4fa0b5b66a
  languageName: node
  linkType: hard

"get-proto@npm:^1.0.1":
  version: 1.0.1
  resolution: "get-proto@npm:1.0.1"
  dependencies:
    dunder-proto: "npm:^1.0.1"
    es-object-atoms: "npm:^1.0.0"
  checksum: 10c0/9224acb44603c5526955e83510b9da41baf6ae73f7398875fba50edc5e944223a89c4a72b070fcd78beb5f7bdda58ecb6294adc28f7acfc0da05f76a2399643c
  languageName: node
  linkType: hard

"gopd@npm:^1.2.0":
  version: 1.2.0
  resolution: "gopd@npm:1.2.0"
  checksum: 10c0/50fff1e04ba2b7737c097358534eacadad1e68d24cccee3272e04e007bed008e68d2614f3987788428fd192a5ae3889d08fb2331417e4fc4a9ab366b2043cead
  languageName: node
  linkType: hard

"has-flag@npm:^4.0.0":
  version: 4.0.0
  resolution: "has-flag@npm:4.0.0"
  checksum: 10c0/2e789c61b7888d66993e14e8331449e525ef42aac53c627cc53d1c3334e768bcb6abdc4f5f0de1478a25beec6f0bd62c7549058b7ac53e924040d4f301f02fd1
  languageName: node
  linkType: hard

"has-symbols@npm:^1.0.3, has-symbols@npm:^1.1.0":
  version: 1.1.0
  resolution: "has-symbols@npm:1.1.0"
  checksum: 10c0/dde0a734b17ae51e84b10986e651c664379018d10b91b6b0e9b293eddb32f0f069688c841fb40f19e9611546130153e0a2a48fd7f512891fb000ddfa36f5a20e
  languageName: node
  linkType: hard

"has-tostringtag@npm:^1.0.2":
  version: 1.0.2
  resolution: "has-tostringtag@npm:1.0.2"
  dependencies:
    has-symbols: "npm:^1.0.3"
  checksum: 10c0/a8b166462192bafe3d9b6e420a1d581d93dd867adb61be223a17a8d6dad147aa77a8be32c961bb2f27b3ef893cae8d36f564ab651f5e9b7938ae86f74027c48c
  languageName: node
  linkType: hard

"hasown@npm:^2.0.2":
  version: 2.0.2
  resolution: "hasown@npm:2.0.2"
  dependencies:
    function-bind: "npm:^1.1.2"
  checksum: 10c0/3769d434703b8ac66b209a4cca0737519925bbdb61dd887f93a16372b14694c63ff4e797686d87c90f08168e81082248b9b028bad60d4da9e0d1148766f56eb9
  languageName: node
  linkType: hard

"he@npm:^1.2.0":
  version: 1.2.0
  resolution: "he@npm:1.2.0"
  bin:
    he: bin/he
  checksum: 10c0/a27d478befe3c8192f006cdd0639a66798979dfa6e2125c6ac582a19a5ebfec62ad83e8382e6036170d873f46e4536a7e795bf8b95bf7c247f4cc0825ccc8c17
  languageName: node
  linkType: hard

"humanize-ms@npm:^1.2.1":
  version: 1.2.1
  resolution: "humanize-ms@npm:1.2.1"
  dependencies:
    ms: "npm:^2.0.0"
  checksum: 10c0/f34a2c20161d02303c2807badec2f3b49cbfbbb409abd4f95a07377ae01cfe6b59e3d15ac609cffcd8f2521f0eb37b7e1091acf65da99aa2a4f1ad63c21e7e7a
  languageName: node
  linkType: hard

"ieee754@npm:^1.1.8":
  version: 1.2.1
  resolution: "ieee754@npm:1.2.1"
  checksum: 10c0/b0782ef5e0935b9f12883a2e2aa37baa75da6e66ce6515c168697b42160807d9330de9a32ec1ed73149aea02e0d822e572bca6f1e22bdcbd2149e13b050b17bb
  languageName: node
  linkType: hard

"int64-buffer@npm:^0.1.9":
  version: 0.1.10
  resolution: "int64-buffer@npm:0.1.10"
  checksum: 10c0/22688f6d1f4db11eaacbf8e7f0b80a23690c29d023987302c367f8c071a53b84fa1cef6f8db0a347e9326f94ff76aa3529e8e9964e99d37fc675f5dcd835ee50
  languageName: node
  linkType: hard

"is-node-process@npm:^1.2.0":
  version: 1.2.0
  resolution: "is-node-process@npm:1.2.0"
  checksum: 10c0/5b24fda6776d00e42431d7bcd86bce81cb0b6cabeb944142fe7b077a54ada2e155066ad06dbe790abdb397884bdc3151e04a9707b8cd185099efbc79780573ed
  languageName: node
  linkType: hard

"isarray@npm:^1.0.0":
  version: 1.0.0
  resolution: "isarray@npm:1.0.0"
  checksum: 10c0/18b5be6669be53425f0b84098732670ed4e727e3af33bc7f948aac01782110eb9a18b3b329c5323bcdd3acdaae547ee077d3951317e7f133bff7105264b3003d
  languageName: node
  linkType: hard

"js-tiktoken@npm:^1.0.12":
  version: 1.0.18
  resolution: "js-tiktoken@npm:1.0.18"
  dependencies:
    base64-js: "npm:^1.5.1"
  checksum: 10c0/de2f82d41d49702d42bb417dfc9dc1ce3801d5f04ec0ac73a6f06db5aa3dadfcc13871b30447c28e0b80e37fe76a5052a7c195af657707e7c6753110881d2a26
  languageName: node
  linkType: hard

"json-stringify-safe@npm:^5.0.1":
  version: 5.0.1
  resolution: "json-stringify-safe@npm:5.0.1"
  checksum: 10c0/7dbf35cd0411d1d648dceb6d59ce5857ec939e52e4afc37601aa3da611f0987d5cee5b38d58329ceddf3ed48bd7215229c8d52059ab01f2444a338bf24ed0f37
  languageName: node
  linkType: hard

"langsmith@npm:>=0.2.8 <0.4.0":
  version: 0.3.7
  resolution: "langsmith@npm:0.3.7"
  dependencies:
    "@types/uuid": "npm:^10.0.0"
    chalk: "npm:^4.1.2"
    console-table-printer: "npm:^2.12.1"
    p-queue: "npm:^6.6.2"
    p-retry: "npm:4"
    semver: "npm:^7.6.3"
    uuid: "npm:^10.0.0"
  peerDependencies:
    openai: "*"
  peerDependenciesMeta:
    openai:
      optional: true
  checksum: 10c0/68ada1d5120376467bbf7edca17b0629f3d5a2588c91d2396a372b69217e3de960487f1c4109c36e38e0ee6a467d5f81e4b59d8f3312e480af5bb01007d179f3
  languageName: node
  linkType: hard

"math-intrinsics@npm:^1.1.0":
  version: 1.1.0
  resolution: "math-intrinsics@npm:1.1.0"
  checksum: 10c0/7579ff94e899e2f76ab64491d76cf606274c874d8f2af4a442c016bd85688927fcfca157ba6bf74b08e9439dc010b248ce05b96cc7c126a354c3bae7fcb48b7f
  languageName: node
  linkType: hard

"mime-db@npm:1.52.0":
  version: 1.52.0
  resolution: "mime-db@npm:1.52.0"
  checksum: 10c0/0557a01deebf45ac5f5777fe7740b2a5c309c6d62d40ceab4e23da9f821899ce7a900b7ac8157d4548ddbb7beffe9abc621250e6d182b0397ec7f10c7b91a5aa
  languageName: node
  linkType: hard

"mime-types@npm:^2.1.12":
  version: 2.1.35
  resolution: "mime-types@npm:2.1.35"
  dependencies:
    mime-db: "npm:1.52.0"
  checksum: 10c0/82fb07ec56d8ff1fc999a84f2f217aa46cb6ed1033fefaabd5785b9a974ed225c90dc72fff460259e66b95b73648596dbcc50d51ed69cdf464af2d237d3149b2
  languageName: node
  linkType: hard

"ms@npm:^2.0.0":
  version: 2.1.3
  resolution: "ms@npm:2.1.3"
  checksum: 10c0/d924b57e7312b3b63ad21fc5b3dc0af5e78d61a1fc7cfb5457edaf26326bf62be5307cc87ffb6862ef1c2b33b0233cdb5d4f01c4c958cc0d660948b65a287a48
  languageName: node
  linkType: hard

"msgpack-lite@npm:^0.1.26":
  version: 0.1.26
  resolution: "msgpack-lite@npm:0.1.26"
  dependencies:
    event-lite: "npm:^0.1.1"
    ieee754: "npm:^1.1.8"
    int64-buffer: "npm:^0.1.9"
    isarray: "npm:^1.0.0"
  bin:
    msgpack: ./bin/msgpack
  checksum: 10c0/ba571dca7d789fa033523b74c1aae52bbd023834bcad3f397f481889a8df6cdb6b163b73307be8b744c420ce6d3c0e697f588bb96984c04f9dcf09370b9f12d4
  languageName: node
  linkType: hard

"mustache@npm:^4.2.0":
  version: 4.2.0
  resolution: "mustache@npm:4.2.0"
  bin:
    mustache: bin/mustache
  checksum: 10c0/1f8197e8a19e63645a786581d58c41df7853da26702dbc005193e2437c98ca49b255345c173d50c08fe4b4dbb363e53cb655ecc570791f8deb09887248dd34a2
  languageName: node
  linkType: hard

"nock@npm:*, nock@npm:^14.0.1":
  version: 14.0.1
  resolution: "nock@npm:14.0.1"
  dependencies:
    "@mswjs/interceptors": "npm:^0.37.3"
    json-stringify-safe: "npm:^5.0.1"
    propagate: "npm:^2.0.0"
  checksum: 10c0/258d123eb726f81268ee8ba2b69f8fdd5763c416027542bf5d255dae9c21ab3fcff936f2f57fa829dac4371aea2d4bd34a2dc3837008f317bb9893bf48fe736d
  languageName: node
  linkType: hard

"node-domexception@npm:1.0.0":
  version: 1.0.0
  resolution: "node-domexception@npm:1.0.0"
  checksum: 10c0/5e5d63cda29856402df9472335af4bb13875e1927ad3be861dc5ebde38917aecbf9ae337923777af52a48c426b70148815e890a5d72760f1b4d758cc671b1a2b
  languageName: node
  linkType: hard

"node-fetch@npm:^2.6.7":
  version: 2.7.0
  resolution: "node-fetch@npm:2.7.0"
  dependencies:
    whatwg-url: "npm:^5.0.0"
  peerDependencies:
    encoding: ^0.1.0
  peerDependenciesMeta:
    encoding:
      optional: true
  checksum: 10c0/b55786b6028208e6fbe594ccccc213cab67a72899c9234eb59dba51062a299ea853210fcf526998eaa2867b0963ad72338824450905679ff0fa304b8c5093ae8
  languageName: node
  linkType: hard

"openai@npm:^4.77.0":
  version: 4.83.0
  resolution: "openai@npm:4.83.0"
  dependencies:
    "@types/node": "npm:^18.11.18"
    "@types/node-fetch": "npm:^2.6.4"
    abort-controller: "npm:^3.0.0"
    agentkeepalive: "npm:^4.2.1"
    form-data-encoder: "npm:1.7.2"
    formdata-node: "npm:^4.3.2"
    node-fetch: "npm:^2.6.7"
  peerDependencies:
    ws: ^8.18.0
    zod: ^3.23.8
  peerDependenciesMeta:
    ws:
      optional: true
    zod:
      optional: true
  bin:
    openai: bin/cli
  checksum: 10c0/8ca7cf1e67a91b746402575acff035dc664f4b50f95533229caa581a9c4f16e9692765fc53be3e8b0ecda0c5efc6735e803154b02c7d69119149f622792e0bb0
  languageName: node
  linkType: hard

"outvariant@npm:^1.4.0, outvariant@npm:^1.4.3":
  version: 1.4.3
  resolution: "outvariant@npm:1.4.3"
  checksum: 10c0/5976ca7740349cb8c71bd3382e2a762b1aeca6f33dc984d9d896acdf3c61f78c3afcf1bfe9cc633a7b3c4b295ec94d292048f83ea2b2594fae4496656eba992c
  languageName: node
  linkType: hard

"p-finally@npm:^1.0.0":
  version: 1.0.0
  resolution: "p-finally@npm:1.0.0"
  checksum: 10c0/6b8552339a71fe7bd424d01d8451eea92d379a711fc62f6b2fe64cad8a472c7259a236c9a22b4733abca0b5666ad503cb497792a0478c5af31ded793d00937e7
  languageName: node
  linkType: hard

"p-queue@npm:^6.6.2":
  version: 6.6.2
  resolution: "p-queue@npm:6.6.2"
  dependencies:
    eventemitter3: "npm:^4.0.4"
    p-timeout: "npm:^3.2.0"
  checksum: 10c0/5739ecf5806bbeadf8e463793d5e3004d08bb3f6177bd1a44a005da8fd81bb90f80e4633e1fb6f1dfd35ee663a5c0229abe26aebb36f547ad5a858347c7b0d3e
  languageName: node
  linkType: hard

"p-retry@npm:4":
  version: 4.6.2
  resolution: "p-retry@npm:4.6.2"
  dependencies:
    "@types/retry": "npm:0.12.0"
    retry: "npm:^0.13.1"
  checksum: 10c0/d58512f120f1590cfedb4c2e0c42cb3fa66f3cea8a4646632fcb834c56055bb7a6f138aa57b20cc236fb207c9d694e362e0b5c2b14d9b062f67e8925580c73b0
  languageName: node
  linkType: hard

"p-timeout@npm:^3.2.0":
  version: 3.2.0
  resolution: "p-timeout@npm:3.2.0"
  dependencies:
    p-finally: "npm:^1.0.0"
  checksum: 10c0/524b393711a6ba8e1d48137c5924749f29c93d70b671e6db761afa784726572ca06149c715632da8f70c090073afb2af1c05730303f915604fd38ee207b70a61
  languageName: node
  linkType: hard

"propagate@npm:^2.0.0":
  version: 2.0.1
  resolution: "propagate@npm:2.0.1"
  checksum: 10c0/01e1023b60ae4050d1a2783f976d7db702022dbdb70dba797cceedad8cfc01b3939c41e77032f8c32aa9d93192fe937ebba1345e8604e5ce61fd3b62ee3003b8
  languageName: node
  linkType: hard

"retry@npm:^0.13.1":
  version: 0.13.1
  resolution: "retry@npm:0.13.1"
  checksum: 10c0/9ae822ee19db2163497e074ea919780b1efa00431d197c7afdb950e42bf109196774b92a49fc9821f0b8b328a98eea6017410bfc5e8a0fc19c85c6d11adb3772
  languageName: node
  linkType: hard

"semver@npm:^7.6.3":
  version: 7.7.1
  resolution: "semver@npm:7.7.1"
  bin:
    semver: bin/semver.js
  checksum: 10c0/fd603a6fb9c399c6054015433051bdbe7b99a940a8fb44b85c2b524c4004b023d7928d47cb22154f8d054ea7ee8597f586605e05b52047f048278e4ac56ae958
  languageName: node
  linkType: hard

"simple-wcswidth@npm:^1.0.1":
  version: 1.0.1
  resolution: "simple-wcswidth@npm:1.0.1"
  checksum: 10c0/2befead4c97134424aa3fba593a81daa9934fd61b9e4c65374b57ac5eecc2f2be1984b017bbdbc919923e19b77f2fcbdb94434789b9643fa8c3fde3a2a6a4b6f
  languageName: node
  linkType: hard

"strict-event-emitter@npm:^0.5.1":
  version: 0.5.1
  resolution: "strict-event-emitter@npm:0.5.1"
  checksum: 10c0/f5228a6e6b6393c57f52f62e673cfe3be3294b35d6f7842fc24b172ae0a6e6c209fa83241d0e433fc267c503bc2f4ffdbe41a9990ff8ffd5ac425ec0489417f7
  languageName: node
  linkType: hard

"supports-color@npm:^7.1.0":
  version: 7.2.0
  resolution: "supports-color@npm:7.2.0"
  dependencies:
    has-flag: "npm:^4.0.0"
  checksum: 10c0/afb4c88521b8b136b5f5f95160c98dee7243dc79d5432db7efc27efb219385bbc7d9427398e43dd6cc730a0f87d5085ce1652af7efbe391327bc0a7d0f7fc124
  languageName: node
  linkType: hard

"tr46@npm:~0.0.3":
  version: 0.0.3
  resolution: "tr46@npm:0.0.3"
  checksum: 10c0/047cb209a6b60c742f05c9d3ace8fa510bff609995c129a37ace03476a9b12db4dbf975e74600830ef0796e18882b2381fb5fb1f6b4f96b832c374de3ab91a11
  languageName: node
  linkType: hard

"undici-types@npm:~5.26.4":
  version: 5.26.5
  resolution: "undici-types@npm:5.26.5"
  checksum: 10c0/bb673d7876c2d411b6eb6c560e0c571eef4a01c1c19925175d16e3a30c4c428181fb8d7ae802a261f283e4166a0ac435e2f505743aa9e45d893f9a3df017b501
  languageName: node
  linkType: hard

"undici-types@npm:~6.20.0":
  version: 6.20.0
  resolution: "undici-types@npm:6.20.0"
  checksum: 10c0/68e659a98898d6a836a9a59e6adf14a5d799707f5ea629433e025ac90d239f75e408e2e5ff086afc3cace26f8b26ee52155293564593fbb4a2f666af57fc59bf
  languageName: node
  linkType: hard

"uuid@npm:^10.0.0":
  version: 10.0.0
  resolution: "uuid@npm:10.0.0"
  bin:
    uuid: dist/bin/uuid
  checksum: 10c0/eab18c27fe4ab9fb9709a5d5f40119b45f2ec8314f8d4cf12ce27e4c6f4ffa4a6321dc7db6c515068fa373c075b49691ba969f0010bf37f44c37ca40cd6bf7fe
  languageName: node
  linkType: hard

"web-streams-polyfill@npm:4.0.0-beta.3":
  version: 4.0.0-beta.3
  resolution: "web-streams-polyfill@npm:4.0.0-beta.3"
  checksum: 10c0/a9596779db2766990117ed3a158e0b0e9f69b887a6d6ba0779940259e95f99dc3922e534acc3e5a117b5f5905300f527d6fbf8a9f0957faf1d8e585ce3452e8e
  languageName: node
  linkType: hard

"webidl-conversions@npm:^3.0.0":
  version: 3.0.1
  resolution: "webidl-conversions@npm:3.0.1"
  checksum: 10c0/5612d5f3e54760a797052eb4927f0ddc01383550f542ccd33d5238cfd65aeed392a45ad38364970d0a0f4fea32e1f4d231b3d8dac4a3bdd385e5cf802ae097db
  languageName: node
  linkType: hard

"whatwg-url@npm:^5.0.0":
  version: 5.0.0
  resolution: "whatwg-url@npm:5.0.0"
  dependencies:
    tr46: "npm:~0.0.3"
    webidl-conversions: "npm:^3.0.0"
  checksum: 10c0/1588bed84d10b72d5eec1d0faa0722ba1962f1821e7539c535558fb5398d223b0c50d8acab950b8c488b4ba69043fd833cc2697056b167d8ad46fac3995a55d5
  languageName: node
  linkType: hard

"zod-to-json-schema@npm:^3.22.3":
  version: 3.24.1
  resolution: "zod-to-json-schema@npm:3.24.1"
  peerDependencies:
    zod: ^3.24.1
  checksum: 10c0/dd4e72085003e41a3f532bd00061f27041418a4eb176aa6ce33042db08d141bd37707017ee9117d97738ae3f22fc3e1404ea44e6354634ac5da79d7d3173b4ee
  languageName: node
  linkType: hard

"zod@npm:^3.22.4":
  version: 3.24.1
  resolution: "zod@npm:3.24.1"
  checksum: 10c0/0223d21dbaa15d8928fe0da3b54696391d8e3e1e2d0283a1a070b5980a1dbba945ce631c2d1eccc088fdbad0f2dfa40155590bf83732d3ac4fcca2cc9237591b
  languageName: node
  linkType: hard

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/copy-page.css
```css
/* Minimal CSS for copy page button */
.copy-page-btn {
    background: transparent;
    border: 1px solid var(--md-default-fg-color--lightest);
    padding: 6px 12px;
    margin-right: 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    color: var(--md-default-fg-color);
    transition: all 0.2s ease;
}

.copy-page-btn:hover {
    background: var(--md-default-fg-color--lightest);
}
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/copy-page.js
```js
// Simple copy page functionality - just copy the markdown content
function copyPageAsMarkdown() {
    const markdownScript = document.getElementById('page-markdown-content');
    if (!markdownScript) {
        alert('Markdown content not available for this page');
        return;
    }
    
    try {
        const data = JSON.parse(markdownScript.textContent);
        const content = `# ${data.title}\n\nSource: ${window.location.href}\n\n${data.markdown}`;
        
        navigator.clipboard.writeText(content).then(() => {
            // Simple notification
            const notification = document.createElement('div');
            notification.textContent = 'Page content copied to clipboard';
            notification.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:10px;border-radius:4px;z-index:9999;';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }).catch(() => {
            alert('Failed to copy content');
        });
    } catch (e) {
        alert('Failed to parse page content');
    }
}

// Add button to header - simpler approach
document.addEventListener('DOMContentLoaded', function() {
    const headerSource = document.querySelector('.md-header__source');
    if (headerSource) {
        const button = document.createElement('button');
        button.textContent = 'Copy page';
        button.onclick = copyPageAsMarkdown;
        button.style.cssText = 'background:none;border:1px solid #ddd;padding:6px 12px;margin-right:8px;border-radius:4px;cursor:pointer;';
        headerSource.parentNode.insertBefore(button, headerSource);
    }
});
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/language-switcher.css
```css
.lang-python,
.lang-javascript {
    display: none;
}

.language-switcher-global {
    display: flex;
    align-items: center;
    padding-left: 0.5rem;
    margin-right: 0.5rem;
}

/* Style the select to match the header */
.language-switcher-global select {
    appearance: none;
    font: inherit;
    border: none;
    padding: 0.25rem 0.6rem;
    cursor: pointer;
    outline: none;
    font-weight: bolder;
}

/* Hover/focus effect */
.language-switcher-global select:hover,
.language-switcher-global select:focus {
    text-decoration: underline;
}

/* Theme-specific overrides */
html[data-md-color-scheme="default"] .language-switcher-global select,
html[data-md-color-scheme="default"] .language-switcher-global option {
    color: #333;
    background-color: transparent;
}

html[data-md-color-scheme="slate"] .language-switcher-global select,
html[data-md-color-scheme="slate"] .language-switcher-global option {
    color: #eee;
    background-color: transparent;
}

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/language-switcher.js
```js
function applyLanguageSwitching() {
    const selector = document.getElementById("global-language-selector");

    const langBlocks = {
        python: document.querySelectorAll(".lang-python"),
        javascript: document.querySelectorAll(".lang-javascript"),
    };

    const setLanguage = (lang) => {
        for (const [key, blocks] of Object.entries(langBlocks)) {
            blocks.forEach((block) => {
                block.style.display = key === lang ? "block" : "none";
            });
        }
        localStorage.setItem("preferredLang", lang);
    };

    const saved = localStorage.getItem("preferredLang") || "python";

    if (selector) {
        selector.value = saved;
        selector.addEventListener("change", (e) => setLanguage(e.target.value));
    }

    setLanguage(saved);
}

// Run on initial load
document.addEventListener("DOMContentLoaded", applyLanguageSwitching);

// Re-run after client-side navigation (MkDocs Material)
document.addEventListener("pjax:success", applyLanguageSwitching);

// Optional: observe DOM changes (e.g., for late-loaded content)
if (window.MutationObserver) {
    const observer = new MutationObserver(() => applyLanguageSwitching());
    observer.observe(document.body, { childList: true, subtree: true });
}

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/main.html
```html
{% extends "base.html" %}

{% block analytics %}
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-T35S4S46');</script>
<!-- End Google Tag Manager -->
{% endblock %}


{% block extrahead %}
  <meta name="algolia-site-verification" content="165B7E7C89E49946" />
  <script>
    // Simple copy page functionality - uses original markdown source
    function copyPageAsMarkdown() {
        const markdownScript = document.getElementById('page-markdown-content');
        if (!markdownScript) {
            alert('Markdown content not available for this page');
            return;
        }
        
        try {
            let rawContent = markdownScript.textContent;
            
            // Safe HTML entity decoding function
            function decodeHtmlEntities(text) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/html');
                return doc.documentElement.textContent || '';
            }
            
            // Always decode HTML entities since the browser might encode them
            rawContent = decodeHtmlEntities(rawContent);
            
            
            const data = JSON.parse(rawContent);
            const content = `Source: ${window.location.href}\n\n${data.markdown}`;
            
            navigator.clipboard.writeText(content).then(() => {
                // Simple notification
                const notification = document.createElement('div');
                notification.textContent = 'Page content copied to clipboard';
                notification.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:10px 16px;border-radius:4px;z-index:9999;box-shadow:0 2px 10px rgba(0,0,0,0.2);';
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }).catch(() => {
                alert('Failed to copy content');
            });
        } catch (e) {
            console.error('Failed to parse page content:', e);
            alert('Failed to parse page content: ' + e.message);
        }
    }

    // Add dropdown button to header when page loads
    document.addEventListener('DOMContentLoaded', function() {
        const headerSource = document.querySelector('.md-header__source');
        if (headerSource) {
            // Create dropdown container
            const dropdownContainer = document.createElement('div');
            dropdownContainer.style.cssText = 'position:relative;display:inline-block;margin-left:8px;';
            
            // Create main button
            const button = document.createElement('button');
            button.innerHTML = 'Copy page <span style="margin-left:8px;font-size:12px;color:#9ca3af;"></span>';
            button.style.cssText = 'background:transparent;border:1px solid #d1d5db;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:14px;color:#374151;transition:all 0.2s ease;white-space:nowrap;display:flex;align-items:center;';
            
            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'copy-page-dropdown';
            dropdown.style.cssText = 'position:absolute;top:100%;left:0;background:white;border:1px solid #e5e7eb;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:1000;min-width:180px;display:none;padding:4px 0;';
            
            // Create dropdown options
            const option1 = document.createElement('div');
            option1.textContent = 'Copy as Markdown for LLMs';
            option1.className = 'copy-page-option';
            option1.style.cssText = 'padding:8px 16px;cursor:pointer;font-size:14px;color:#374151;margin:2px 0;';
            option1.onmouseover = function() { 
                this.style.background = document.documentElement.getAttribute('data-md-color-scheme') === 'slate' ? '#4a5568' : '#f8fafc'; 
            };
            option1.onmouseout = function() { this.style.background = 'transparent'; };
            option1.onclick = function() {
                // Check if we're on a reference page
                if (window.location.pathname.includes('/reference/')) {
                    alert('Copy Page not yet available in API reference pages.');
                } else {
                    copyPageAsMarkdown();
                }
                dropdown.style.display = 'none';
            };
            
            const option2 = document.createElement('div');
            option2.textContent = "View LangGraph's llms.txt";
            option2.className = 'copy-page-option';
            option2.style.cssText = 'padding:8px 16px;cursor:pointer;font-size:14px;color:#374151;margin:2px 0;';
            option2.onmouseover = function() { 
                this.style.background = document.documentElement.getAttribute('data-md-color-scheme') === 'slate' ? '#4a5568' : '#f8fafc'; 
            };
            option2.onmouseout = function() { this.style.background = 'transparent'; };
            option2.onclick = function() {
                window.open('/langgraph/llms-txt-overview/', '_blank');
                dropdown.style.display = 'none';
            };
            
            // Add options to dropdown
            dropdown.appendChild(option1);
            dropdown.appendChild(option2);
            
            // Button hover effects
            button.onmouseover = function() { 
                this.style.background = '#f3f4f6'; 
                this.style.borderColor = '#9ca3af'; 
            };
            button.onmouseout = function() { 
                this.style.background = 'transparent'; 
                this.style.borderColor = '#d1d5db'; 
            };
            
            // Toggle dropdown
            button.onclick = function(e) {
                e.stopPropagation();
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            };
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function() {
                dropdown.style.display = 'none';
            });
            
            // Assemble dropdown
            dropdownContainer.appendChild(button);
            dropdownContainer.appendChild(dropdown);
            headerSource.parentNode.insertBefore(dropdownContainer, headerSource.nextSibling);
        }
    });
  </script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Public+Sans&display=swap");
    :root {
      --md-primary-fg-color: #333333;
      --md-accent-fg-color: #1E88E5;
      --md-default-bg-color: #FFFFFF;
      --md-default-fg-color: #333333;
      --md-text-font-family: "Public Sans", sans-serif;
    }

    body {
      font-family: var(--md-text-font-family);
      background-color: var(--md-default-bg-color);
      color: var(--md-default-fg-color);
    }

    .md-main {
      background-color: #FFFFFF;
    }

    .md-footer {
      background-color: #F5F5F5;
      color: #666666;
    }

    .md-footer-meta {
      background-color: #4d4d4d;
    }

    .md-typeset a {
      color: #1E88E5;
    }

    .md-typeset a:hover {
      color: #1565C0;
    }

    .md-nav__link--active,
    .md-nav__link:active {
      color: #1E88E5;
    }

    .md-search__input {
      background-color: #F5F5F5;
      color: #333333;
    }

    .md-search__input:hover,
    .md-search__input:focus {
      background-color: #EEEEEE;
    }
    /* Table of contents styles */
    .md-nav--secondary .md-nav__item--active > .md-nav__link {
      font-weight: bold;
      color: var(--md-primary-fg-color);
    }

    .md-nav--secondary .md-nav__item--nested > .md-nav__link {
      font-weight: normal;
      color: var(--md-default-fg-color);
    }

    .md-nav--secondary .md-nav__item--nested > .md-nav__link::before {
      content: "";
      display: inline-block;
      width: 6px;
      height: 6px;
      background-color: var(--md-default-fg-color);
      border-radius: 50%;
      margin-right: 0.5rem;
    }

    [data-md-color-scheme="slate"] {
      --md-default-bg-color: #1E1E1E;
      --md-default-fg-color: #FFFFFF;
      --md-accent-fg-color: #64B5F6;
    }

    [data-md-color-scheme="slate"] .md-main {
      background-color: #1E1E1E;
    }

    [data-md-color-scheme="slate"] .navbar {
      background-color: #1E1E1E;
      color: #FFFFFF;
      box-shadow: none;
    }

    [data-md-color-scheme="slate"] .md-footer {
      background-color: #1E1E1E;
      color: #BDBDBD;
    }

    [data-md-color-scheme="slate"] .md-header {
      background-color: #1E1E1E;
      color: #BDBDBD;
    }

    [data-md-color-scheme="slate"] .md-tabs {
      background-color: #1E1E1E;
      color: #BDBDBD;
    }

    [data-md-color-scheme="slate"] .md-search__input {
      background-color: #F5F5F5;
      color: #333333;
    }

    [data-md-color-scheme="slate"] .md-search__icon {
      color: #333333;
    }

    [data-md-color-scheme="slate"] .md-search__input::placeholder {
      color: #333333;
    }

    [data-md-color-scheme="slate"] .md-footer-meta {
      background-color: #4d4d4d;
    }

    [data-md-color-scheme="slate"] .md-typeset a {
      color: #64B5F6;
    }

    [data-md-color-scheme="slate"] .md-typeset a:hover {
      color: #90CAF9;
    }

    .notebook-links {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 1rem;
    }
    .notebook-links .md-content__button {
      margin-left: 0.5rem;
    }

    [data-md-color-scheme=default] .logo-dark {
      display: none !important;
    }

    [data-md-color-scheme=slate] .logo-light {
      display: none !important;
    }

    .jupyter-wrapper .jp-CodeCell .jp-Cell-inputWrapper .jp-InputPrompt.jp-InputArea-prompt {
      display: none !important;
    }

    .jupyter-wrapper .jp-Notebook .jp-Cell .jp-OutputPrompt {
      display: none !important;
    }

    .md-banner {
      background-color: #FFAE42;
      color: #000000;
    }

    .md-banner a {
      color: #000000;
      text-decoration: underline;
    }

    .md-banner a:hover {
      color: #000000;
    }

    .md-header__title {
      visibility: hidden;
    }

    /* Dark mode banner styling */
    [data-md-color-scheme="slate"] .md-banner {
      background-color: #CFC9FA; /* Same light purple for both modes */
      color: #000000;
    }

    [data-md-color-scheme="slate"] .md-banner a {
      color: #000000;
    }

    [data-md-color-scheme="slate"] .md-banner a:hover {
      color: #000000;
    }

    /* Copy page dropdown dark mode support */
    [data-md-color-scheme="slate"] .copy-page-dropdown {
      background: #1f2937 !important;
      border-color: #374151 !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important;
    }

    [data-md-color-scheme="slate"] .copy-page-option {
      color: #e5e7eb !important;
    }

  </style>
{% endblock %}

{% block content %}
<div class="notebook-links">
  {% if page.nb_url %}
    <a href="{{ page.nb_url }}" title="Download Notebook" class="md-content__button md-icon">
      {% include ".icons/material/download.svg" %}
    </a>
  {% endif %}
</div>

{{ super() }}
{% endblock content %}


{% block htmltitle %}
  {% if page.meta and page.meta.title %}
    <title>{{ page.meta.title }}</title>
  {% elif page.title and not page.is_homepage %}
    <title>{{ page.title | striptags }}</title>
  {% else %}
    <title>{{ config.site_name }}</title>
  {% endif %}
{% endblock %}

{% block announce %}
These docs will be deprecated and removed with the release of LangGraph v1.0 in October 2025. <a href="https://docs.langchain.com/oss/python/langgraph/overview" target="_blank">Visit the v1.0 alpha docs</a>
{% endblock %}

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/partials/language-toggle.html
```html
<div class="md-header__button language-switcher-global" title="Select Language">
  <select id="global-language-selector" aria-label="Select Language">
    <option value="python"> Python</option>
    <option value="javascript"> JavaScript</option>
  </select>
</div>

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/overrides/partials/logo.html
```html
{% if config.theme.logo_light_mode %}
  <img src="{{ config.theme.logo_light_mode | url }}" alt="logo" class="logo-light" />
  <img src="{{ config.theme.logo_dark_mode | url }}" alt="logo" class="logo-dark" />
{% endif %}
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/adopters.md
```md
#  Case studies

This list of companies using LangGraph and their success stories is compiled from public sources. If your company uses LangGraph, we'd love for you to share your story and add it to the list. Youre also welcome to contribute updates based on publicly available information from other companies, such as blog posts or press releases.


| Company | Industry | Use case | Reference |
| --- | --- | --- | --- |
| [AirTop](https://www.airtop.ai/) | Software & Technology (GenAI Native) | Browser automation for AI agents | [Case study, 2024](https://blog.langchain.dev/customers-airtop/) |
| [AppFolio](https://www.appfolio.com/) | Real Estate | Copilot for domain-specific task | [Case study, 2024](https://blog.langchain.dev/customers-appfolio/) |
| [Athena Intelligence](https://www.athenaintel.com/) | Software & Technology (GenAI Native) | Research & summarization | [Case study, 2024](https://blog.langchain.dev/customers-athena-intelligence/) |
| [BlackRock](https://www.blackrock.com/) | Financial Services | Copilot for domain-specific task | [Interrupt talk, 2025](https://youtu.be/oyqeCHFM5U4?feature=shared) |
| [Captide](https://www.captide.co/) | Software & Technology (GenAI Native) | Data extraction | [Case study, 2025](https://blog.langchain.dev/how-captide-is-redefining-equity-research-with-agentic-workflows-built-on-langgraph-and-langsmith/) |
| [Cisco CX](https://www.cisco.com/site/us/en/services/modern-data-center/index.html?CCID=cc005911&DTID=eivtotr001480&OID=srwsas032775) | Software & Technology | Customer support | [Interrupt Talk, 2025](https://youtu.be/gPhyPRtIMn0?feature=shared) |
| [Cisco Outshift](https://outshift.cisco.com/) | Software & Technology | DevOps | [Video story, 2025](https://www.youtube.com/watch?v=htcb-vGR_x0); [Case study, 2025](https://blog.langchain.com/cisco-outshift/); [Blog post, 2025](https://outshift.cisco.com/blog/build-react-agent-application-for-devops-tasks-using-rest-apis) |
| [Cisco TAC](https://www.cisco.com/c/en/us/support/index.html) | Software & Technology | Customer support | [Video story, 2025](https://youtu.be/EAj0HBDGqaE?feature=shared) |
| [City of Hope](https://www.cityofhope.org/) | Non-profit | Copilot for domain-specific task | [Video story, 2025](https://youtu.be/9ABwtK2gIZU?feature=shared) |
| [C.H. Robinson](https://www.chrobinson.com/en-us/) | Logistics | Automation | [Case study, 2025](https://blog.langchain.dev/customers-chrobinson/) |
| [Definely](https://www.definely.com/) | Legal | Copilot for domain-specific task | [Case study, 2025](https://blog.langchain.com/customers-definely/) |
| [Docent Pro](https://docentpro.com/) | Travel | GenAI embedded product experiences | [Case study, 2025](https://blog.langchain.com/customers-docentpro/) |
| [Elastic](https://www.elastic.co/) | Software & Technology | Copilot for domain-specific task | [Blog post, 2025](https://www.elastic.co/blog/elastic-security-generative-ai-features) |
| [Exa](https://exa.ai/) | Software & Technology (GenAI Native) | Search | [Case study, 2025](https://blog.langchain.com/exa/) |
| [GitLab](https://about.gitlab.com/) | Software & Technology | Code generation | [Duo workflow docs](https://handbook.gitlab.com/handbook/engineering/architecture/design-documents/duo_workflow/) |
| [Harmonic](https://harmonic.ai/) | Software & Technology | Search | [Case study, 2025](https://blog.langchain.com/customers-harmonic/) |
| [Inconvo](https://inconvo.ai/?ref=blog.langchain.dev) | Software & Technology | Code generation | [Case study, 2025](https://blog.langchain.dev/customers-inconvo/) |
| [Infor](https://infor.com/) | Software & Technology | GenAI embedded product experiences; customer support; copilot | [Case study, 2025](https://blog.langchain.dev/customers-infor/) |
| [J.P. Morgan](https://www.jpmorganchase.com/) | Financial Services | Copilot for domain-specific task | [Interrupt talk, 2025](https://youtu.be/yMalr0jiOAc?feature=shared) |
| [Klarna](https://www.klarna.com/) | Fintech | Copilot for domain-specific task | [Case study, 2025](https://blog.langchain.dev/customers-klarna/) |
| [Komodo Health](https://www.komodohealth.com/) | Healthcare | Copilot for domain-specific task | [Blog post](https://www.komodohealth.com/perspectives/new-gen-ai-assistant-empowers-the-enterprise/) |
| [LinkedIn](https://www.linkedin.com/) | Social Media | Code generation; Search & discovery | [Interrupt talk, 2025](https://youtu.be/NmblVxyBhi8?feature=shared); [Blog post, 2025](https://www.linkedin.com/blog/engineering/ai/practical-text-to-sql-for-data-analytics); [Blog post, 2024](https://www.linkedin.com/blog/engineering/generative-ai/behind-the-platform-the-journey-to-create-the-linkedin-genai-application-tech-stack) |
| [Minimal](https://gominimal.ai/) | E-commerce | Customer support | [Case study, 2025](https://blog.langchain.dev/how-minimal-built-a-multi-agent-customer-support-system-with-langgraph-langsmith/) |
| [Modern Treasury](https://www.moderntreasury.com/) | Fintech | GenAI embedded product experiences | [Video story, 2025](https://youtu.be/AwAiffXqaCU?feature=shared) |
| [Monday](https://monday.com/) | Software & Technology | GenAI embedded product experiences | [Interrupt talk, 2025](https://blog.langchain.dev/how-minimal-built-a-multi-agent-customer-support-system-with-langgraph-langsmith/) |
| [Morningstar](https://www.morningstar.com/) | Financial Services | Research & summarization | [Video story, 2025](https://youtu.be/6LidoFXCJPs?feature=shared) |
| [OpenRecovery](https://www.openrecovery.com/) | Healthcare | Copilot for domain-specific task | [Case study, 2024](https://blog.langchain.dev/customers-openrecovery/) |
| [Pigment](https://www.pigment.com/) | Fintech | GenAI embedded product experiences | [Video story, 2025](https://youtu.be/5JVSO2KYOmE?feature=shared) |
| [Prosper](https://www.prosper.com/) | Fintech | Customer support | [Video story, 2025](https://youtu.be/9RFNOYtkwsc?feature=shared) |
| [Qodo](https://www.qodo.ai/) | Software & Technology (GenAI Native) | Code generation | [Blog post, 2025](https://www.qodo.ai/blog/why-we-chose-langgraph-to-build-our-coding-agent/) |
| [Rakuten](https://www.rakuten.com/) | E-commerce / Fintech | Copilot for domain-specific task | [Video story, 2025](https://youtu.be/gD1LIjCkuA8?feature=shared); [Blog post, 2025](https://rakuten.today/blog/from-ai-hype-to-real-world-tools-rakuten-teams-up-with-langchain.html) |
| [Replit](https://replit.com/) | Software & Technology | Code generation | [Blog post, 2024](https://blog.langchain.dev/customers-replit/); [Breakout agent story, 2024](https://www.langchain.com/breakoutagents/replit); [Fireside chat video, 2024](https://www.youtube.com/watch?v=ViykMqljjxU) |
| [Rexera](https://www.rexera.com/) | Real Estate (GenAI Native) | Copilot for domain-specific task | [Case study, 2024](https://blog.langchain.dev/customers-rexera/) |
| [Abu Dhabi Government](https://www.tamm.abudhabi/) | Government | Search | [Case study, 2025](https://blog.langchain.com/customers-abu-dhabi-government/) |
| [Tradestack](https://www.tradestack.uk/) | Software & Technology (GenAI Native) | Copilot for domain-specific task | [Case study, 2024](https://blog.langchain.dev/customers-tradestack/) |
| [Uber](https://www.uber.com/) | Transportation | Developer productivity; Code generation | [Interrupt talk, 2025](https://youtu.be/Bugs0dVcNI8?feature=shared); [Presentation, 2024](https://dpe.org/sessions/ty-smith-adam-huda/this-year-in-ubers-ai-driven-developer-productivity-revolution/); [Video, 2024](https://www.youtube.com/watch?v=8rkA5vWUE4Y) |
| [Unify](https://www.unifygtm.com/) | Software & Technology (GenAI Native) | Copilot for domain-specific task | [Interrupt talk, 2025](https://youtu.be/pKk-LfhujwI?feature=shared); [Blog post, 2024](https://blog.langchain.dev/unify-launches-agents-for-account-qualification-using-langgraph-and-langsmith/) |
| [Vizient](https://www.vizientinc.com/) | Healthcare | Copilot for domain-specific task | [Video story, 2025](https://www.youtube.com/watch?v=vrjJ6NuyTWA); [Case study, 2025](https://blog.langchain.dev/p/3d2cd58c-13a5-4df9-bd84-7d54ed0ed82c/) |
| [Vodafone](https://www.vodafone.com/) | Telecommunications | Code generation; internal search | [Case study, 2025](https://blog.langchain.dev/customers-vodafone/) |
| [WebToon](https://www.webtoons.com/en/) | Media & Entertainment | Data extraction | [Case study, 2025](https://blog.langchain.com/customers-webtoon/) |
| [11x](https://www.11x.ai/) | Software & Technology (GenAI Native) | Research & outreach | [Interrupt talk, 2025](https://youtu.be/fegwPmaAPQk?feature=shared) |

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/index.md
```md
---
hide_comments: true
title: LangGraph
---

<script>
  // This script only runs in MkDocs, not on GitHub
  var hideGitHubVersion = function() {
    document.querySelectorAll('.github-only').forEach(el => el.style.display = 'none');
  };

  // Handle both initial load and subsequent navigation
  document.addEventListener('DOMContentLoaded', hideGitHubVersion);
  document$.subscribe(hideGitHubVersion);
</script>

<p class="mkdocs-only">
  <img class="logo-light" src="static/wordmark_dark.svg" alt="LangGraph Logo" width="80%">
  <img class="logo-dark" src="static/wordmark_light.svg" alt="LangGraph Logo" width="80%">
</p>

<style>
.md-content h1 {
  display: none;
}
.md-header__topic {
  display: none;
}
</style>

{% include-markdown "../../README.md" %}
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/llms-txt-overview.md
```md
# llms.txt

Below you can find a list of documentation files in the [`llms.txt`](https://llmstxt.org/) format, specifically `llms.txt` and `llms-full.txt`. These files allow large language models (LLMs) and agents to access programming documentation and APIs, particularly useful within integrated development environments (IDEs).

| Language Version | llms.txt                                                                                                   | llms-full.txt                                                                                                        |
|------------------|------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| LangGraph Python | [https://langchain-ai.github.io/langgraph/llms.txt](https://langchain-ai.github.io/langgraph/llms.txt)     | [https://langchain-ai.github.io/langgraph/llms-full.txt](https://langchain-ai.github.io/langgraph/llms-full.txt)     |
| LangGraph JS     | [https://langchain-ai.github.io/langgraphjs/llms.txt](https://langchain-ai.github.io/langgraphjs/llms.txt) | [https://langchain-ai.github.io/langgraphjs/llms-full.txt](https://langchain-ai.github.io/langgraphjs/llms-full.txt) |
| LangChain Python | [https://python.langchain.com/llms.txt](https://python.langchain.com/llms.txt)                             | N/A                                                                                                                  |
| LangChain JS     | [https://js.langchain.com/llms.txt](https://js.langchain.com/llms.txt)                                     | N/A                                                                                                                  |

!!! info "Review the output"

    Even with access to up-to-date documentation, current state-of-the-art models may not always generate correct code. Treat the generated code as a starting point, and always review it before shipping
    code to production.

## Differences Between `llms.txt` and `llms-full.txt`

- **`llms.txt`** is an index file containing links with brief descriptions of the content. An LLM or agent must follow these links to access detailed information.

- **`llms-full.txt`** includes all the detailed content directly in a single file, eliminating the need for additional navigation.

A key consideration when using `llms-full.txt` is its size. For extensive documentation, this file may become too large to fit into an LLM's context window.

## Using `llms.txt` via an MCP Server

As of March 9, 2025, IDEs [do not yet have robust native support for `llms.txt`](https://x.com/jeremyphoward/status/1902109312216129905?t=1eHFv2vdNdAckajnug0_Vw&s=19). However, you can still use `llms.txt` effectively through an MCP server.

###  Use the `mcpdoc` Server

We provide an **MCP server** that was designed to serve documentation for LLMs and IDEs:

 **[langchain-ai/mcpdoc GitHub Repository](https://github.com/langchain-ai/mcpdoc)**

This MCP server allows integrating `llms.txt` into tools like **Cursor**, **Windsurf**, **Claude**, and **Claude Code**.

 **Setup instructions and usage examples** are available in the repository.

## Using `llms-full.txt`

The LangGraph `llms-full.txt` file typically contains several hundred thousand tokens, exceeding the context window limitations of most LLMs. To effectively use this file:

1. **With IDEs (e.g., Cursor, Windsurf)**:
    - Add the `llms-full.txt` as custom documentation. The IDE will automatically chunk and index the content, implementing Retrieval-Augmented Generation (RAG).

2. **Without IDE support**:
    - Use a chat model with a large context window.
    - Implement a RAG strategy to manage and query the documentation efficiently.


```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/llms.txt
```txt

# Guides

- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/index/): This page provides an overview of the LangGraph project, including its logo and essential scripts for functionality within MkDocs. It also includes a reference to the README.md file for detailed information about the project. The content is designed to be user-friendly and visually appealing.
- [LangGraph Quickstart Guide](https://langchain-ai.github.io/langgraph/agents/agents/): This quickstart guide provides step-by-step instructions for setting up and using LangGraph's prebuilt components to create agentic systems. It covers prerequisites, installation, agent creation, configuration of language models, and advanced features like memory and structured output. Ideal for developers looking to leverage LangGraph for building intelligent agents.
- [Getting Started with LangGraph: Building AI Agents](https://langchain-ai.github.io/langgraph/concepts/why-langgraph/): This page provides an overview of LangGraph, a platform designed for developers to create adaptable AI agents. It highlights key features such as reliability, extensibility, and streaming support, and offers a series of tutorials to help users build a support chatbot with various capabilities. By following the tutorials, developers will learn to implement essential functionalities like conversation state management and human-in-the-loop controls.
- [Building a Basic Chatbot with LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/1-build-basic-chatbot/): This tutorial guides you through the process of creating a basic chatbot using LangGraph. It covers prerequisites, installation of necessary packages, and step-by-step instructions to set up a state machine for the chatbot. By the end of the tutorial, you will have a functional chatbot that can engage in simple conversations.
- [Integrating Web Search Tools into Your Chatbot](https://langchain-ai.github.io/langgraph/tutorials/get-started/2-add-tools/): This tutorial guides you through the process of enhancing your chatbot's capabilities by integrating a web search tool, specifically the Tavily Search Engine. It covers prerequisites, installation, configuration, and the implementation of the search tool within a LangGraph-based chatbot. By the end, you'll have a functional chatbot that can retrieve real-time information to answer user queries beyond its training data.
- [Implementing Memory in Chatbots with LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/3-add-memory/): This page provides a comprehensive guide on how to add memory functionality to chatbots using LangGraph's persistent checkpointing feature. It details the steps to create a `MemorySaver` checkpointer, compile the graph, and interact with the chatbot to maintain context across multiple interactions. Additionally, it explains how to inspect the state of the chatbot and highlights the advantages of checkpointing over simple memory solutions.
- [Implementing Human-in-the-Loop Controls in LangGraph](https://langchain-ai.github.io/langgraph/tutorials/get-started/4-human-in-the-loop/): This page provides a comprehensive guide on adding human-in-the-loop controls to LangGraph workflows, enabling agents to pause execution for human input. It details the use of the `interrupt` function to facilitate user feedback and outlines the steps to integrate a `human_assistance` tool into a chatbot. Additionally, the tutorial covers graph compilation, visualization, and resuming execution with human input.
- [Customizing State in LangGraph for Enhanced Chatbot Functionality](https://langchain-ai.github.io/langgraph/tutorials/get-started/5-customize-state/): This tutorial guides you through the process of adding custom fields to the state in LangGraph, enabling complex behaviors in your chatbot without relying solely on message lists. You will learn how to implement human-in-the-loop controls to verify information before it is stored in the state. By the end of this tutorial, you will have a deeper understanding of state management and how to enhance your chatbot's capabilities.
- [Implementing Time Travel in LangGraph Chatbots](https://langchain-ai.github.io/langgraph/tutorials/get-started/6-time-travel/): This page provides a comprehensive guide on utilizing the time travel functionality in LangGraph to enhance chatbot interactions. It covers how to rewind, add steps, and replay the state history of a chatbot, allowing users to explore different outcomes and fix mistakes. Additionally, it includes code snippets and practical examples to help developers implement these features effectively.
- [LangGraph Deployment Options](https://langchain-ai.github.io/langgraph/tutorials/deployment/): This page outlines the various options available for deploying LangGraph applications, including local testing and different cloud-based solutions. It details free deployment methods such as Local, as well as production options like Cloud SaaS and self-hosted solutions. Each deployment method is linked to further documentation for in-depth guidance.
- [Agent Development with LangGraph](https://langchain-ai.github.io/langgraph/agents/overview/): This page provides an overview of agent development using LangGraph, highlighting its prebuilt components and capabilities for building agent-based applications. It explains the structure of an agent, key features such as memory integration and human-in-the-loop control, and outlines the package ecosystem available for developers. With LangGraph, users can focus on application logic while leveraging robust infrastructure for state management and feedback.
- [Guide to Running Agents in LangGraph](https://langchain-ai.github.io/langgraph/agents/run_agents/): This page provides a comprehensive overview of how to execute agents in LangGraph, detailing both synchronous and asynchronous methods. It covers input and output formats, streaming capabilities, and how to manage execution limits to prevent infinite loops. Additionally, it includes code examples and links to further resources for deeper understanding.
- [Streaming Data in LangGraph](https://langchain-ai.github.io/langgraph/agents/streaming/): This page provides an overview of streaming data types in LangGraph, including agent progress, LLM tokens, and custom updates. It includes code examples for both synchronous and asynchronous streaming methods. Additionally, it covers how to stream multiple modes and disable streaming when necessary.
- [Configuring Chat Models for Agents](https://langchain-ai.github.io/langgraph/agents/models/): This page provides detailed instructions on how to configure various chat models for use with agents in LangChain. It covers model initialization, tool calling support, and how to specify models from different providers such as OpenAI, Anthropic, Azure, Google Gemini, and AWS Bedrock. Additionally, it includes information on disabling streaming, adding model fallbacks, and links to further resources.
- [Using Tools in LangChain](https://langchain-ai.github.io/langgraph/agents/tools/): This page provides an overview of how to define, customize, and manage tools within the LangChain framework. It covers creating simple tools, handling tool errors, and utilizing prebuilt integrations for enhanced functionality. Additionally, it discusses advanced features such as memory management and controlling tool behavior during agent execution.
- [Integrating MCP with LangGraph Agents](https://langchain-ai.github.io/langgraph/agents/mcp/): This page provides a comprehensive guide on how to integrate the Model Context Protocol (MCP) with LangGraph agents using the `langchain-mcp-adapters` library. It includes installation instructions, example code for using MCP tools, and guidance on creating custom MCP servers. Additional resources for further reading on MCP are also provided.
- [Understanding Context in LangGraph Agents](https://langchain-ai.github.io/langgraph/agents/context/): This page provides an overview of how to supply context to agents in LangGraph, detailing the three primary types: Config, State, and Long-Term Memory. It explains how to use these context types to enhance agent behavior, customize prompts, and access context in tools. Additionally, it includes code examples for implementing context in various scenarios.
- [Understanding Memory in LangGraph for Conversational Agents](https://langchain-ai.github.io/langgraph/agents/memory/): This documentation page provides an overview of the two types of memory supported by LangGraph: short-term and long-term memory. It explains how to implement these memory types in conversational agents, including code examples and best practices for managing message history. Additionally, it covers the use of persistent storage and tools for enhancing memory functionality.
- [Implementing Human-in-the-Loop in LangGraph](https://langchain-ai.github.io/langgraph/agents/human-in-the-loop/): This documentation page provides a comprehensive guide on how to implement Human-in-the-Loop (HIL) features in LangGraph, allowing for human review and approval of tool calls in agents. It covers the use of the `interrupt()` function to pause execution for human input, along with practical examples and code snippets. Additionally, it explains how to create a wrapper to add HIL capabilities to any tool seamlessly.
- [Building Multi-Agent Systems](https://langchain-ai.github.io/langgraph/agents/multi-agent/): This page provides an overview of multi-agent systems, detailing how to create and manage them using supervisor and swarm architectures. It includes practical examples of implementing a flight and hotel booking assistant using the LangGraph libraries. Additionally, the page explains the concept of handoffs between agents, allowing for seamless communication and task delegation.
- [Evaluating Agent Performance with LangSmith](https://langchain-ai.github.io/langgraph/agents/evals/): This page provides a comprehensive guide on how to evaluate the performance of agents using the LangSmith evaluations framework. It includes instructions on defining evaluator functions, utilizing prebuilt evaluators from the AgentEvals package, and running evaluations with specific datasets. Additionally, it covers different evaluation techniques, including trajectory matching and using LLMs as judges.
- [Deploying Your LangGraph Agent](https://langchain-ai.github.io/langgraph/agents/deployment/): This page provides a comprehensive guide on how to deploy a LangGraph agent, including setting up a LangGraph app for both local development and production. It covers essential features, installation steps, and configuration requirements, along with instructions for launching the local server and utilizing the LangGraph Studio Web UI for debugging. Additionally, it offers links to further resources for deployment options.
- [Agent Chat UI Documentation](https://langchain-ai.github.io/langgraph/agents/ui/): This page provides comprehensive guidance on using the Agent Chat UI for interacting with LangGraph agents. It covers setup instructions, features like human-in-the-loop workflows, and the integration of generative UI components. Users can find links to relevant resources and tips for customizing their chat experience.
- [Overview of Agent Architectures in LLM Applications](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/): This page provides a comprehensive overview of various agent architectures used in large language model (LLM) applications, highlighting their control flows and functionalities. It discusses key concepts such as routers, tool-calling agents, memory management, and planning, along with customization options for specific tasks. Additionally, it covers advanced features like human-in-the-loop, parallelization, subgraphs, and reflection mechanisms to enhance agent performance.
- [Understanding Workflows and Agents in LangGraph](https://langchain-ai.github.io/langgraph/tutorials/workflows/): This documentation page provides an in-depth overview of workflows and agents within LangGraph, highlighting their differences and use cases. It covers various patterns for building agentic systems, including setup instructions, building blocks, and advanced concepts like prompt chaining, parallelization, and routing. Additionally, it offers practical examples and code snippets to help users implement these workflows effectively.
- [Understanding LangGraph: Core Concepts and Components](https://langchain-ai.github.io/langgraph/concepts/low_level/): This documentation page provides an in-depth overview of the core concepts of LangGraph, focusing on how agent workflows are modeled as graphs. It covers essential components such as States, Nodes, and Edges, and explains how they interact to create complex workflows. Additionally, it discusses graph compilation, message handling, and configuration options to enhance the functionality of your graphs.
- [LangGraph Runtime Overview](https://langchain-ai.github.io/langgraph/concepts/pregel/): This page provides a comprehensive overview of the LangGraph runtime, specifically focusing on the Pregel execution model. It details the structure and functionality of actors and channels within the Pregel framework, along with examples of how to implement applications. Additionally, it introduces high-level APIs for creating Pregel applications using StateGraph and Functional API.
- [Using the LangGraph API: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/how-tos/graph-api/): This documentation provides a detailed overview of how to utilize the LangGraph Graph API, covering essential concepts such as state management, node creation, and control flow. It includes practical examples for building sequences, branches, and loops, as well as advanced features like retry policies and async execution. Additionally, the guide offers insights into visualizing graphs and integrating with external tools.
- [LangGraph Streaming System](https://langchain-ai.github.io/langgraph/concepts/streaming/): This page provides an overview of the streaming capabilities of LangGraph, enabling real-time updates for enhanced user experiences. It details the types of data that can be streamed, including workflow progress, LLM tokens, and custom updates. Additionally, it outlines various functionalities and modes available for streaming within the LangGraph framework.
- [Streaming Outputs in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/streaming/): This documentation page provides an overview of how to utilize the streaming capabilities of LangGraph, including synchronous and asynchronous streaming methods. It covers various stream modes, such as updates, values, and custom data, along with examples of how to implement them in your graphs. Additionally, it discusses the integration of Large Language Models (LLMs) and how to handle streaming outputs effectively.
- [LangGraph Persistence and Checkpointing](https://langchain-ai.github.io/langgraph/concepts/persistence/): This page provides an in-depth overview of the persistence layer in LangGraph, focusing on the use of checkpointers to save graph states at each super-step. It covers key concepts such as threads, checkpoints, state retrieval, and memory management, along with practical examples and code snippets. Additionally, it discusses advanced features like time travel, fault tolerance, and the integration of memory stores for cross-thread information retention.
- [Understanding Durable Execution in LangGraph](https://langchain-ai.github.io/langgraph/concepts/durable_execution/): This page provides an overview of durable execution, a technique that allows workflows to save their progress and resume from key points. It details the requirements for implementing durable execution in LangGraph, including the use of persistence and tasks to ensure deterministic and consistent replay. Additionally, it covers how to handle pausing, resuming, and recovering workflows effectively.
- [Implementing Memory in LangGraph for AI Applications](https://langchain-ai.github.io/langgraph/how-tos/persistence/): This documentation page provides a comprehensive guide on adding persistence to AI applications using LangGraph. It covers both short-term and long-term memory implementations, including code examples for managing conversation context and user-specific data. Additionally, it discusses the use of various storage backends and semantic search capabilities for enhanced memory management.
- [Understanding Memory in AI Agents](https://langchain-ai.github.io/langgraph/concepts/memory/): This documentation page provides an in-depth overview of memory types in AI agents, focusing on short-term and long-term memory. It explains how these memory types can be implemented and managed within applications using LangGraph, including techniques for handling conversation history and storing memories. Additionally, it discusses the importance of memory in enhancing user interactions and the various strategies for writing and updating memories.
- [Memory Management in LangGraph for AI Applications](https://langchain-ai.github.io/langgraph/how-tos/memory/): This page provides an overview of memory management in LangGraph, focusing on short-term and long-term memory functionalities essential for conversational agents. It includes detailed instructions on how to implement memory strategies such as trimming, summarizing, and deleting messages to optimize conversation tracking without exceeding context limits. Code examples are provided to illustrate the implementation of these memory management techniques.
- [Human-in-the-Loop Workflows in LangGraph](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/): This page provides an overview of the human-in-the-loop (HIL) capabilities within LangGraph, highlighting how human intervention can enhance automated processes. It details key features such as persistent execution state and flexible integration points, along with typical use cases for validating outputs and providing context. Additionally, it outlines the implementation of HIL through specific functions and primitives.
- [Implementing Human-in-the-Loop Workflows with Interrupts](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/add-human-in-the-loop/): This documentation page provides a comprehensive guide on using the `interrupt` function in LangGraph to facilitate human-in-the-loop workflows. It covers the implementation details, design patterns, and best practices for pausing graph execution to gather human input, as well as how to resume execution with that input. Additionally, it highlights common pitfalls and offers extended examples to illustrate various use cases.
- [Understanding Breakpoints in LangGraph](https://langchain-ai.github.io/langgraph/concepts/breakpoints/): This page provides an overview of breakpoints in LangGraph, which allow users to pause graph execution at specific points for inspection. It explains how breakpoints utilize the persistence layer to save the graph state and how execution can be resumed after inspection. An illustrative example is included to demonstrate the concept visually.
- [Using Breakpoints in Graph Execution](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/breakpoints/): This page provides a comprehensive guide on how to implement breakpoints in graph execution for debugging purposes. It covers the requirements for setting breakpoints, the difference between static and dynamic breakpoints, and includes code examples for both compile-time and run-time configurations. Additionally, it explains how to manage breakpoints in subgraphs.
- [Time Travel Functionality in LangGraph](https://langchain-ai.github.io/langgraph/concepts/time-travel/): This page explains the time travel feature in LangGraph, which allows users to analyze and debug decision-making processes in non-deterministic systems. It outlines how to understand reasoning, debug mistakes, and explore alternative solutions by resuming execution from prior checkpoints. The functionality enables users to create new forks in the execution history for deeper insights.
- [Using Time-Travel in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/time-travel/): This page provides a comprehensive guide on how to implement time-travel functionality in LangGraph. It outlines the steps to run a graph, identify checkpoints, modify graph states, and resume execution from specific checkpoints. Additionally, an example workflow is included to illustrate the process of generating and modifying jokes using LangGraph.
- [Integrating Tools with AI Models](https://langchain-ai.github.io/langgraph/concepts/tools/): This page provides an overview of how AI models can interact with external systems using tool calling. It explains the concept of tools, their integration with chat models, and how to create or use prebuilt tools for various applications. Additionally, it highlights the importance of relevance in tool invocation and offers links to further resources and guides.
- [Using Tools in LangChain](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/): This documentation page provides a comprehensive guide on how to create and utilize tools within the LangChain framework. It covers defining simple and customized tools, managing tool arguments, accessing configuration and state, and integrating tools with chat models and agents. Additionally, it discusses error handling and strategies for managing a large number of tools.
- [Understanding Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/concepts/subgraphs/): This page provides an overview of subgraphs in LangGraph, explaining their role as encapsulated nodes within larger graphs. It discusses the benefits of using subgraphs, such as facilitating multi-agent systems and enabling independent team work. Additionally, it outlines the communication methods between parent graphs and subgraphs, detailing scenarios involving shared and different state schemas.
- [Using Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/subgraph/): This guide provides an overview of how to effectively use subgraphs within LangGraph, including communication methods between parent graphs and subgraphs. It covers shared and different state schemas, setup instructions, and examples for implementing subgraphs in multi-agent systems. Additionally, it discusses persistence, state management, and streaming outputs from subgraphs.
- [Understanding Multi-Agent Systems](https://langchain-ai.github.io/langgraph/concepts/multi_agent/): This page provides an in-depth overview of multi-agent systems, focusing on the architecture and benefits of using multiple independent agents to manage complex applications. It discusses various multi-agent architectures, including network, supervisor, and hierarchical models, as well as communication strategies and state management techniques for effective agent interaction.
- [Building Multi-Agent Systems with LangGraph](https://langchain-ai.github.io/langgraph/how-tos/multi_agent/): This guide provides an overview of how to build multi-agent systems using LangGraph, focusing on the implementation of handoffs for agent communication. It covers the creation of independent agents, the use of handoffs to transfer control and data between agents, and examples of prebuilt multi-agent architectures. Additionally, it includes code snippets and best practices for managing agent interactions and state.
- [Understanding the Functional API in LangGraph](https://langchain-ai.github.io/langgraph/concepts/functional_api/): This documentation page provides an overview of the Functional API in LangGraph, detailing its key features such as persistence, memory, and human-in-the-loop capabilities. It explains how to define workflows using the `@entrypoint` and `@task` decorators, along with examples and best practices for implementing workflows with state management and streaming. Additionally, it compares the Functional API with the Graph API, highlighting their differences and use cases.
- [Functional API Documentation](https://langchain-ai.github.io/langgraph/how-tos/use-functional-api/): This page provides comprehensive guidance on using the Functional API, including creating workflows, handling parallel execution, and integrating with other APIs. It covers various features such as retry policies, caching, and human-in-the-loop workflows, along with practical examples. Additionally, it discusses memory management strategies for both short-term and long-term use cases.
- [Overview of LangGraph Platform](https://langchain-ai.github.io/langgraph/concepts/langgraph_platform/): The LangGraph Platform is designed for developing, deploying, and managing long-running agent workflows with ease. This page outlines the platform's features, including streaming support, background runs, and memory management, which enhance the performance and reliability of agent applications. Additionally, it provides links to resources for getting started and deploying agents effectively.
- [LangGraph Platform Quickstart Guide](https://langchain-ai.github.io/langgraph/tutorials/langgraph-platform/local-server/): This quickstart guide provides step-by-step instructions for running a LangGraph application locally. It covers prerequisites, installation of the LangGraph CLI, app creation, dependency installation, and launching the server. Additionally, it includes testing your application using the LangGraph Studio and API.
- [LangGraph Platform Deployment Quickstart](https://langchain-ai.github.io/langgraph/cloud/quick_start/): This quickstart guide provides step-by-step instructions for deploying an application on the LangGraph Platform using GitHub. It covers prerequisites, repository creation, deployment procedures, and testing your application and API. Follow these steps to successfully set up and run your application in the LangGraph environment.
- [Overview of LangGraph Platform Components](https://langchain-ai.github.io/langgraph/concepts/langgraph_components/): This page provides a comprehensive overview of the various components that make up the LangGraph Platform. It details the functionalities of each component, including the LangGraph Server, CLI, Studio, SDKs, and the control and data planes. Users can learn how these components work together to facilitate the development, deployment, and management of LangGraph applications.
- [LangGraph Server Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_server/): This page provides an overview of the LangGraph Server, an API designed for creating and managing agent-based applications. It details the server versions, application structure, deployment components, and the use of assistants, persistence, and task queues. Additionally, it includes links to further resources and guides for effective deployment and usage.
- [LangGraph Application Structure Guide](https://langchain-ai.github.io/langgraph/concepts/application_structure/): This page provides an overview of the structure of a LangGraph application, detailing the essential components such as the configuration file, dependencies, graphs, and environment variables. It includes examples of directory structures for both Python and JavaScript applications, as well as guidance on how to specify the necessary information for deployment. Additionally, it covers key concepts related to the configuration file and the role of dependencies and environment variables in the application.
- [Setting Up a LangGraph Application with requirements.txt](https://langchain-ai.github.io/langgraph/cloud/deployment/setup/): This guide provides step-by-step instructions for configuring a LangGraph application for deployment using a requirements.txt file to manage dependencies. It covers essential topics such as specifying dependencies, defining environment variables, and creating the LangGraph configuration file. Additionally, it includes examples and tips for alternative setup methods.
- [Setting Up a LangGraph Application with pyproject.toml](https://langchain-ai.github.io/langgraph/cloud/deployment/setup_pyproject/): This guide provides step-by-step instructions for configuring a LangGraph application using the `pyproject.toml` file for dependency management. It covers the necessary components, including specifying dependencies, environment variables, and defining graphs, along with examples and best practices. Additionally, it offers tips for alternative setups and links to further resources for deployment.
- [Setting Up a LangGraph.js Application](https://langchain-ai.github.io/langgraph/cloud/deployment/setup_javascript/): This guide provides step-by-step instructions for configuring a LangGraph.js application for deployment on the LangGraph Platform or for self-hosting. It covers essential topics such as specifying dependencies, environment variables, defining graphs, and creating the necessary configuration file. By following this walkthrough, users will learn how to structure their application and prepare it for deployment.
- [Customizing Your Dockerfile in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/custom_docker/): This page provides a guide on how to customize your Dockerfile by adding additional commands through the `langgraph.json` configuration file. It explains how to specify the `dockerfile_lines` key to include necessary dependencies, such as installing system packages and Python libraries. An example is provided to illustrate the process of integrating the Pillow library for image processing.
- [LangGraph CLI Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_cli/): This page provides an overview of the LangGraph CLI, a command-line tool for building and running the LangGraph API server locally. It includes installation instructions, a list of core commands, and their descriptions to help users effectively utilize the CLI for development and deployment. For further details, users can refer to the LangGraph CLI Reference.
- [LangGraph Studio Documentation](https://langchain-ai.github.io/langgraph/concepts/langgraph_studio/): This page provides an overview of LangGraph Studio, an IDE for visualizing, interacting with, and debugging agentic systems that utilize the LangGraph Server API. It outlines the prerequisites for using the studio, key features, and the two operational modes: Graph mode and Chat mode. Additionally, it includes links to further resources for getting started with LangGraph Studio.
- [Getting Started with LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/studio/quick_start/): This page provides a comprehensive guide on how to connect and use LangGraph Studio with both deployed applications on the LangGraph Platform and local development servers. It includes instructions for installation, running the server, accessing the Studio UI, and debugging options. Additionally, troubleshooting tips and next steps for further exploration of LangGraph Studio features are also provided.
- [Running Applications: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/cloud/how-tos/invoke_studio/): This page provides a detailed guide on how to submit a run to your application, covering both Graph and Chat modes. It includes instructions on specifying input, managing assistants, enabling streaming, and using breakpoints. Additionally, it offers tips for running applications from specific checkpoints in existing threads.
- [Managing Assistants in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/studio/manage_assistants/): This page provides guidance on how to manage assistants within LangGraph Studio, including viewing, editing, and updating assistant configurations. It covers both Graph mode and Chat mode, detailing how to activate assistants and make changes to their settings. Users will learn how to navigate the interface to effectively manage their assistant configurations for graph runs.
- [Managing Threads in Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/threads_studio/): This page provides a comprehensive guide on how to view and edit threads within the Studio application. It covers both Graph and Chat modes, detailing the steps to create new threads, view thread history, and edit thread states. Additionally, it includes links to related concepts for further learning.
- [Modifying Prompts in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/iterate_graph_studio/): This page provides guidance on how to modify prompts within LangGraph Studio using two methods: direct node editing and the LangSmith Playground interface. It details the configuration options available for nodes, including `langgraph_nodes` and `langgraph_type`, along with examples for both Pydantic models and dataclasses. Additionally, it outlines the steps for editing prompts in the UI and utilizing the LangSmith Playground for testing LLM calls.
- [Debugging LangSmith Traces in LangGraph Studio](https://langchain-ai.github.io/langgraph/cloud/how-tos/clone_traces_studio/): This guide provides step-by-step instructions for opening and debugging LangSmith traces in LangGraph Studio. It covers how to deploy threads and test local agents with remote traces, ensuring a seamless debugging experience. Additionally, it outlines the requirements for local agents and the process for cloning threads for local testing.
- [How to Add Nodes to LangSmith Datasets](https://langchain-ai.github.io/langgraph/cloud/how-tos/datasets_studio/): This guide provides step-by-step instructions on how to add examples from nodes in the thread log to LangSmith datasets. It covers selecting threads, choosing nodes, and editing inputs/outputs before adding them to the dataset. Additionally, it includes links to further resources on evaluating intermediate steps.
- [LangGraph SDK Documentation](https://langchain-ai.github.io/langgraph/concepts/sdk/): This page provides an overview of the LangGraph SDK, including installation instructions for both Python and JavaScript. It details the synchronous and asynchronous client options available for interacting with the LangGraph Server. Additionally, it offers links to further resources and references for the SDK.
- [Integrating Semantic Search in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/semantic_search/): This guide provides step-by-step instructions on how to implement semantic search in your LangGraph deployment. It covers prerequisites, configuration of the store, and usage examples for searching memories and documents by semantic similarity. Additionally, it includes information on using custom embeddings and querying via the LangGraph SDK.
- [Configuring Time-to-Live (TTL) in LangGraph Applications](https://langchain-ai.github.io/langgraph/how-tos/ttl/configure_ttl/): This guide provides detailed instructions on how to configure Time-to-Live (TTL) settings for checkpoints and store items in LangGraph applications. It covers the necessary configurations in the `langgraph.json` file, including strategies for managing data lifecycle and memory. Additionally, it explains how to combine TTL configurations and override them at runtime.
- [LangGraph Authentication & Access Control Overview](https://langchain-ai.github.io/langgraph/concepts/auth/): This page provides a comprehensive guide to the authentication and authorization mechanisms within the LangGraph Platform. It explains the core concepts of authentication versus authorization, outlines default security models, and details the system architecture involved in user identity management. Additionally, it covers implementation examples for authentication and authorization handlers, along with common access patterns and supported resources.
- [Custom Authentication Setup for LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/auth/custom_auth/): This guide provides step-by-step instructions on how to implement custom authentication in your LangGraph Platform application. It covers the necessary prerequisites, implementation details, configuration updates, and client connection methods. The guide is applicable to both managed and Enterprise self-hosted deployments.
- [Documenting API Authentication in OpenAPI for LangGraph](https://langchain-ai.github.io/langgraph/how-tos/auth/openapi_security/): This guide provides instructions on how to customize the security schema for your LangGraph Platform API documentation using OpenAPI. It covers default security schemes for both LangGraph Platform and self-hosted deployments, as well as how to implement custom authentication. Additionally, it includes examples for OAuth2 and API key authentication, along with testing procedures.
- [Managing Assistants in LangGraph](https://langchain-ai.github.io/langgraph/concepts/assistants/): This page provides an overview of how to create and manage assistants within the LangGraph Platform, which allows for separate configuration of agents without altering the core graph logic. It covers the prerequisites, configuration options, and versioning of assistants, highlighting their role in optimizing agent performance for different tasks. Additionally, it includes links to relevant API references and how-to guides for further assistance.
- [Managing Assistants in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/): This documentation page provides a comprehensive guide on how to create, configure, and manage assistants using the LangGraph SDK and Platform UI. It includes code examples in Python and JavaScript, as well as instructions for creating new versions and using previous versions of assistants. Additionally, it covers the process of utilizing assistants in various environments.
- [Understanding Threads in LangGraph](https://langchain-ai.github.io/langgraph/cloud/concepts/threads/): This page provides an overview of threads in the LangGraph framework, detailing how they accumulate the state of runs and the importance of checkpoints. It explains the process of creating threads and retrieving their current and historical states. Additionally, it offers links to further resources on threads, checkpoints, and the LangGraph API for managing thread states.
- [Managing Threads in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/use_threads/): This documentation page provides a comprehensive guide on how to create, view, and inspect threads using the LangGraph SDK. It includes detailed instructions for creating empty threads, copying existing threads, and initializing threads with prepopulated states. Additionally, it covers how to list and inspect threads, including filtering and sorting options.
- [Understanding Runs in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/runs/): This page provides an overview of what constitutes a run in the LangGraph Platform, including its input, configuration, and metadata. It also highlights the ability to execute runs on threads and offers links to the API reference for managing runs.
- [Starting Background Runs for Your Agent](https://langchain-ai.github.io/langgraph/cloud/how-tos/background_run/): This guide provides step-by-step instructions on how to initiate background runs for your agent using Python, JavaScript, and CURL. It covers the setup process, checking current runs, starting new runs, and retrieving the final results. By following this documentation, users can efficiently manage long-running jobs within their applications.
- [Running Multiple Agents on the Same Thread in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/same-thread/): This documentation page explains how to run multiple agents on the same thread using the LangGraph Platform. It provides step-by-step examples in Python, JavaScript, and CURL to create agents, run them on a thread, and demonstrate how the second agent can utilize the context from the first agent's responses. By following the examples, users can learn to effectively manage multiple agents and their interactions.
- [Scheduling Cron Jobs with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/cron_jobs/): This page provides a comprehensive guide on how to schedule cron jobs using the LangGraph Platform. It includes setup instructions for different programming languages, examples of creating and deleting cron jobs, and details on managing stateless cron jobs. Users will learn how to automate tasks such as sending weekly emails without writing custom scripts.
- [Guide to Stateless Runs in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/stateless_runs/): This page provides a comprehensive guide on how to implement stateless runs using the LangGraph Platform. It includes setup instructions for various programming languages, examples of streaming results, and methods for waiting for stateless results. Users will learn how to execute runs without maintaining persistent state, making their applications more efficient.
- [Configurable Headers in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/configurable_headers/): This page provides guidance on how to configure headers dynamically in the LangGraph platform to modify agent behavior and permissions. It details how to include or exclude specific headers in the runtime configuration using the `langgraph.json` file. Additionally, it explains how to access these headers within your graph and offers an option to opt-out of configurable headers.
- [Streaming in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/streaming/): This page provides an overview of streaming capabilities within the LangGraph Platform, detailing the various streaming modes available for LLM applications. It includes instructions for creating streaming runs, handling stateless runs, and joining active background runs. Additionally, code examples in Python, JavaScript, and cURL are provided to illustrate the implementation of these features.
- [Streaming Outputs with LangGraph SDK](https://langchain-ai.github.io/langgraph/cloud/how-tos/streaming/): This documentation page provides detailed instructions on how to stream outputs from the LangGraph API server using the LangGraph SDK in Python, JavaScript, and cURL. It covers various streaming modes, including updates, values, and custom data, along with examples for each mode. Additionally, it explains how to handle subgraphs, debug information, and LLM tokens during streaming.
- [Human-in-the-Loop Workflows in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/add-human-in-the-loop/): This page provides an overview of the human-in-the-loop (HIL) capabilities in LangGraph, allowing for human intervention in automated processes. It details the `interrupt` function, which pauses execution for human input, and includes examples in Python, JavaScript, and cURL for implementing HIL workflows. Additionally, it links to further resources for understanding and utilizing HIL features effectively.
- [Using Breakpoints in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/human_in_the_loop_breakpoint/): This page provides an overview of how to set and use breakpoints in LangGraph to pause graph execution for inspection. It includes examples for setting breakpoints at compile time and run time in Python, JavaScript, and cURL. Additionally, it offers guidance on resuming execution after hitting a breakpoint.
- [Using Time Travel in LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/human_in_the_loop_time_travel/): This page provides a comprehensive guide on how to utilize the time travel functionality in LangGraph, allowing users to resume execution from previous checkpoints. It outlines the steps to run a graph, identify checkpoints, modify graph states, and resume execution. Additionally, the page includes code examples in Python, JavaScript, and cURL for practical implementation.
- [Model Context Protocol (MCP) Endpoint Documentation](https://langchain-ai.github.io/langgraph/concepts/server-mcp/): This page provides comprehensive documentation on the Model Context Protocol (MCP) endpoint available in LangGraph Server. It covers the requirements for using MCP, how to expose agents as MCP tools, and includes examples for connecting with MCP-compliant clients in various programming languages. Additionally, it outlines session behavior, authentication, and instructions for disabling the MCP endpoint.
- [Managing Double Texting in LangGraph](https://langchain-ai.github.io/langgraph/concepts/double_texting/): This page provides an overview of how to handle double texting scenarios in LangGraph, where users may send multiple messages before the first has completed. It outlines four strategies: Reject, Enqueue, Interrupt, and Rollback, each with links to detailed configuration guides. Prerequisites for implementing these strategies include having the LangGraph Server set up.
- [Using the Interrupt Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/interrupt_concurrent/): This guide provides detailed instructions on how to utilize the `interrupt` option for double texting, allowing users to interrupt a prior run of a graph and start a new one. It includes setup instructions, code examples in Python, JavaScript, and CURL, as well as guidance on viewing run results and verifying the status of interrupted runs. Familiarity with double texting is assumed, and a link to a conceptual guide is provided for further understanding.
- [Using the Rollback Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/rollback_concurrent/): This guide provides detailed instructions on how to utilize the `rollback` option in double texting, which allows users to interrupt a previous run and start a new one while permanently deleting the prior run from the database. It includes setup instructions, code examples in Python, JavaScript, and CURL, and demonstrates how to view run results and verify the deletion of the original run. Familiarity with double texting is assumed, and a link to a conceptual guide is provided for further reading.
- [Using the Reject Option in Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/reject_concurrent/): This guide provides an overview of the `reject` option in double texting, which prevents new runs of a graph from starting while an original run is still in progress. It includes setup instructions, code examples in Python, JavaScript, and CURL, and demonstrates how to handle errors when attempting to create concurrent runs. Additionally, it shows how to view the results of the original run after the rejection.
- [Using the Enqueue Option for Double Texting](https://langchain-ai.github.io/langgraph/cloud/how-tos/enqueue_concurrent/): This guide provides an overview of the `enqueue` option for double texting, which allows interruptions to be queued and executed in the order they are received. It includes setup instructions, code examples in Python, JavaScript, and CURL for creating runs, and methods for viewing run results. Familiarity with double texting concepts is assumed, and a helper function for output formatting is also provided.
- [Understanding Webhooks in LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/webhooks/): This page provides an overview of webhooks and their role in enabling event-driven communication between LangGraph Platform applications and external services. It explains how to use the `webhook` parameter in various endpoints to trigger requests upon the completion of API calls. For further details, a link to a comprehensive how-to guide is also included.
- [Using Webhooks with LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/how-tos/webhooks/): This documentation page provides a comprehensive guide on how to implement webhooks in the LangGraph Platform to receive updates after API calls. It includes details on supported endpoints, setup instructions for different programming languages, and examples of how to specify webhook parameters in API requests. Additionally, it covers security measures and testing tools for verifying webhook functionality.
- [Scheduling Tasks with Cron Jobs on LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/concepts/cron_jobs/): This page provides an overview of how to use cron jobs on the LangGraph Platform to run assistants on a defined schedule. It explains the process of setting up a cron job, including specifying the schedule, assistant, and input. Additionally, it includes links to a how-to guide and API reference for further details.
- [Scheduling Cron Jobs with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/cron_jobs/): This page provides a comprehensive guide on how to use cron jobs with the LangGraph Platform to automate graph executions on a schedule. It includes setup instructions for various programming languages, examples of creating and deleting cron jobs, and tips for managing stateless cron jobs. Users will learn how to efficiently schedule tasks without manual intervention, ensuring timely execution of automated processes.
- [Adding Custom Lifespan Events in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/http/custom_lifespan/): This page provides a guide on how to implement custom lifespan events in your LangGraph Platform applications, specifically for Python deployments. It covers the initialization and cleanup of resources during server startup and shutdown using FastAPI. Additionally, it includes code examples and configuration steps to help you integrate these events into your application.
- [Adding Custom Middleware to LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/http/custom_middleware/): This page provides a step-by-step guide on how to add custom middleware to your server when deploying agents to the LangGraph Platform. It covers the necessary code implementation using FastAPI, configuration settings in `langgraph.json`, and instructions for testing and deploying your application. Additionally, it offers links to related topics such as custom routes and lifespan events for further customization.
- [Adding Custom Routes in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/http/custom_routes/): This page provides a step-by-step guide on how to add custom routes to your LangGraph platform application using a Starlette or FastAPI app. It includes instructions for creating a new app, configuring the `langgraph.json` file, and testing the server locally. Additionally, it explains how custom routes can override default endpoints and offers suggestions for further customization.
- [LangGraph Deployment Options](https://langchain-ai.github.io/langgraph/concepts/deployment_options/): This page outlines the various deployment options available for the LangGraph Platform, including Cloud SaaS, Self-Hosted Data Plane, Self-Hosted Control Plane, and Standalone Container. Each option is described in detail, highlighting key features, management responsibilities, and compatibility. A comparison table is also provided to help users choose the best deployment strategy for their needs.
- [LangGraph Data Plane Overview](https://langchain-ai.github.io/langgraph/concepts/langgraph_data_plane/): This page provides a comprehensive overview of the LangGraph Data Plane, detailing its components including the server infrastructure, listener application, and data management systems like Postgres and Redis. It also covers key features such as autoscaling, static IP addresses, and custom configurations for Postgres and Redis. Additionally, the page outlines telemetry, licensing, and tracing functionalities relevant to different deployment options.
- [LangGraph Control Plane Overview](https://langchain-ai.github.io/langgraph/concepts/langgraph_control_plane/): This page provides a comprehensive overview of the LangGraph Control Plane, detailing its UI and API functionalities for managing LangGraph Servers. It covers deployment types, environment variables, database provisioning, and asynchronous deployment processes. Additionally, it highlights the integration with LangSmith for tracing projects.
- [Cloud SaaS Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_cloud/): This page provides a comprehensive guide on deploying the LangGraph Server using the Cloud SaaS model. It outlines the roles of the control plane and data plane, detailing their functionalities and management. Additionally, it includes an architectural diagram to illustrate the deployment structure.
- [Deployment Guide for LangGraph Platform](https://langchain-ai.github.io/langgraph/cloud/deployment/cloud/): This page provides a comprehensive guide on how to deploy applications to the LangGraph Platform using GitHub repositories. It covers prerequisites, steps for creating new deployments and revisions, managing deployment settings, and viewing logs. Additionally, it includes instructions for whitelisting IP addresses and modifying GitHub repository access.
- [Self-Hosted Data Plane Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_self_hosted_data_plane/): This page provides an overview of the Self-Hosted Data Plane deployment option, which allows users to manage their data plane infrastructure while offloading control plane management to LangChain. It outlines the requirements, architecture, and supported compute platforms for deployment. Additionally, it includes important information regarding the beta status of this deployment option.
- [Deploying a Self-Hosted Data Plane](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_data_plane/): This page provides a comprehensive guide on deploying a Self-Hosted Data Plane using Kubernetes and Amazon ECS. It outlines the prerequisites, setup steps, and configuration details necessary for a successful deployment. Additionally, it highlights the current beta status of this deployment option.
- [Self-Hosted Control Plane Deployment Guide](https://langchain-ai.github.io/langgraph/concepts/langgraph_self_hosted_control_plane/): This page provides an overview of the Self-Hosted Control Plane deployment option, currently in beta. It outlines the requirements, architecture, and compute platforms supported for deploying the control and data planes in your cloud environment. Additionally, it includes important links and resources for managing your self-hosted infrastructure.
- [Deploying a Self-Hosted Control Plane](https://langchain-ai.github.io/langgraph/cloud/deployment/self_hosted_control_plane/): This page provides a comprehensive guide on deploying a Self-Hosted Control Plane using Kubernetes. It outlines the prerequisites, setup steps, and configuration details necessary for a successful deployment. Additionally, it highlights the beta status of this deployment option and includes links to relevant resources for further assistance.
- [Deploying LangGraph Server with Standalone Container](https://langchain-ai.github.io/langgraph/concepts/langgraph_standalone_container/): This page provides a comprehensive guide on deploying a LangGraph Server using the Standalone Container option. It outlines the architecture, supported compute platforms, and Enterprise server version features. Users will find essential information on managing the data plane infrastructure without a control plane.
- [Deploying a Standalone Container with LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/standalone_container/): This documentation provides a comprehensive guide on deploying a standalone container for the LangGraph application. It covers prerequisites, environment variable configurations, and deployment methods using Docker and Docker Compose. Additionally, it includes instructions for deploying on Kubernetes using Helm.
- [Scalability and Resilience of LangGraph Platform](https://langchain-ai.github.io/langgraph/concepts/scalability_and_resilience/): This page provides an overview of the scalability and resilience features of the LangGraph Platform. It details how the platform handles server and queue scalability, as well as the mechanisms in place for ensuring resilience during both graceful and hard shutdowns. Additionally, it covers the resilience strategies employed for Postgres and Redis to maintain service availability.
- [LangGraph Platform Plans Overview](https://langchain-ai.github.io/langgraph/concepts/plans/): This page provides an overview of the different plans available for the LangGraph Platform, including Developer, Plus, and Enterprise options. Each plan offers varying deployment options, usage limits, and features tailored to different user needs. For detailed pricing and related resources, links to additional documentation are also included.

# Examples

- [Building an Agentic RAG System](https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/): This tutorial guides you through the process of creating a retrieval agent (RAG) system using LangChain and LangGraph. You will learn how to fetch and preprocess documents, create a retriever tool, and build an agentic RAG that intelligently decides when to retrieve information or respond directly to user queries. By the end, you'll have a functional system capable of semantic search and context-aware responses.
- [Building a Multi-Agent Supervisor System](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/): This tutorial guides you through the process of creating a multi-agent supervisor system using specialized agents for research and math tasks. You will learn how to set up the environment, create individual worker agents, and implement a supervisor that orchestrates their interactions. By the end, you'll have a fully functional multi-agent architecture capable of handling complex queries.
- [Building a SQL Agent with LangChain](https://langchain-ai.github.io/langgraph/tutorials/sql-agent/): This tutorial provides a step-by-step guide on how to create a SQL agent capable of answering questions about a SQL database. It covers the setup of necessary dependencies, configuration of a SQLite database, and the implementation of a prebuilt agent that interacts with the database to generate and execute queries. Additionally, it discusses customizing the agent for more control over its behavior.
- [Custom Run ID, Tags, and Metadata for LangSmith Graph Runs](https://langchain-ai.github.io/langgraph/how-tos/run-id-langsmith/): This guide provides instructions on how to pass a custom run ID and set tags and metadata for graph runs in LangSmith. It covers prerequisites, configuration options, and includes code examples for setting up and running a graph with LangGraph. Additionally, it explains how to view and filter traces in the LangSmith platform.
- [Custom Authentication Setup for Chatbots](https://langchain-ai.github.io/langgraph/tutorials/auth/getting_started/): This tutorial guides you through the process of setting up custom authentication for a chatbot using the LangGraph platform. You will learn how to implement token-based security to control user access, starting with a basic example and preparing for more advanced authentication methods in future tutorials. By the end, you'll have a functional chatbot that restricts access to authenticated users.
- [Implementing Private Conversations in Chatbots](https://langchain-ai.github.io/langgraph/tutorials/auth/resource_auth/): This tutorial guides you through extending a chatbot to enable private conversations for each user by implementing resource-level access control. You'll learn how to add authorization handlers to ensure users can only access their own threads and test the functionality to confirm proper access restrictions. Additionally, the tutorial covers scoped authorization handlers for more granular control over resource access.
- [Integrating OAuth2 Authentication with Supabase](https://langchain-ai.github.io/langgraph/tutorials/auth/add_auth_server/): This tutorial guides you through replacing hard-coded tokens with real user accounts using OAuth2 for secure authentication in your LangGraph application. You'll learn how to set up Supabase as your identity provider, implement token validation, and ensure proper user authorization. By the end, you'll have a production-ready authentication system that allows users to securely access their own data.
- [Rebuilding Graphs at Runtime in LangGraph](https://langchain-ai.github.io/langgraph/cloud/deployment/graph_rebuild/): This guide explains how to rebuild your graph at runtime with different configurations in LangGraph. It covers the necessary prerequisites, how to define graphs, and the steps to modify your graph-making function for dynamic behavior based on user input. Additionally, it provides examples of both static and dynamic graph configurations.
- [Interacting with RemoteGraph in LangGraph](https://langchain-ai.github.io/langgraph/how-tos/use-remote-graph/): This documentation page provides a comprehensive guide on how to interact with a LangGraph Platform deployment using the RemoteGraph interface. It covers the initialization of RemoteGraph, invoking the graph both asynchronously and synchronously, and utilizing it as a subgraph. Additionally, it includes code examples in Python and JavaScript to facilitate understanding and implementation.
- [Deploying Agents on LangGraph Platform](https://langchain-ai.github.io/langgraph/how-tos/autogen-langgraph-platform/): This page provides a comprehensive guide on how to deploy agents like AutoGen and CrewAI using the LangGraph Platform. It covers the necessary setup, agent definition, and wrapping the agent in a LangGraph node for deployment. Additionally, it highlights the benefits of using LangGraph for scalable infrastructure and memory support.
- [Integrating LangGraph with React: A Comprehensive Guide](https://langchain-ai.github.io/langgraph/cloud/how-tos/use_stream_react/): This documentation provides a detailed guide on how to integrate the LangGraph platform into your React applications using the `useStream()` hook. It covers installation, key features, example implementations, and customization options for building chat experiences. Additionally, it includes advanced topics such as event handling, TypeScript support, and managing conversation threads.
- [Implementing Generative User Interfaces with LangGraph](https://langchain-ai.github.io/langgraph/cloud/how-tos/generative_ui_react/): This documentation provides a comprehensive guide on how to implement Generative User Interfaces (Generative UI) using the LangGraph platform. It covers prerequisites, step-by-step tutorials for defining UI components, sending them in graphs, and handling them in React applications. Additionally, it includes how-to guides for customizing components and managing UI state effectively.

# Resources

- [LangGraph FAQ](https://langchain-ai.github.io/langgraph/concepts/faq/): This FAQ page provides answers to common questions about LangGraph, an orchestration framework for complex agentic systems. It covers topics such as the differences between LangGraph and LangChain, performance impacts, open-source status, and compatibility with various LLMs. Additionally, it outlines the distinctions between LangGraph and LangGraph Platform, including features and deployment options.
- [Getting Started with LangGraph Templates](https://langchain-ai.github.io/langgraph/concepts/template_applications/): This page provides an overview of open source reference applications known as templates, designed to help users quickly build applications with LangGraph. It includes installation instructions for the LangGraph CLI, a list of available templates with their descriptions, and guidance on creating and deploying a new LangGraph app. Users can find links to repositories for each template and next steps for customizing their applications.
- [Guide to Using llms.txt and llms-full.txt for LLMs](https://langchain-ai.github.io/langgraph/llms-txt-overview/): This page provides an overview of the `llms.txt` and `llms-full.txt` formats, which facilitate access to programming documentation for large language models (LLMs) and agents. It outlines the differences between the two formats, usage instructions via an MCP server, and best practices for integrating these files into integrated development environments (IDEs). Additionally, it highlights considerations for managing large documentation files effectively.
- [Community Agents for LangGraph](https://langchain-ai.github.io/langgraph/agents/prebuilt/): This page provides a list of community-built libraries that extend the functionality of LangGraph. Each entry includes the library name, GitHub URL, a brief description, and additional metrics like weekly downloads and stars. Additionally, it outlines how to contribute your own library to the LangGraph documentation.
- [LangGraph Error Reference Guide](https://langchain-ai.github.io/langgraph/troubleshooting/errors/index/): This page serves as a comprehensive reference for resolving common errors encountered while using the LangGraph platform. It includes a list of error codes and links to detailed guides for troubleshooting specific issues. Users can find solutions for errors related to graph recursion, concurrent updates, node return values, and more.
- [Handling Recursion Limits in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/GRAPH_RECURSION_LIMIT/): This page provides guidance on managing recursion limits in LangGraph's StateGraph. It explains how to identify potential infinite loops in your graph and offers solutions for increasing the recursion limit when working with complex graphs. Additionally, it includes code examples to illustrate the concepts discussed.
- [Handling INVALID_CONCURRENT_GRAPH_UPDATE in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_CONCURRENT_GRAPH_UPDATE/): This page explains the INVALID_CONCURRENT_GRAPH_UPDATE error that occurs in LangGraph when multiple nodes attempt to update the same state property concurrently. It provides an example of how this error can arise and offers a solution by using a reducer to combine values from parallel node executions. Additionally, troubleshooting tips are included to help resolve this issue.
- [Handling Invalid Node Return Values in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_GRAPH_NODE_RETURN_VALUE/): This page provides guidance on the error encountered when a LangGraph node returns a non-dict value. It includes an example of incorrect node implementation and the resulting error message. Additionally, troubleshooting tips are offered to ensure that all nodes return the expected dictionary format.
- [Handling Multiple Subgraphs in LangGraph](https://langchain-ai.github.io/langgraph/troubleshooting/errors/MULTIPLE_SUBGRAPHS/): This page discusses the limitations of calling multiple subgraphs within a single LangGraph node when checkpointing is enabled. It provides troubleshooting tips to resolve related errors, including suggestions for compiling subgraphs without checkpointing and using the Send API for graph calls.
- [Handling INVALID_CHAT_HISTORY Error in create_react_agent](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_CHAT_HISTORY/): This page provides an overview of the INVALID_CHAT_HISTORY error encountered in the create_react_agent function when a malformed list of messages is passed. It outlines the potential causes of the error and offers troubleshooting steps to resolve it. Users can learn how to properly invoke the graph and manage tool calls to avoid this issue.
- [Handling INVALID_LICENSE Error in LangGraph Platform](https://langchain-ai.github.io/langgraph/troubleshooting/errors/INVALID_LICENSE/): This page provides guidance on troubleshooting the INVALID_LICENSE error encountered when starting a self-hosted LangGraph Platform server. It outlines the scenarios in which this error may occur and offers solutions based on different deployment types. Additionally, it includes steps to verify the necessary credentials for successful deployment.
- [LangGraph Studio Troubleshooting Guide](https://langchain-ai.github.io/langgraph/troubleshooting/studio/): This page provides troubleshooting solutions for common connection issues encountered in LangGraph Studio, particularly with Safari and Brave browsers. It also addresses potential graph edge issues and offers methods to define routing paths for conditional edges. Users can find step-by-step instructions for resolving these issues using Cloudflare Tunnel and browser settings.
- [LangGraph Case Studies](https://langchain-ai.github.io/langgraph/adopters/): This page provides a comprehensive list of companies that have successfully implemented LangGraph, showcasing their unique use cases and the benefits they have achieved. Each entry includes links to detailed case studies or blog posts for further reading. If your company uses LangGraph, you are encouraged to share your success story to contribute to this growing collection.

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/quick_start.md
```md
# Deployment quickstart

This guide shows you how to set up and use LangGraph Platform for a cloud deployment.

## Prerequisites

Before you begin, ensure you have the following:

- A [GitHub account](https://github.com/)
- A [LangSmith account](https://smith.langchain.com/)  free to sign up

## 1. Create a repository on GitHub

To deploy an application to **LangGraph Platform**, your application code must reside in a GitHub repository. Both public and private repositories are supported. For this quickstart, use the [`new-langgraph-project` template](https://github.com/langchain-ai/react-agent) for your application:

1. Go to the [`new-langgraph-project` repository](https://github.com/langchain-ai/new-langgraph-project) or [`new-langgraphjs-project` template](https://github.com/langchain-ai/new-langgraphjs-project).
1. Click the `Fork` button in the top right corner to fork the repository to your GitHub account.
1. Click **Create fork**. 

## 2. Deploy to LangGraph Platform

1. Log in to [LangSmith](https://smith.langchain.com/).
1. In the left sidebar, select **Deployments**.
1. Click the **+ New Deployment** button. A pane will open where you can fill in the required fields.
1. If you are a first time user or adding a private repository that has not been previously connected, click the **Import from GitHub** button and follow the instructions to connect your GitHub account.
1. Select your New LangGraph Project repository.
1. Click **Submit** to deploy.

    This may take about 15 minutes to complete. You can check the status in the **Deployment details** view.

## 3. Test your application in LangGraph Studio

Once your application is deployed:

1. Select the deployment you just created to view more details.
1. Click the **LangGraph Studio** button in the top right corner.

    LangGraph Studio will open to display your graph.

    <figure markdown="1">
    [![image](deployment/img/langgraph_studio.png){: style="max-height:400px"}](deployment/img/langgraph_studio.png)
    <figcaption>
        Sample graph run in LangGraph Studio.
    </figcaption>
    </figure>

## 4. Get the API URL for your deployment

1. In the **Deployment details** view in LangGraph, click the **API URL** to copy it to your clipboard.
1. Click the `URL` to copy it to the clipboard.

## 5. Test the API

You can now test the API:

=== "Python SDK (Async)"

    1. Install the LangGraph Python SDK:

        ```shell
        pip install langgraph-sdk
        ```

    1. Send a message to the assistant (threadless run):

        ```python
        from langgraph_sdk import get_client

        client = get_client(url="your-deployment-url", api_key="your-langsmith-api-key")

        async for chunk in client.runs.stream(
            None,  # Threadless run
            "agent", # Name of assistant. Defined in langgraph.json.
            input={
                "messages": [{
                    "role": "human",
                    "content": "What is LangGraph?",
                }],
            },
            stream_mode="updates",
        ):
            print(f"Receiving new event of type: {chunk.event}...")
            print(chunk.data)
            print("\n\n")
        ```

=== "Python SDK (Sync)"

    1. Install the LangGraph Python SDK:

        ```shell
        pip install langgraph-sdk
        ```

    1. Send a message to the assistant (threadless run):

        ```python
        from langgraph_sdk import get_sync_client

        client = get_sync_client(url="your-deployment-url", api_key="your-langsmith-api-key")

        for chunk in client.runs.stream(
            None,  # Threadless run
            "agent", # Name of assistant. Defined in langgraph.json.
            input={
                "messages": [{
                    "role": "human",
                    "content": "What is LangGraph?",
                }],
            },
            stream_mode="updates",
        ):
            print(f"Receiving new event of type: {chunk.event}...")
            print(chunk.data)
            print("\n\n")
        ```

=== "JavaScript SDK"

    1. Install the LangGraph JS SDK

        ```shell
        npm install @langchain/langgraph-sdk
        ```

    1. Send a message to the assistant (threadless run):

        ```js
        const { Client } = await import("@langchain/langgraph-sdk");

        const client = new Client({ apiUrl: "your-deployment-url", apiKey: "your-langsmith-api-key" });

        const streamResponse = client.runs.stream(
            null, // Threadless run
            "agent", // Assistant ID
            {
                input: {
                    "messages": [
                        { "role": "user", "content": "What is LangGraph?"}
                    ]
                },
                streamMode: "messages",
            }
        );

        for await (const chunk of streamResponse) {
            console.log(`Receiving new event of type: ${chunk.event}...`);
            console.log(JSON.stringify(chunk.data));
            console.log("\n\n");
        }
        ```

=== "Rest API"

    ```bash
    curl -s --request POST \
        --url <DEPLOYMENT_URL>/runs/stream \
        --header 'Content-Type: application/json' \
        --header "X-Api-Key: <LANGSMITH API KEY> \
        --data "{
            \"assistant_id\": \"agent\",
            \"input\": {
                \"messages\": [
                    {
                        \"role\": \"human\",
                        \"content\": \"What is LangGraph?\"
                    }
                ]
            },
            \"stream_mode\": \"updates\"
        }" 
    ```


## Next steps

Congratulations! You have deployed an application using LangGraph Platform.

Here are some other resources to check out:

- [LangGraph Platform overview](../concepts/langgraph_platform.md)
- [Deployment options](../concepts/deployment_options.md)



```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/cli.md
```md
# LangGraph CLI

The LangGraph command line interface includes commands to build and run a LangGraph Platform API server locally in [Docker](https://www.docker.com/). For development and testing, you can use the CLI to deploy a local API server.

## Installation

1.  Ensure that Docker is installed (e.g. `docker --version`).
2.  Install the CLI package:

    === "Python"
        ```bash
        pip install langgraph-cli
        ```

    === "JS"
        ```bash
        npx @langchain/langgraph-cli

        # Install globally, will be available as `langgraphjs`
        npm install -g @langchain/langgraph-cli
        ```

3.  Run the command `langgraph --help` or `npx @langchain/langgraph-cli --help` to confirm that the CLI is working correctly.

[](){#langgraph.json}

## Configuration File {#configuration-file}

The LangGraph CLI requires a JSON configuration file that follows this [schema](https://raw.githubusercontent.com/langchain-ai/langgraph/refs/heads/main/libs/cli/schemas/schema.json). It contains the following properties:

<div class="admonition tip">
    <p class="admonition-title">Note</p>
    <p>
        The LangGraph CLI defaults to using the configuration file <strong>langgraph.json</strong> in the current directory.
    </p>
</div>

=== "Python"

    | Key                                                          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
    | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | <span style="white-space: nowrap;">`dependencies`</span>     | **Required**. Array of dependencies for LangGraph Platform API server. Dependencies can be one of the following: <ul><li>A single period (`"."`), which will look for local Python packages.</li><li>The directory path where `pyproject.toml`, `setup.py` or `requirements.txt` is located.</br></br>For example, if `requirements.txt` is located in the root of the project directory, specify `"./"`. If it's located in a subdirectory called `local_package`, specify `"./local_package"`. Do not specify the string `"requirements.txt"` itself.</li><li>A Python package name.</li></ul> |
    | <span style="white-space: nowrap;">`graphs`</span>           | **Required**. Mapping from graph ID to path where the compiled graph or a function that makes a graph is defined. Example: <ul><li>`./your_package/your_file.py:variable`, where `variable` is an instance of `langgraph.graph.state.CompiledStateGraph`</li><li>`./your_package/your_file.py:make_graph`, where `make_graph` is a function that takes a config dictionary (`langchain_core.runnables.RunnableConfig`) and returns an instance of `langgraph.graph.state.StateGraph` or `langgraph.graph.state.CompiledStateGraph`. See [how to rebuild a graph at runtime](../../cloud/deployment/graph_rebuild.md) for more details.</li></ul>                                    |
    | <span style="white-space: nowrap;">`auth`</span>             | _(Added in v0.0.11)_ Auth configuration containing the path to your authentication handler. Example: `./your_package/auth.py:auth`, where `auth` is an instance of `langgraph_sdk.Auth`. See [authentication guide](../../concepts/auth.md) for details.                                                                                                                                                                                                                                                                                                                        |
    | <span style="white-space: nowrap;">`base_image`</span>       | Optional. Base image to use for the LangGraph API server. Defaults to `langchain/langgraph-api` or `langchain/langgraphjs-api`. Use this to pin your builds to a particular version of the langgraph API, such as `"langchain/langgraph-server:0.2"`. See https://hub.docker.com/r/langchain/langgraph-server/tags for more details. (added in `langgraph-cli==0.2.8`) |
    | <span style="white-space: nowrap;">`image_distro`</span>     | Optional. Linux distribution for the base image. Must be either `"debian"` or `"wolfi"`. If omitted, defaults to `"debian"`. Available in `langgraph-cli>=0.2.11`.|
    | <span style="white-space: nowrap;">`env`</span>              | Path to `.env` file or a mapping from environment variable to its value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
    | <span style="white-space: nowrap;">`store`</span>            | Configuration for adding semantic search and/or time-to-live (TTL) to the BaseStore. Contains the following fields: <ul><li>`index` (optional): Configuration for semantic search indexing with fields `embed`, `dims`, and optional `fields`.</li><li>`ttl` (optional): Configuration for item expiration. An object with optional fields: `refresh_on_read` (boolean, defaults to `true`), `default_ttl` (float, lifespan in **minutes**, defaults to no expiration), and `sweep_interval_minutes` (integer, how often to check for expired items, defaults to no sweeping).</li></ul> |
    | <span style="white-space: nowrap;">`ui`</span>               | Optional. Named definitions of UI components emitted by the agent, each pointing to a JS/TS file. (added in `langgraph-cli==0.1.84`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
    | <span style="white-space: nowrap;">`python_version`</span>   | `3.11`, `3.12`, or `3.13`. Defaults to `3.11`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
    | <span style="white-space: nowrap;">`node_version`</span>     | Specify `node_version: 20` to use LangGraph.js.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
    | <span style="white-space: nowrap;">`pip_config_file`</span>  | Path to `pip` config file.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
    | <span style="white-space: nowrap;">`pip_installer`</span> | _(Added in v0.3)_ Optional. Python package installer selector. It can be set to `"auto"`, `"pip"`, or `"uv"`. From version&nbsp;0.3 onward the default strategy is to run `uv pip`, which typically delivers faster builds while remaining a drop-in replacement. In the uncommon situation where `uv` cannot handle your dependency graph or the structure of your `pyproject.toml`, specify `"pip"` here to revert to the earlier behaviour. |
    | <span style="white-space: nowrap;">`keep_pkg_tools`</span> | _(Added in v0.3.4)_ Optional. Control whether to retain Python packaging tools (`pip`, `setuptools`, `wheel`) in the final image. Accepted values: <ul><li><code>true</code> : Keep all three tools (skip uninstall).</li><li><code>false</code> / omitted : Uninstall all three tools (default behaviour).</li><li><code>list[str]</code> : Names of tools <strong>to retain</strong>. Each value must be one of "pip", "setuptools", "wheel".</li></ul>. By default, all three tools are uninstalled. |
    | <span style="white-space: nowrap;">`dockerfile_lines`</span> | Array of additional lines to add to Dockerfile following the import from parent image.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
    | <span style="white-space: nowrap;">`checkpointer`</span>   | Configuration for the checkpointer. Contains a `ttl` field which is an object with the following keys: <ul><li>`strategy`: How to handle expired checkpoints (e.g., `"delete"`).</li><li>`sweep_interval_minutes`: How often to check for expired checkpoints (integer).</li><li>`default_ttl`: Default time-to-live for checkpoints in **minutes** (integer). Defines how long checkpoints are kept before the specified strategy is applied.</li></ul> |
    | <span style="white-space: nowrap;">`http`</span>            | HTTP server configuration with the following fields: <ul><li>`app`: Path to custom Starlette/FastAPI app (e.g., `"./src/agent/webapp.py:app"`). See [custom routes guide](../../how-tos/http/custom_routes.md).</li><li>`cors`: CORS configuration with fields for `allow_origins`, `allow_methods`, `allow_headers`, etc.</li><li>`configurable_headers`: Define which request headers to exclude or include as a run's configurable values.</li><li>`disable_assistants`: Disable `/assistants` routes</li><li>`disable_mcp`: Disable `/mcp` routes</li><li>`disable_meta`: Disable `/ok`, `/info`, `/metrics`, and `/docs` routes</li><li>`disable_runs`: Disable `/runs` routes</li><li>`disable_store`: Disable `/store` routes</li><li>`disable_threads`: Disable `/threads` routes</li><li>`disable_ui`: Disable `/ui` routes</li><li>`disable_webhooks`: Disable webhooks calls on run completion in all routes</li><li>`mount_prefix`: Prefix for mounted routes (e.g., "/my-deployment/api")</li></ul> |

=== "JS"

    | Key                                                          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
    | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | <span style="white-space: nowrap;">`graphs`</span>           | **Required**. Mapping from graph ID to path where the compiled graph or a function that makes a graph is defined. Example: <ul><li>`./src/graph.ts:variable`, where `variable` is an instance of `CompiledStateGraph`</li><li>`./src/graph.ts:makeGraph`, where `makeGraph` is a function that takes a config dictionary (`LangGraphRunnableConfig`) and returns an instance of `StateGraph` or `CompiledStateGraph`. See [how to rebuild a graph at runtime](../../cloud/deployment/graph_rebuild.md) for more details.</li></ul>                                    |
    | <span style="white-space: nowrap;">`env`</span>              | Path to `.env` file or a mapping from environment variable to its value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
    | <span style="white-space: nowrap;">`store`</span>            | Configuration for adding semantic search and/or time-to-live (TTL) to the BaseStore. Contains the following fields: <ul><li>`index` (optional): Configuration for semantic search indexing with fields `embed`, `dims`, and optional `fields`.</li><li>`ttl` (optional): Configuration for item expiration. An object with optional fields: `refresh_on_read` (boolean, defaults to `true`), `default_ttl` (float, lifespan in **minutes**, defaults to no expiration), and `sweep_interval_minutes` (integer, how often to check for expired items, defaults to no sweeping).</li></ul> |
    | <span style="white-space: nowrap;">`node_version`</span>     | Specify `node_version: 20` to use LangGraph.js.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
    | <span style="white-space: nowrap;">`dockerfile_lines`</span> | Array of additional lines to add to Dockerfile following the import from parent image.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
    | <span style="white-space: nowrap;">`checkpointer`</span>   | Configuration for the checkpointer. Contains a `ttl` field which is an object with the following keys: <ul><li>`strategy`: How to handle expired checkpoints (e.g., `"delete"`).</li><li>`sweep_interval_minutes`: How often to check for expired checkpoints (integer).</li><li>`default_ttl`: Default time-to-live for checkpoints in **minutes** (integer). Defines how long checkpoints are kept before the specified strategy is applied.</li></ul> |

### Examples

=== "Python"
    
    #### Basic Configuration

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "chat": "./chat/graph.py:graph"
      }
    }
    ```

    #### Using Wolfi Base Images

    You can specify the Linux distribution for your base image using the `image_distro` field. Valid options are `debian` or `wolfi`. Wolfi is the recommended option as it provides smaller and more secure images. This is available in `langgraph-cli>=0.2.11`.

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "chat": "./chat/graph.py:graph"
      },
      "image_distro": "wolfi"
    }
    ```

    #### Adding semantic search to the store

    All deployments come with a DB-backed BaseStore. Adding an "index" configuration to your `langgraph.json` will enable [semantic search](../deployment/semantic_search.md) within the BaseStore of your deployment.

    The `index.fields` configuration determines which parts of your documents to embed:

    - If omitted or set to `["$"]`, the entire document will be embedded
    - To embed specific fields, use JSON path notation: `["metadata.title", "content.text"]`
    - Documents missing specified fields will still be stored but won't have embeddings for those fields
    - You can still override which fields to embed on a specific item at `put` time using the `index` parameter

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "memory_agent": "./agent/graph.py:graph"
      },
      "store": {
        "index": {
          "embed": "openai:text-embedding-3-small",
          "dims": 1536,
          "fields": ["$"]
        }
      }
    }
    ```

    !!! note "Common model dimensions" 
        - `openai:text-embedding-3-large`: 3072 
        - `openai:text-embedding-3-small`: 1536 
        - `openai:text-embedding-ada-002`: 1536 
        - `cohere:embed-english-v3.0`: 1024 
        - `cohere:embed-english-light-v3.0`: 384 
        - `cohere:embed-multilingual-v3.0`: 1024 
        - `cohere:embed-multilingual-light-v3.0`: 384 

    #### Semantic search with a custom embedding function

    If you want to use semantic search with a custom embedding function, you can pass a path to a custom embedding function:

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "memory_agent": "./agent/graph.py:graph"
      },
      "store": {
        "index": {
          "embed": "./embeddings.py:embed_texts",
          "dims": 768,
          "fields": ["text", "summary"]
        }
      }
    }
    ```

    The `embed` field in store configuration can reference a custom function that takes a list of strings and returns a list of embeddings. Example implementation:

    ```python
    # embeddings.py
    def embed_texts(texts: list[str]) -> list[list[float]]:
        """Custom embedding function for semantic search."""
        # Implementation using your preferred embedding model
        return [[0.1, 0.2, ...] for _ in texts]  # dims-dimensional vectors
    ```

    #### Adding custom authentication

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "chat": "./chat/graph.py:graph"
      },
      "auth": {
        "path": "./auth.py:auth",
        "openapi": {
          "securitySchemes": {
            "apiKeyAuth": {
              "type": "apiKey",
              "in": "header",
              "name": "X-API-Key"
            }
          },
          "security": [{ "apiKeyAuth": [] }]
        },
        "disable_studio_auth": false
      }
    }
    ```

    See the [authentication conceptual guide](../../concepts/auth.md) for details, and the [setting up custom authentication](../../tutorials/auth/getting_started.md) guide for a practical walk through of the process.

    #### Configuring Store Item Time-to-Live (TTL)

    You can configure default data expiration for items/memories in the BaseStore using the `store.ttl` key. This determines how long items are retained after they are last accessed (with reads potentially refreshing the timer based on `refresh_on_read`). Note that these defaults can be overwritten on a per-call basis by modifying the corresponding arguments in `get`, `search`, etc.
    
    The `ttl` configuration is an object containing optional fields:

    - `refresh_on_read`: If `true` (the default), accessing an item via `get` or `search` resets its expiration timer. Set to `false` to only refresh TTL on writes (`put`).
    - `default_ttl`: The default lifespan of an item in **minutes**. If not set, items do not expire by default.
    - `sweep_interval_minutes`: How frequently (in minutes) the system should run a background process to delete expired items. If not set, sweeping does not occur automatically.

    Here is an example enabling a 7-day TTL (10080 minutes), refreshing on reads, and sweeping every hour:

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "memory_agent": "./agent/graph.py:graph"
      },
      "store": {
        "ttl": {
          "refresh_on_read": true,
          "sweep_interval_minutes": 60,
          "default_ttl": 10080 
        }
      }
    }
    ```

    #### Configuring Checkpoint Time-to-Live (TTL)

    You can configure the time-to-live (TTL) for checkpoints using the `checkpointer` key. This determines how long checkpoint data is retained before being automatically handled according to the specified strategy (e.g., deletion). The `ttl` configuration is an object containing:

    - `strategy`: The action to take on expired checkpoints (currently `"delete"` is the only accepted option).
    - `sweep_interval_minutes`: How frequently (in minutes) the system checks for expired checkpoints.
    - `default_ttl`: The default lifespan of a checkpoint in **minutes**.

    Here's an example setting a default TTL of 30 days (43200 minutes):

    ```json
    {
      "dependencies": ["."],
      "graphs": {
        "chat": "./chat/graph.py:graph"
      },
      "checkpointer": {
        "ttl": {
          "strategy": "delete",
          "sweep_interval_minutes": 10,
          "default_ttl": 43200
        }
      }
    }
    ```

    In this example, checkpoints older than 30 days will be deleted, and the check runs every 10 minutes.


=== "JS"
    
    #### Basic Configuration

    ```json
    {
      "graphs": {
        "chat": "./src/graph.ts:graph"
      }
    }
    ```


## Commands

**Usage**

=== "Python"

    The base command for the LangGraph CLI is `langgraph`.

    ```
    langgraph [OPTIONS] COMMAND [ARGS]
    ```
=== "JS"

    The base command for the LangGraph.js CLI is `langgraphjs`. 

    ```
    npx @langchain/langgraph-cli [OPTIONS] COMMAND [ARGS]
    ```

    We recommend using `npx` to always use the latest version of the CLI.

### `dev`

=== "Python"

    Run LangGraph API server in development mode with hot reloading and debugging capabilities. This lightweight server requires no Docker installation and is suitable for development and testing. State is persisted to a local directory.

    !!! note

        Currently, the CLI only supports Python >= 3.11.

    **Installation**

    This command requires the "inmem" extra to be installed:

    ```bash
    pip install -U "langgraph-cli[inmem]"
    ```

    **Usage**

    ```
    langgraph dev [OPTIONS]
    ```

    **Options**

    | Option                        | Default          | Description                                                                         |
    | ----------------------------- | ---------------- | ----------------------------------------------------------------------------------- |
    | `-c, --config FILE`           | `langgraph.json` | Path to configuration file declaring dependencies, graphs and environment variables |
    | `--host TEXT`                 | `127.0.0.1`      | Host to bind the server to                                                          |
    | `--port INTEGER`              | `2024`           | Port to bind the server to                                                          |
    | `--no-reload`                 |                  | Disable auto-reload                                                                 |
    | `--n-jobs-per-worker INTEGER` |                  | Number of jobs per worker. Default is 10                                            |
    | `--debug-port INTEGER`        |                  | Port for debugger to listen on                                                      |
    | `--wait-for-client`           | `False`          | Wait for a debugger client to connect to the debug port before starting the server   |
    | `--no-browser`                |                  | Skip automatically opening the browser when the server starts                       |
    | `--studio-url TEXT`           |                  | URL of the LangGraph Studio instance to connect to. Defaults to https://smith.langchain.com |
    | `--allow-blocking`            | `False`          | Do not raise errors for synchronous I/O blocking operations in your code (added in `0.2.6`)           |
    | `--tunnel`                    | `False`          | Expose the local server via a public tunnel (Cloudflare) for remote frontend access. This avoids issues with browsers like Safari or networks blocking localhost connections        |
    | `--help`                      |                  | Display command documentation                                                       |


=== "JS"

    Run LangGraph API server in development mode with hot reloading capabilities. This lightweight server requires no Docker installation and is suitable for development and testing. State is persisted to a local directory.

    **Usage**

    ```
    npx @langchain/langgraph-cli dev [OPTIONS]
    ```

    **Options**

    | Option                        | Default          | Description                                                                         |
    | ----------------------------- | ---------------- | ----------------------------------------------------------------------------------- |
    | `-c, --config FILE`           | `langgraph.json` | Path to configuration file declaring dependencies, graphs and environment variables |
    | `--host TEXT`                 | `127.0.0.1`      | Host to bind the server to                                                          |
    | `--port INTEGER`              | `2024`           | Port to bind the server to                                                          |
    | `--no-reload`                 |                  | Disable auto-reload                                                                 |
    | `--n-jobs-per-worker INTEGER` |                  | Number of jobs per worker. Default is 10                                            |
    | `--debug-port INTEGER`        |                  | Port for debugger to listen on                                                      |
    | `--wait-for-client`           | `False`          | Wait for a debugger client to connect to the debug port before starting the server   |
    | `--no-browser`                |                  | Skip automatically opening the browser when the server starts                       |
    | `--studio-url TEXT`           |                  | URL of the LangGraph Studio instance to connect to. Defaults to https://smith.langchain.com |
    | `--allow-blocking`            | `False`          | Do not raise errors for synchronous I/O blocking operations in your code            |
    | `--tunnel`                    | `False`          | Expose the local server via a public tunnel (Cloudflare) for remote frontend access. This avoids issues with browsers or networks blocking localhost connections        |
    | `--help`                      |                  | Display command documentation                                                       |

### `build`

=== "Python"

    Build LangGraph Platform API server Docker image.

    **Usage**

    ```
    langgraph build [OPTIONS]
    ```

    **Options**

    | Option               | Default          | Description                                                                                                     |
    | -------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
    | `--platform TEXT`    |                  | Target platform(s) to build the Docker image for. Example: `langgraph build --platform linux/amd64,linux/arm64`              |
    | `-t, --tag TEXT`     |                  | **Required**. Tag for the Docker image. Example: `langgraph build -t my-image`                                               |
    | `--pull / --no-pull` | `--pull`         | Build with latest remote Docker image. Use `--no-pull` for running the LangGraph Platform API server with locally built images. |
    | `-c, --config FILE`  | `langgraph.json` | Path to configuration file declaring dependencies, graphs and environment variables.                                         |
    | `--help`             |                  | Display command documentation.                                                                                               |

=== "JS"

    Build LangGraph Platform API server Docker image.

    **Usage**

    ```
    npx @langchain/langgraph-cli build [OPTIONS]
    ```

    **Options**

    | Option               | Default          | Description                                                                                                     |
    | -------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
    | `--platform TEXT`    |                  | Target platform(s) to build the Docker image for. Example: `langgraph build --platform linux/amd64,linux/arm64`              |
    | `-t, --tag TEXT`     |                  | **Required**. Tag for the Docker image. Example: `langgraph build -t my-image`                                               |
    | `--no-pull`          |                  | Use locally built images. Defaults to `false` to build with latest remote Docker image.                                      |
    | `-c, --config FILE`  | `langgraph.json` | Path to configuration file declaring dependencies, graphs and environment variables.                                         |
    | `--help`             |                  | Display command documentation.                                                                                               |


### `up`

=== "Python"

    Start LangGraph API server. For local testing, requires a LangSmith API key with access to LangGraph Platform. Requires a license key for production use.

    **Usage**

    ```
    langgraph up [OPTIONS]
    ```

    **Options**

    | Option                       | Default                   | Description                                                                                                             |
    | ---------------------------- | ------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
    | `--wait`                     |                           | Wait for services to start before returning. Implies --detach                                                           |
    | `--base-image TEXT`          | `langchain/langgraph-api`  | Base image to use for the LangGraph API server. Pin to specific versions using version tags.                            |
    | `--image TEXT`               |                           | Docker image to use for the langgraph-api service. If specified, skips building and uses this image directly.           |
    | `--postgres-uri TEXT`        | Local database            | Postgres URI to use for the database.                                                                                   |
    | `--watch`                    |                           | Restart on file changes                                                                                                 |
    | `--debugger-base-url TEXT`   | `http://127.0.0.1:[PORT]` | URL used by the debugger to access LangGraph API.                                                                       |
    | `--debugger-port INTEGER`    |                           | Pull the debugger image locally and serve the UI on specified port                                                      |
    | `--verbose`                  |                           | Show more output from the server logs.                                                                                  |
    | `-c, --config FILE`          | `langgraph.json`          | Path to configuration file declaring dependencies, graphs and environment variables.                                    |
    | `-d, --docker-compose FILE`  |                           | Path to docker-compose.yml file with additional services to launch.                                                     |
    | `-p, --port INTEGER`         | `8123`                    | Port to expose. Example: `langgraph up --port 8000`                                                                     |
    | `--pull / --no-pull`         | `pull`                    | Pull latest images. Use `--no-pull` for running the server with locally-built images. Example: `langgraph up --no-pull` |
    | `--recreate / --no-recreate` | `no-recreate`             | Recreate containers even if their configuration and image haven't changed                                               |
    | `--help`                     |                           | Display command documentation.                                                                                          |

=== "JS"

    Start LangGraph API server. For local testing, requires a LangSmith API key with access to LangGraph Platform. Requires a license key for production use.

    **Usage**

    ```
    npx @langchain/langgraph-cli up [OPTIONS]
    ```

    **Options**

    | Option                                                                 | Default                   | Description                                                                                                             |
    | ---------------------------------------------------------------------- | ------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
    | <span style="white-space: nowrap;">`--wait`</span>                     |                           | Wait for services to start before returning. Implies --detach                                                           |
    | <span style="white-space: nowrap;">`--base-image TEXT`</span>          | <span style="white-space: nowrap;">`langchain/langgraph-api`</span> | Base image to use for the LangGraph API server. Pin to specific versions using version tags. |
    | <span style="white-space: nowrap;">`--image TEXT`</span>               |                           | Docker image to use for the langgraph-api service. If specified, skips building and uses this image directly. |
    | <span style="white-space: nowrap;">`--postgres-uri TEXT`</span>        | Local database            | Postgres URI to use for the database.                                                                                   |
    | <span style="white-space: nowrap;">`--watch`</span>                    |                           | Restart on file changes                                                                                                 |
    | <span style="white-space: nowrap;">`-c, --config FILE`</span>          | `langgraph.json`          | Path to configuration file declaring dependencies, graphs and environment variables.                                    |
    | <span style="white-space: nowrap;">`-d, --docker-compose FILE`</span>  |                           | Path to docker-compose.yml file with additional services to launch.                                                     |
    | <span style="white-space: nowrap;">`-p, --port INTEGER`</span>         | `8123`                    | Port to expose. Example: `langgraph up --port 8000`                                                                     |
    | <span style="white-space: nowrap;">`--no-pull`</span>                  |                           | Use locally built images. Defaults to `false` to build with latest remote Docker image.                                 |
    | <span style="white-space: nowrap;">`--recreate`</span>                 |                           | Recreate containers even if their configuration and image haven't changed                                               |
    | <span style="white-space: nowrap;">`--help`</span>                     |                           | Display command documentation.                                                                                          |

### `dockerfile`

=== "Python"

    Generate a Dockerfile for building a LangGraph Platform API server Docker image.

    **Usage**

    ```
    langgraph dockerfile [OPTIONS] SAVE_PATH
    ```

    **Options**

    | Option              | Default          | Description                                                                                                     |
    | ------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
    | `-c, --config FILE` | `langgraph.json` | Path to the [configuration file](#configuration-file) declaring dependencies, graphs and environment variables. |
    | `--help`            |                  | Show this message and exit.                                                                                     |

    Example:

    ```bash
    langgraph dockerfile -c langgraph.json Dockerfile
    ```

    This generates a Dockerfile that looks similar to:

    ```dockerfile
    FROM langchain/langgraph-api:3.11

    ADD ./pipconf.txt /pipconfig.txt

    RUN PIP_CONFIG_FILE=/pipconfig.txt PYTHONDONTWRITEBYTECODE=1 pip install --no-cache-dir -c /api/constraints.txt langchain_community langchain_anthropic langchain_openai wikipedia scikit-learn

    ADD ./graphs /deps/outer-graphs/src
    RUN set -ex && \
        for line in '[project]' \
                    'name = "graphs"' \
                    'version = "0.1"' \
                    '[tool.setuptools.package-data]' \
                    '"*" = ["**/*"]'; do \
            echo "$line" >> /deps/outer-graphs/pyproject.toml; \
        done

    RUN PIP_CONFIG_FILE=/pipconfig.txt PYTHONDONTWRITEBYTECODE=1 pip install --no-cache-dir -c /api/constraints.txt -e /deps/*

    ENV LANGSERVE_GRAPHS='{"agent": "/deps/outer-graphs/src/agent.py:graph", "storm": "/deps/outer-graphs/src/storm.py:graph"}'
    ```

    ???+ note "Updating your langgraph.json file"
         The `langgraph dockerfile` command translates all the configuration in your `langgraph.json` file into Dockerfile commands. When using this command, you will have to re-run it whenever you update your `langgraph.json` file. Otherwise, your changes will not be reflected when you build or run the dockerfile.

=== "JS"

    Generate a Dockerfile for building a LangGraph Platform API server Docker image.

    **Usage**

    ```
    npx @langchain/langgraph-cli dockerfile [OPTIONS] SAVE_PATH
    ```

    **Options**

    | Option              | Default          | Description                                                                                                     |
    | ------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------- |
    | `-c, --config FILE` | `langgraph.json` | Path to the [configuration file](#configuration-file) declaring dependencies, graphs and environment variables. |
    | `--help`            |                  | Show this message and exit.                                                                                     |

    Example:

    ```bash
    npx @langchain/langgraph-cli dockerfile -c langgraph.json Dockerfile
    ```

    This generates a Dockerfile that looks similar to:

    ```dockerfile
    FROM langchain/langgraphjs-api:20
    
    ADD . /deps/agent
    
    RUN cd /deps/agent && yarn install
    
    ENV LANGSERVE_GRAPHS='{"agent":"./src/react_agent/graph.ts:graph"}'
    
    WORKDIR /deps/agent
    
    RUN (test ! -f /api/langgraph_api/js/build.mts && echo "Prebuild script not found, skipping") || tsx /api/langgraph_api/js/build.mts
    ```

    ???+ note "Updating your langgraph.json file"
         The `npx @langchain/langgraph-cli dockerfile` command translates all the configuration in your `langgraph.json` file into Dockerfile commands. When using this command, you will have to re-run it whenever you update your `langgraph.json` file. Otherwise, your changes will not be reflected when you build or run the dockerfile.

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/env_var.md
```md
# Environment Variables

The LangGraph Server supports specific environment variables for configuring a deployment.

## `BG_JOB_ISOLATED_LOOPS`

Set `BG_JOB_ISOLATED_LOOPS` to `True` to execute background runs in an isolated event loop separate from the serving API event loop.

This environment variable should be set to `True` if the implementation of a graph/node contains synchronous code. In this situation, the synchronous code will block the serving API event loop, which may cause the API to be unavailable. A symptom of an unavailable API is continuous application restarts due to failing health checks.

Defaults to `False`.

## `BG_JOB_SHUTDOWN_GRACE_PERIOD_SECS`

Specifies, in seconds, how long the server will wait for background jobs to finish after the queue receives a shutdown signal. After this period, the server will force termination. Defaults to `180` seconds. Set this to ensure jobs have enough time to complete cleanly during shutdown. Added in `langgraph-api==0.2.16`.

## `BG_JOB_TIMEOUT_SECS`

The timeout of a background run can be increased. However, the infrastructure for a Cloud SaaS deployment enforces a 1 hour timeout limit for API requests. This means the connection between client and server will timeout after 1 hour. This is not configurable.

A background run can execute for longer than 1 hour, but a client must reconnect to the server (e.g. join stream via `POST /threads/{thread_id}/runs/{run_id}/stream`) to retrieve output from the run if the run is taking longer than 1 hour.

Defaults to `3600`.

## `DD_API_KEY`

Specify `DD_API_KEY` (your [Datadog API Key](https://docs.datadoghq.com/account_management/api-app-keys/)) to automatically enable Datadog tracing for the deployment. Specify other [`DD_*` environment variables](https://ddtrace.readthedocs.io/en/stable/configuration.html) to configure the tracing instrumentation.

If `DD_API_KEY` is specified, the application process is wrapped in the [`ddtrace-run` command](https://ddtrace.readthedocs.io/en/stable/installation_quickstart.html). Other `DD_*` environment variables (e.g. `DD_SITE`, `DD_ENV`, `DD_SERVICE`, `DD_TRACE_ENABLED`) are typically needed to properly configure the tracing instrumentation. See [`DD_*` environment variables](https://ddtrace.readthedocs.io/en/stable/configuration.html) for more details.

!!! note 
    Enabling `DD_API_KEY` (and thus `ddtrace-run`) can override or interfere with other auto-instrumentation solutions (such as OpenTelemetry) that you may have instrumented into your application code.

## `LANGCHAIN_TRACING_SAMPLING_RATE`

Sampling rate for traces sent to LangSmith. Valid values: Any float between `0` and `1`.

See <a href="https://docs.smith.langchain.com/how_to_guides/tracing/sample_traces" target="_blank">LangSmith documentation</a> for more details.

## `LANGGRAPH_AUTH_TYPE`

Type of authentication for the LangGraph Server deployment. Valid values: `langsmith`, `noop`.

For deployments to LangGraph Platform, this environment variable is set automatically. For local development or deployments where authentication is handled externally (e.g. self-hosted), set this environment variable to `noop`.

## `LANGGRAPH_POSTGRES_POOL_MAX_SIZE`

Beginning with langgraph-api version `0.2.12`, the maximum size of the Postgres connection pool (per replica) can be controlled using the `LANGGRAPH_POSTGRES_POOL_MAX_SIZE` environment variable. By setting this variable, you can determine the upper bound on the number of simultaneous connections the server will establish with the Postgres database.

For example, if a deployment is scaled up to 10 replicas and `LANGGRAPH_POSTGRES_POOL_MAX_SIZE` is configured to `150`, then up to `1500` connections to Postgres can be established. This is particularly useful for deployments where database resources are limited (or more available) or where you need to tune connection behavior for performance or scaling reasons.

Defaults to `150` connections.

## `LANGSMITH_RUNS_ENDPOINTS`

For deployments with [self-hosted LangSmith](https://docs.smith.langchain.com/self_hosting) only.

Set this environment variable to have a deployment send traces to a self-hosted LangSmith instance. The value of `LANGSMITH_RUNS_ENDPOINTS` is a JSON string: `{"<SELF_HOSTED_LANGSMITH_HOSTNAME>":"<LANGSMITH_API_KEY>"}`.

`SELF_HOSTED_LANGSMITH_HOSTNAME` is the hostname of the self-hosted LangSmith instance. It must be accessible to the deployment. `LANGSMITH_API_KEY` is a LangSmith API generated from the self-hosted LangSmith instance.

## `LANGSMITH_TRACING`

Set `LANGSMITH_TRACING` to `false` to disable tracing to LangSmith.

Defaults to `true`.

## `LOG_COLOR`

This is mainly relevant in the context of using the dev server via the `langgraph dev` command. Set `LOG_COLOR` to `true` to enable ANSI-colored console output when using the default console renderer. Disabling color output by setting this variable to `false` produces monochrome logs. Defaults to `true`.

## `LOG_LEVEL`

Configure [log level](https://docs.python.org/3/library/logging.html#logging-levels). Defaults to `INFO`.

## `LOG_JSON`

Set `LOG_JSON` to `true` to render all log messages as JSON objects using the configured `JSONRenderer`. This produces structured logs that can be easily parsed or ingested by log management systems. Defaults to `false`.

## `MOUNT_PREFIX`

!!! info "Only Allowed in Self-Hosted Deployments"
    The `MOUNT_PREFIX` environment variable is only allowed in Self-Hosted Deployment models, LangGraph Platform SaaS will not allow this environment variable.

Set `MOUNT_PREFIX` to serve the LangGraph Server under a specific path prefix. This is useful for deployments where the server is behind a reverse proxy or load balancer that requires a specific path prefix.

For example, if the server is to be served under `https://example.com/langgraph`, set `MOUNT_PREFIX` to `/langgraph`.

## `N_JOBS_PER_WORKER`

Number of jobs per worker for the LangGraph Server task queue. Defaults to `10`.

## `POSTGRES_URI_CUSTOM`

!!! info "Only for Self-Hosted Data Plane and Self-Hosted Control Plane"
    Custom Postgres instances are only available for [Self-Hosted Data Plane](../../concepts/langgraph_self_hosted_data_plane.md) and [Self-Hosted Control Plane](../../concepts/langgraph_self_hosted_control_plane.md) deployments.

Specify `POSTGRES_URI_CUSTOM` to use a custom Postgres instance. The value of `POSTGRES_URI_CUSTOM` must be a valid [Postgres connection URI](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING-URIS).

Postgres:

- Version 15.8 or higher.
- An initial database must be present and the connection URI must reference the database.

Control Plane Functionality:

- If `POSTGRES_URI_CUSTOM` is specified, the LangGraph Control Plane will not provision a database for the server.
- If `POSTGRES_URI_CUSTOM` is removed, the LangGraph Control Plane will not provision a database for the server and will not delete the externally managed Postgres instance.
- If `POSTGRES_URI_CUSTOM` is removed, deployment of the revision will not succeed. Once `POSTGRES_URI_CUSTOM` is specified, it must always be set for the lifecycle of the deployment.
- If the deployment is deleted, the LangGraph Control Plane will not delete the externally managed Postgres instance.
- The value of `POSTGRES_URI_CUSTOM` can be updated. For example, a password in the URI can be updated.

Database Connectivity:

- The custom Postgres instance must be accessible by the LangGraph Server. The user is responsible for ensuring connectivity.

## `REDIS_CLUSTER`

!!! info "Only Allowed in Self-Hosted Deployments"
    Redis Cluster mode is only available in Self-Hosted Deployment models, LangGraph Platform SaaS will provision a redis instance for you by default.

Set `REDIS_CLUSTER` to `True` to enable Redis Cluster mode. When enabled, the system will connect to Redis using cluster mode. This is useful when connecting to a Redis Cluster deployment.

Defaults to `False`.

## `REDIS_KEY_PREFIX`

!!! info "Available in API Server version 0.1.9+"
    This environment variable is supported in API Server version 0.1.9 and above.

Specify a prefix for Redis keys. This allows multiple LangGraph Server instances to share the same Redis instance by using different key prefixes. 

Defaults to `''`.

## `REDIS_URI_CUSTOM`

!!! info "Only for Self-Hosted Data Plane and Self-Hosted Control Plane"
    Custom Redis instances are only available for [Self-Hosted Data Plane](../../concepts/langgraph_self_hosted_data_plane.md) and [Self-Hosted Control Plane](../../concepts/langgraph_self_hosted_control_plane.md) deployments.

Specify `REDIS_URI_CUSTOM` to use a custom Redis instance. The value of `REDIS_URI_CUSTOM` must be a valid [Redis connection URI](https://redis-py.readthedocs.io/en/stable/connections.html#redis.Redis.from_url).

## `RESUMABLE_STREAM_TTL_SECONDS`

Time-to-live in seconds for resumable stream data in Redis.

When a run is created and the output is streamed, the stream can be configured to be resumable (e.g. `stream_resumable=True`). If a stream is resumable, output from the stream is temporarily stored in Redis. The TTL for this data can be configured by setting `RESUMABLE_STREAM_TTL_SECONDS`.

See the [Python](https://langchain-ai.github.io/langgraph/cloud/reference/sdk/python_sdk_ref/#langgraph_sdk.client.RunsClient.stream) and [JS/TS](https://langchain-ai.github.io/langgraphjs/reference/classes/sdk_client.RunsClient.html#stream) SDKs for more details on how to implement resumable streams.

Defaults to `120` seconds.

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/langgraph_server_changelog.md
```md
# LangGraph Server Changelog

> **Note:** This changelog is no longer actively maintained. For the most up-to-date LangGraph Server changelog, please visit our new documentation site: [LangGraph Server Changelog](https://docs.langchain.com/langgraph-platform/langgraph-server-changelog#langgraph-server-changelog)

[LangGraph Server](../../concepts/langgraph_server.md) is an API platform for creating and managing agent-based applications. It provides built-in persistence, a task queue, and supports deploying, configuring, and running assistants (agentic workflows) at scale. This changelog documents all notable updates, features, and fixes to LangGraph Server releases.

---

## v0.2.111 (2025-07-29)
- Started the heartbeat immediately upon connection to prevent JS graph streaming errors during long startups.

## v0.2.110 (2025-07-29)
- Added interrupts as default values for all operations except streams to maintain consistent behavior.

## v0.2.109 (2025-07-28)
- Fixed an issue where missing config schema occurred when `config_type` was not set.

## v0.2.108 (2025-07-28)
- Added compatibility for langgraph v0.6, including new context API support and a migration to enhance context handling in assistant operations.

## v0.2.107 (2025-07-27)
- Implemented caching for authentication processes to improve performance.
- Merged count and select queries to improve database query efficiency.

## v0.2.106 (2025-07-27)
- Log whether run uses resumable streams.

## v0.2.105 (2025-07-27)
- Added a `/heapdump` endpoint to capture and save JS process heap data.

## v0.2.103 (2025-07-25)
- Corrected the metadata endpoint to ensure accurate data retrieval.

## v0.2.102 (2025-07-24)
- Captured interrupt events in the wait method to preserve legacy behavior and stream updates by default.
- Added support for SDK structlog in the JavaScript environment, enhancing logging capabilities.

## v0.2.101 (2025-07-24)
- Used the correct metadata endpoint for self-hosted environments, resolving an access issue.

## v0.2.99 (2025-07-22)
- Improved license validation by adding an in-memory cache and handling Redis connection errors more effectively.
- Automatically remove agents from memory that are removed from `langgraph.json` to prevent persistence issues.
- Ensured the UI namespace for generated UI is a valid JavaScript property name to prevent errors.
- Raised a 422 error for improved request validation feedback.

## v0.2.98 (2025-07-19)
- Added langgraph node context for improved log filtering and trace visibility.

## v0.2.97 (2025-07-19)
- Fixed scheduling issue with ckpt ingestion worker that occurred on isolated background loops.
- Ensured queue worker starts only after all migrations have completed.
- Added more detailed error messages for thread state issues and improved response handling when state updates fail.
- Exposed interrupt ID while retrieving thread state for enhanced API response details.

## v0.2.96 (2025-07-17)
- Added a fallback mechanism for configurable header patterns to handle exclude/include settings more effectively.

## v0.2.95 (2025-07-17)
- Avoided setting the future if it is already done to prevent redundant operations.
- Resolved compatibility errors in CI by switching from `typing.TypedDict` to `typing_extensions.TypedDict` for Python versions below 3.12.

## v0.2.94 (2025-07-16)
- Improved performance by omitting pending sends for langgraph versions 0.5 and above.
- Improved server startup logs to provide clearer warnings when the DD_API_KEY environment variable is set.

## v0.2.93 (2025-07-16)
- Removed the GIN index for run metadata to improve performance.

## v0.2.92 (2025-07-16)
- Enabled copying functionality for blobs and checkpoints, improving data management flexibility.

## v0.2.91 (2025-07-16)
- Reduced writes to the `checkpoint_blobs` table by inlining small values (null, numeric, str, etc.). This means we don't need to store extra values for channels that haven't been updated.

## v0.2.90 (2025-07-16)
- Improve checkpoint writes via node-local background queueing.


## v0.2.89 (2025-07-15)
- Decoupled checkpoint writing from thread/run state by removing foreign keys and updated logger to prevent timeout-related failures.

## v0.2.88 (2025-07-14)
- Removed the foreign key constraint for `thread` in the `run` table to simplify database schema.

## v0.2.87 (2025-07-14)
- Added more detailed logs for Redis worker signaling to improve debugging.

## v0.2.86 (2025-07-11)
- Honored tool descriptions in the `/mcp` endpoint to align with expected functionality.

## v0.2.85 (2025-07-10)
- Added support for the `on_disconnect` field to `runs/wait` and included disconnect logs for better debugging.

## v0.2.84 (2025-07-09)
- Removed unnecessary status updates to streamline thread handling and updated version to 0.2.84.

## v0.2.83 (2025-07-09)
- Reduced the default time-to-live for resumable streams to 2 minutes.
- Enhanced data submission logic to send data to both Beacon and LangSmith instance based on license configuration.
- Enabled submission of self-hosted data to a Langsmith instance when the endpoint is configured.

## v0.2.82 (2025-07-03)
- Addressed a race condition in background runs by implementing a lock using join, ensuring reliable execution across CTEs.

## v0.2.81 (2025-07-03)
- Optimized run streams by reducing initial wait time to improve responsiveness for older or non-existent runs.

## v0.2.80 (2025-07-03)
- Corrected parameter passing in the `logger.ainfo()` API call to resolve a TypeError.

## v0.2.79 (2025-07-02)
- Fixed a JsonDecodeError in checkpointing with remote graph by correcting JSON serialization to handle trailing slashes properly.
- Introduced a configuration flag to disable webhooks globally across all routes.

## v0.2.78 (2025-07-02)
- Added timeout retries to webhook calls to improve reliability.
- Added HTTP request metrics, including a request count and latency histogram, for enhanced monitoring capabilities.

## v0.2.77 (2025-07-02)
- Added HTTP metrics to improve performance monitoring.
- Changed the Redis cache delimiter to reduce conflicts with subgraph message names and updated caching behavior.

## v0.2.76 (2025-07-01)
- Updated Redis cache delimiter to prevent conflicts with subgraph messages.

## v0.2.74 (2025-06-30)
- Scheduled webhooks in an isolated loop to ensure thread-safe operations and prevent errors with PYTHONASYNCIODEBUG=1.

## v0.2.73 (2025-06-27)
- Fixed an infinite frame loop issue and removed the dict_parser due to structlog's unexpected behavior.
- Throw a 409 error on deadlock occurrence during run cancellations to handle lock conflicts gracefully.

## v0.2.72 (2025-06-27)
- Ensured compatibility with future langgraph versions.
- Implemented a 409 response status to handle deadlock issues during cancellation.

## v0.2.71 (2025-06-26)
- Improved logging for better clarity and detail regarding log types.

## v0.2.70 (2025-06-26)
- Improved error handling to better distinguish and log TimeoutErrors caused by users from internal run timeouts.

## v0.2.69 (2025-06-26)
- Added sorting and pagination to the crons API and updated schema definitions for improved accuracy.

## v0.2.66 (2025-06-26)
- Fixed a 404 error when creating multiple runs with the same thread_id using `on_not_exist="create"`.

## v0.2.65 (2025-06-25)
- Ensured that only fields from `assistant_versions` are returned when necessary.
- Ensured consistent data types for in-memory and PostgreSQL users, improving internal authentication handling.

## v0.2.64 (2025-06-24)
- Added descriptions to version entries for better clarity.

## v0.2.62 (2025-06-23)
- Improved user handling for custom authentication in the JS Studio.
- Added Prometheus-format run statistics to the metrics endpoint for better monitoring.
- Added run statistics in Prometheus format to the metrics endpoint.

## v0.2.61 (2025-06-20)
- Set a maximum idle time for Redis connections to prevent unnecessary open connections.

## v0.2.60 (2025-06-20)
- Enhanced error logging to include traceback details for dictionary operations.
- Added a `/metrics` endpoint to expose queue worker metrics for monitoring.

## v0.2.57 (2025-06-18)
- Removed CancelledError from retriable exceptions to allow local interrupts while maintaining retriability for workers.
- Introduced middleware to gracefully shut down the server after completing in-flight requests upon receiving a SIGINT.
- Reduced metadata stored in checkpoint to only include necessary information.
- Improved error handling in join runs to return error details when present.

## v0.2.56 (2025-06-17)
- Improved application stability by adding a handler for SIGTERM signals.

## v0.2.55 (2025-06-17)
- Improved the handling of cancellations in the queue entrypoint.
- Improved cancellation handling in the queue entry point.

## v0.2.54 (2025-06-16)
- Enhanced error message for LuaLock timeout during license validation.
- Fixed the $contains filter in custom auth by requiring an explicit ::text cast and updated tests accordingly.
- Ensured project and tenant IDs are formatted as UUIDs for consistency.

## v0.2.53 (2025-06-13)
- Resolved a timing issue to ensure the queue starts only after the graph is registered.
- Improved performance by setting thread and run status in a single query and enhanced error handling during checkpoint writes.
- Reduced the default background grace period to 3 minutes.

## v0.2.52 (2025-06-12)
- Now logging expected graphs when one is omitted to improve traceability.
- Implemented a time-to-live (TTL) feature for resumable streams.
- Improved query efficiency and consistency by adding a unique index and optimizing row locking.

## v0.2.51 (2025-06-12)
- Handled `CancelledError` by marking tasks as ready to retry, improving error management in worker processes.
- Added LG API version and request ID to metadata and logs for better tracking.
- Added LG API version and request ID to metadata and logs to improve traceability.
- Improved database performance by creating indexes concurrently.
- Ensured postgres write is committed only after the Redis running marker is set to prevent race conditions.
- Enhanced query efficiency and reliability by adding a unique index on thread_id/running, optimizing row locks, and ensuring deterministic run selection.
- Resolved a race condition by ensuring Postgres updates only occur after the Redis running marker is set.

## v0.2.46 (2025-06-07)
- Introduced a new connection for each operation while preserving transaction characteristics in Threads state `update()` and `bulk()` commands.

## v0.2.45 (2025-06-05)
- Enhanced streaming feature by incorporating tracing contexts.
- Removed an unnecessary query from the Crons.search function.
- Resolved connection reuse issue when scheduling next run for multiple cron jobs.
- Removed an unnecessary query in the Crons.search function to improve efficiency.
- Resolved an issue with scheduling the next cron run by improving connection reuse.

## v0.2.44 (2025-06-04)
- Enhanced the worker logic to exit the pipeline before continuing when the Redis message limit is reached.
- Introduced a ceiling for Redis message size with an option to skip messages larger than 128 MB for improved performance.
- Ensured the pipeline always closes properly to prevent resource leaks.

## v0.2.43 (2025-06-04)
- Improved performance by omitting logs in metadata calls and ensuring output schema compliance in value streaming.
- Ensured the connection is properly closed after use.
- Aligned output format to strictly adhere to the specified schema.
- Stopped sending internal logs in metadata requests to improve privacy.

## v0.2.42 (2025-06-04)
- Added timestamps to track the start and end of a request's run.
- Added tracer information to the configuration settings.
- Added support for streaming with tracing contexts.

## v0.2.41 (2025-06-03)
- Added locking mechanism to prevent errors in pipelined executions.

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/api_ref.html
```html
<!doctype html>
<html>
  <head>
    <title>LangGraph Platform API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script id="api-reference" data-url="./openapi.json"></script>
    <script>
      var configuration = {}
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
  </body>
</html>
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/api_ref.md
```md
# LangGraph Server API Reference

The LangGraph Server API reference is available within each deployment at the `/docs` endpoint (e.g. `http://localhost:8124/docs`).

Click <a href="/langgraph/cloud/reference/api/api_ref.html" target="_blank">here</a> to view the API reference.

## Authentication

For deployments to LangGraph Platform, authentication is required. Pass the `X-Api-Key` header with each request to the LangGraph Server. The value of the header should be set to a valid LangSmith API key for the organization where the LangGraph Server is deployed.

Example `curl` command:
```shell
curl --request POST \
  --url http://localhost:8124/assistants/search \
  --header 'Content-Type: application/json' \
  --header 'X-Api-Key: LANGSMITH_API_KEY' \
  --data '{
  "metadata": {},
  "limit": 10,
  "offset": 0
}'
```

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/api_ref_control_plane.html
```html
<!doctype html>
<html>
  <head>
    <title>LangGraph Platform API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script id="api-reference" data-url="./openapi_control_plane.json"></script>
    <script>
      var configuration = {}
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
  </body>
</html>

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/api_ref_control_plane.md
```md
# LangGraph Control Plane API Reference

The LangGraph Control Plane API is used to programmatically create and manage LangGraph Server deployments. For example, the APIs can be orchestrated to create custom CI/CD workflows.

Click <a href="https://api.host.langchain.com/docs" target="_blank">here</a> to view the API reference.

## Host

LangGraph Control Plane hosts for Cloud SaaS data regions:

| US | EU |
|----|----|
| `https://api.host.langchain.com` | `https://eu.api.host.langchain.com` |

**Note**: Self-hosted deployments of LangGraph Platform will have a custom host for the LangGraph Control Plane.

## Authentication

To authenticate with the LangGraph Control Plane API, set the `X-Api-Key` header to a valid LangSmith API key.

Example `curl` command:
```shell
curl --request GET \
  --url http://localhost:8124/v2/deployments \
  --header 'X-Api-Key: LANGSMITH_API_KEY'
```

## Versioning

Each endpoint path is prefixed with a version (e.g. `v1`, `v2`).

## Quick Start

1. Call `POST /v2/deployments` to create a new Deployment. The response body contains the Deployment ID (`id`) and the ID of the latest (and first) revision (`latest_revision_id`).
1. Call `GET /v2/deployments/{deployment_id}` to retrieve the Deployment. Set `deployment_id` in the URL to the value of Deployment ID (`id`).
1. Poll for revision `status` until `status` is `DEPLOYED` by calling `GET /v2/deployments/{deployment_id}/revisions/{latest_revision_id}`.
1. Call `PATCH /v2/deployments/{deployment_id}` to update the deployment.

## Example Code
Below is example Python code that demonstrates how to orchestrate the LangGraph Control Plane APIs to create a deployment, update the deployment, and delete the deployment.
```python
import os
import time

import requests
from dotenv import load_dotenv


load_dotenv()

# required environment variables
CONTROL_PLANE_HOST = os.getenv("CONTROL_PLANE_HOST")
LANGSMITH_API_KEY = os.getenv("LANGSMITH_API_KEY")
INTEGRATION_ID = os.getenv("INTEGRATION_ID")
MAX_WAIT_TIME = 1800  # 30 mins


def get_headers() -> dict:
    """Return common headers for requests to LangGraph Control Plane API."""
    return {
        "X-Api-Key": LANGSMITH_API_KEY,
    }


def create_deployment() -> str:
    """Create deployment. Return deployment ID."""
    headers = get_headers()
    headers["Content-Type"] = "application/json"

    deployment_name = "my_deployment"

    request_body = {
        "name": deployment_name,
        "source": "github",
        "source_config": {
            "integration_id": INTEGRATION_ID,
            "repo_url": "https://github.com/langchain-ai/langgraph-example",
            "deployment_type": "dev",
            "build_on_push": False,
            "custom_url": None,
            "resource_spec": None,
        },
        "source_revision_config": {
            "repo_ref": "main",
            "langgraph_config_path": "langgraph.json",
            "image_uri": None,
        },
        "secrets": [
            {
                "name": "OPENAI_API_KEY",
                "value": "test_openai_api_key",
            },
            {
                "name": "ANTHROPIC_API_KEY",
                "value": "test_anthropic_api_key",
            },
            {
                "name": "TAVILY_API_KEY",
                "value": "test_tavily_api_key",
            },
        ],
    }

    response = requests.post(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments",
        headers=headers,
        json=request_body,
    )

    if response.status_code != 201:
        raise Exception(f"Failed to create deployment: {response.text}")

    deployment_id = response.json()["id"]
    print(f"Created deployment {deployment_name} ({deployment_id})")
    return deployment_id


def get_deployment(deployment_id: str) -> dict:
    """Get deployment."""
    response = requests.get(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}",
        headers=get_headers(),
    )

    if response.status_code != 200:
        raise Exception(f"Failed to get deployment ID {deployment_id}: {response.text}")

    return response.json()


def list_revisions(deployment_id: str) -> list[dict]:
    """List revisions.

    Return list is sorted by created_at in descending order (latest first).
    """
    response = requests.get(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}/revisions",
        headers=get_headers(),
    )

    if response.status_code != 200:
        raise Exception(
            f"Failed to list revisions for deployment ID {deployment_id}: {response.text}"
        )

    return response.json()


def get_revision(
    deployment_id: str,
    revision_id: str,
) -> dict:
    """Get revision."""
    response = requests.get(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}/revisions/{revision_id}",
        headers=get_headers(),
    )

    if response.status_code != 200:
        raise Exception(f"Failed to get revision ID {revision_id}: {response.text}")

    return response.json()


def patch_deployment(deployment_id: str) -> None:
    """Patch deployment."""
    headers = get_headers()
    headers["Content-Type"] = "application/json"

    response = requests.patch(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}",
        headers=headers,
        json={
            "source_config": {
                "build_on_push": True,
            },
            "source_revision_config": {
                "repo_ref": "main",
                "langgraph_config_path": "langgraph.json",
            },
        },
    )

    if response.status_code != 200:
        raise Exception(f"Failed to patch deployment: {response.text}")

    print(f"Patched deployment ID {deployment_id}")


def wait_for_deployment(deployment_id: str, revision_id: str) -> None:
    """Wait for revision status to be DEPLOYED."""
    start_time = time.time()
    revision, status = None, None
    while time.time() - start_time < MAX_WAIT_TIME:
        revision = get_revision(deployment_id, revision_id)
        status = revision["status"]
        if status == "DEPLOYED":
            break
        elif "FAILED" in status:
            raise Exception(f"Revision ID {revision_id} failed: {revision}")

        print(f"Waiting for revision ID {revision_id} to be DEPLOYED...")
        time.sleep(60)

    if status != "DEPLOYED":
        raise Exception(
            f"Timeout waiting for revision ID {revision_id} to be DEPLOYED: {revision}"
        )


def delete_deployment(deployment_id: str) -> None:
    """Delete deployment."""
    response = requests.delete(
        url=f"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}",
        headers=get_headers(),
    )

    if response.status_code != 204:
        raise Exception(
            f"Failed to delete deployment ID {deployment_id}: {response.text}"
        )

    print(f"Deployment ID {deployment_id} deleted")


if __name__ == "__main__":
    # create deployment and get the latest revision
    deployment_id = create_deployment()
    revisions = list_revisions(deployment_id)
    latest_revision = revisions["resources"][0]
    latest_revision_id = latest_revision["id"]

    # wait for latest revision to be DEPLOYED
    wait_for_deployment(deployment_id, latest_revision_id)

    # patch the deployment and get the latest revision
    patch_deployment(deployment_id)
    revisions = list_revisions(deployment_id)
    latest_revision = revisions["resources"][0]
    latest_revision_id = latest_revision["id"]

    # wait for latest revision to be DEPLOYED
    wait_for_deployment(deployment_id, latest_revision_id)

    # delete the deployment
    delete_deployment(deployment_id)
```
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/openapi.json
```json
{
  "openapi": "3.1.0",
  "info": {
    "title": "LangSmith Deployment",
    "version": "0.1.0"
  },
  "tags": [
    {
      "name": "Assistants",
      "description": "An assistant is a configured instance of a graph."
    },
    {
      "name": "Threads",
      "description": "A thread contains the accumulated outputs of a group of runs."
    },
    {
      "name": "Thread Runs",
      "description": "A run is an invocation of a graph / assistant on a thread. It updates the state of the thread."
    },
    {
      "name": "Stateless Runs",
      "description": "A run is an invocation of a graph / assistant, with no state or memory persistence."
    },
    {
      "name": "Crons (Plus tier)",
      "description": "A cron is a periodic run that recurs on a given schedule. The repeats can be isolated, or share state in a thread"
    },
    {
      "name": "Store",
      "description": "Store is an API for managing persistent key-value store (long-term memory) that is available from any thread."
    },
    {
      "name": "A2A",
      "description": "Agent-to-Agent Protocol related endpoints for exposing assistants as A2A-compliant agents."
    },
    {
      "name": "MCP",
      "description": "Model Context Protocol related endpoints for exposing an agent as an MCP server."
    },
    {
      "name": "System",
      "description": "System endpoints for health checks, metrics, and server information."
    }
  ],
  "paths": {
    "/assistants": {
      "post": {
        "tags": [
          "Assistants"
        ],
        "summary": "Create Assistant",
        "description": "Create an assistant.\n\nAn initial version of the assistant will be created and the assistant is set to that version. To change versions, use the `POST /assistants/{assistant_id}/latest` endpoint.",
        "operationId": "create_assistant_assistants_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssistantCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/search": {
      "post": {
        "tags": [
          "Assistants"
        ],
        "summary": "Search Assistants",
        "description": "Search for assistants.\n\nThis endpoint also functions as the endpoint to list all assistants.",
        "operationId": "search_assistants_assistants_search_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssistantSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Assistant"
                  },
                  "type": "array",
                  "title": "Response Search Assistants Assistants Search Post"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/count": {
      "post": {
        "tags": [
          "Assistants"
        ],
        "summary": "Count Assistants",
        "description": "Get the count of assistants matching the specified criteria.",
        "operationId": "count_assistants_assistants_count_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssistantCountRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "title": "Count"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}": {
      "get": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant",
        "description": "Get an assistant by ID.",
        "operationId": "get_assistant_assistants__assistant_id__get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant ID",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Assistants"
        ],
        "summary": "Delete Assistant",
        "description": "Delete an assistant by ID.\n\nAll versions of the assistant will be deleted as well.",
        "operationId": "delete_assistant_assistants__assistant_id__delete",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant ID",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Assistants"
        ],
        "summary": "Patch Assistant",
        "description": "Update an assistant.",
        "operationId": "patch_assistant_assistants__assistant_id__patch",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant ID",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssistantPatch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/graph": {
      "get": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant Graph",
        "description": "Get an assistant by ID.",
        "operationId": "get_assistant_graph_assistants__assistant_id__graph_get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "title": "Assistant ID",
                  "description": "The ID of the assistant."
                },
                {
                  "type": "string",
                  "title": "Graph ID",
                  "description": "The ID of the graph."
                }
              ]
            },
            "name": "assistant_id",
            "in": "path"
          },
          {
            "description": "Include graph representation of subgraphs. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Xray",
              "default": false,
              "description": "Include graph representation of subgraphs. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included."
            },
            "name": "xray",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "items": {
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "type": "object",
                  "title": "Response Get Assistant Graph Assistants  Assistant Id  Graph Get"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/subgraphs": {
      "get": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant Subgraphs",
        "description": "Get an assistant's subgraphs.",
        "operationId": "get_assistant_subgraphs_assistants__assistant_id__subgraphs_get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant Id"
            },
            "name": "assistant_id",
            "in": "path"
          },
          {
            "description": "Recursively retrieve subgraphs of subgraphs.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Recurse",
              "default": false
            },
            "name": "recurse",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subgraphs"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/subgraphs/{namespace}": {
      "get": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant Subgraphs by Namespace",
        "description": "Get an assistant's subgraphs filtered by namespace.",
        "operationId": "get_assistant_subgraphs_assistants__assistant_id__subgraphs__namespace__get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant Id"
            },
            "name": "assistant_id",
            "in": "path"
          },
          {
            "description": "Namespace of the subgraph to filter by.",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Namespace"
            },
            "name": "namespace",
            "in": "path"
          },
          {
            "description": "Recursively retrieve subgraphs of subgraphs.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Recurse",
              "default": false
            },
            "name": "recurse",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Subgraphs"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/schemas": {
      "get": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant Schemas",
        "description": "Get an assistant by ID.",
        "operationId": "get_assistant_schemas_assistants__assistant_id__schemas_get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant Id",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GraphSchema"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/versions": {
      "post": {
        "tags": [
          "Assistants"
        ],
        "summary": "Get Assistant Versions",
        "description": "Get all versions of an assistant.",
        "operationId": "get_assistant_versions_assistants__assistant_id__versions_get",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant Id",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Assistant"
                  },
                  "type": "array",
                  "title": "Response Search Assistants Assistants Search Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/assistants/{assistant_id}/latest": {
      "post": {
        "tags": [
          "Assistants"
        ],
        "summary": "Set Latest Assistant Version",
        "description": "Set the latest version for an assistant.",
        "operationId": "set_latest_assistant_version_assistants__assistant_id__versions_post",
        "parameters": [
          {
            "description": "The ID of the assistant.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Assistant Id",
              "description": "The ID of the assistant."
            },
            "name": "assistant_id",
            "in": "path"
          },
          {
            "description": "The version to change to.",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Version",
              "description": "The version of the assistant to change to."
            },
            "name": "version",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Assistant"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads": {
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Create Thread",
        "description": "Create a thread.",
        "operationId": "create_thread_threads_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Thread"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/search": {
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Search Threads",
        "description": "Search for threads.\n\nThis endpoint also functions as the endpoint to list all threads.",
        "operationId": "search_threads_threads_search_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Thread"
                  },
                  "type": "array",
                  "title": "Response Search Threads Threads Search Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/count": {
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Count Threads",
        "description": "Get the count of threads matching the specified criteria.",
        "operationId": "count_threads_threads_count_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadCountRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "title": "Count"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/state": {
      "get": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread State",
        "description": "Get state for a thread.\n\nThe latest state of the thread (i.e. latest checkpoint) is returned.",
        "operationId": "get_latest_thread_state_threads__thread_id__state_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "Whether to include subgraphs in the response.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Subgraphs",
              "description": "Whether to include subgraphs in the response."
            },
            "name": "subgraphs",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThreadState"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Update Thread State",
        "description": "Add state to a thread.",
        "operationId": "update_thread_state_threads__thread_id__state_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadStateUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThreadStateUpdateResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/state/{checkpoint_id}": {
      "get": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread State At Checkpoint",
        "description": "Get state for a thread at a specific checkpoint.",
        "operationId": "get_thread_state_at_checkpoint_threads__thread_id__state__checkpoint_id__get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the checkpoint.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Checkpoint Id",
              "description": "The ID of the checkpoint."
            },
            "name": "checkpoint_id",
            "in": "path"
          },
          {
            "description": "Whether to include subgraphs in the response.",
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Subgraphs",
              "description": "Whether to include subgraphs in the response."
            },
            "name": "subgraphs",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThreadState"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/state/checkpoint": {
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread State At Checkpoint",
        "description": "Get state for a thread at a specific checkpoint.",
        "operationId": "post_thread_state_at_checkpoint_threads__thread_id__state__checkpoint_id__get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Subgraphs",
              "description": "If true, includes subgraph states."
            },
            "name": "subgraphs",
            "in": "query"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadStateCheckpointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThreadState"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/history": {
      "get": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread History",
        "description": "Get all past states for a thread.",
        "operationId": "get_thread_history_threads__thread_id__history_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "name": "limit",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Before"
            },
            "name": "before",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ThreadState"
                  },
                  "type": "array",
                  "title": "Response Get Thread History Threads  Thread Id  History Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread History Post",
        "description": "Get all past states for a thread.",
        "operationId": "get_thread_history_post_threads__thread_id__history_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadStateSearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/ThreadState"
                  },
                  "type": "array",
                  "title": "Response Get Thread History Post Threads  Thread Id  History Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/copy": {
      "post": {
        "tags": [
          "Threads"
        ],
        "summary": "Copy Thread",
        "description": "Create a new thread with a copy of the state and checkpoints from an existing thread.",
        "operationId": "copy_thread_post_threads__thread_id__copy_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Thread"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}": {
      "get": {
        "tags": [
          "Threads"
        ],
        "summary": "Get Thread",
        "description": "Get a thread by ID.",
        "operationId": "get_thread_threads__thread_id__get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Thread"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Threads"
        ],
        "summary": "Delete Thread",
        "description": "Delete a thread by ID.",
        "operationId": "delete_thread_threads__thread_id__delete",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Threads"
        ],
        "summary": "Patch Thread",
        "description": "Update a thread.",
        "operationId": "patch_thread_threads__thread_id__patch",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ThreadPatch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Thread"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/stream": {
      "get": {
        "tags": [
          "Threads"
        ],
        "summary": "Join Thread Stream",
        "description": "This endpoint streams output in real-time from a thread. The stream will include the output of each run executed sequentially on the thread and will remain open indefinitely. It is the responsibility of the calling client to close the connection.",
        "operationId": "join_thread_stream_threads__thread_id__stream_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Last Event ID",
              "description": "The ID of the last event received. Used to resume streaming from a specific point. Pass '-' to resume from the beginning."
            },
            "name": "Last-Event-ID",
            "in": "header"
          },
          {
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "enum": ["lifecycle", "run_modes", "state_update"]
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": ["lifecycle", "run_modes", "state_update"]
                  }
                }
              ],
              "default": ["run_modes"],
              "title": "Stream Modes",
              "description": "Stream modes to control which events are returned. 'lifecycle' returns only run start/end events, 'run_modes' returns all run events (default behavior), 'state_update' returns only state update events."
            },
            "name": "stream_modes",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "The server will send a stream of events in SSE format.\n\n**Example event**:\n\nid: 1\n\nevent: message\n\ndata: {}"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs": {
      "get": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "List Runs",
        "description": "List runs for a thread.",
        "operationId": "list_runs_http_threads__thread_id__runs_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "name": "limit",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Offset",
              "default": 0
            },
            "name": "offset",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "error",
                "success",
                "timeout",
                "interrupted"
              ]
            },
            "name": "status",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "run_id",
                  "thread_id",
                  "assistant_id",
                  "created_at",
                  "updated_at",
                  "status",
                  "metadata",
                  "kwargs",
                  "multitask_strategy"
                ]
              },
              "title": "Select",
              "description": "Specify which fields to return. If not provided, all fields are returned."
            },
            "name": "select",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Run"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Create Background Run",
        "description": "Create a run in existing thread, return the run ID immediately. Don't wait for the final run output.",
        "operationId": "create_run_threads__thread_id__runs_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateful"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Run"
                }
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/crons": {
      "post": {
        "tags": [
          "Crons (Plus tier)"
        ],
        "summary": "Create Thread Cron",
        "description": "Create a cron to schedule runs on a thread.",
        "operationId": "create_thread_cron_threads__thread_id__runs_crons_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CronCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Cron"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/stream": {
      "post": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Create Run, Stream Output",
        "description": "Create a run in existing thread. Stream the output.",
        "operationId": "stream_run_threads__thread_id__runs_stream_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateful"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "The server will send a stream of events in SSE format.\n\n**Example event**:\n\nid: 1\n\nevent: message\n\ndata: {}"
                }
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/wait": {
      "post": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Create Run, Wait for Output",
        "description": "Create a run in existing thread. Wait for the final output and then return it.",
        "operationId": "wait_run_threads__thread_id__runs_wait_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateful"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/{run_id}": {
      "get": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Get Run",
        "description": "Get a run by ID.",
        "operationId": "get_run_http_threads__thread_id__runs__run_id__get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the run.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Run Id",
              "description": "The ID of the run."
            },
            "name": "run_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Run"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Delete Run",
        "description": "Delete a run by ID.",
        "operationId": "delete_run_threads__thread_id__runs__run_id__delete",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the run.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Run Id",
              "description": "The ID of the run."
            },
            "name": "run_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/{run_id}/join": {
      "get": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Join Run",
        "description": "Wait for a run to finish.",
        "operationId": "join_run_http_threads__thread_id__runs__run_id__join_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the run.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Run Id",
              "description": "The ID of the run."
            },
            "name": "run_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Cancel on Disconnect",
              "description": "If true, the run will be cancelled if the client disconnects.",
              "default": false
            },
            "name": "cancel_on_disconnect",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/{run_id}/stream": {
      "get": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Join Run Stream",
        "description": "Join a run stream. This endpoint streams output in real-time from a run similar to the /threads/__THREAD_ID__/runs/stream endpoint. If the run has been created with `stream_resumable=true`, the stream can be resumed from the last seen event ID.",
        "operationId": "stream_run_http_threads__thread_id__runs__run_id__join_get",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the run.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Run Id",
              "description": "The ID of the run."
            },
            "name": "run_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Last Event ID",
              "description": "The ID of the last event received. Set to -1 if you want to stream all events. Requires `stream_resumable=true` to be set when creating the run."
            },
            "name": "Last-Event-ID",
            "in": "header"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Stream Mode",
              "description": "The mode to stream the run in. If not provided, the default mode will be used."
            },
            "name": "stream_mode",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Cancel On Disconnect",
              "description": "If true, the run will be cancelled if the client disconnects.",
              "default": false
            },
            "name": "cancel_on_disconnect",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "The server will send a stream of events in SSE format.\n\n**Example event**:\n\nid: 1\n\nevent: message\n\ndata: {}"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/threads/{thread_id}/runs/{run_id}/cancel": {
      "post": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Cancel Run",
        "operationId": "cancel_run_http_threads__thread_id__runs__run_id__cancel_post",
        "parameters": [
          {
            "description": "The ID of the thread.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Thread Id",
              "description": "The ID of the thread."
            },
            "name": "thread_id",
            "in": "path"
          },
          {
            "description": "The ID of the run.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Run Id",
              "description": "The ID of the run."
            },
            "name": "run_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "boolean",
              "title": "Wait",
              "default": false
            },
            "name": "wait",
            "in": "query"
          },
          {
            "description": "Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. `interrupt` will simply cancel the run. `rollback` will cancel the run and delete the run and associated checkpoints afterwards.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "interrupt",
                "rollback"
              ],
              "title": "Action",
              "default": "interrupt"
            },
            "name": "action",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/crons": {
      "post": {
        "tags": [
          "Crons (Plus tier)"
        ],
        "summary": "Create Cron",
        "description": "Create a cron to schedule runs on new threads.",
        "operationId": "create_cron_runs_crons_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CronCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Cron"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/crons/search": {
      "post": {
        "tags": [
          "Crons (Plus tier)"
        ],
        "summary": "Search Crons",
        "description": "Search all active crons",
        "operationId": "search_crons_runs_crons_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CronSearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Cron"
                  },
                  "type": "array",
                  "title": "Response Search Crons Search Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/crons/count": {
      "post": {
        "tags": [
          "Crons (Plus tier)"
        ],
        "summary": "Count Crons",
        "description": "Get the count of crons matching the specified criteria.",
        "operationId": "count_crons_runs_crons_count_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CronCountRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "title": "Count"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/stream": {
      "post": {
        "tags": [
          "Stateless Runs"
        ],
        "summary": "Create Run, Stream Output",
        "description": "Create a run in a new thread, stream the output.",
        "operationId": "stream_run_stateless_runs_stream_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateless"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/event-stream": {
                "schema": {
                  "type": "string",
                  "description": "The server will send a stream of events in SSE format.\n\n**Example event**:\n\nid: 1\n\nevent: message\n\ndata: {}"
                }
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/cancel": {
      "post": {
        "tags": [
          "Thread Runs"
        ],
        "summary": "Cancel Runs",
        "description": "Cancel one or more runs. Can cancel runs by thread ID and run IDs, or by status filter.",
        "operationId": "cancel_runs_post",
        "parameters": [
          {
            "description": "Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. `interrupt` will simply cancel the run. `rollback` will cancel the run and delete the run and associated checkpoints afterwards.",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "interrupt",
                "rollback"
              ],
              "title": "Action",
              "default": "interrupt"
            },
            "name": "action",
            "in": "query"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunsCancel"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Success - Runs cancelled"
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/wait": {
      "post": {
        "tags": [
          "Stateless Runs"
        ],
        "summary": "Create Run, Wait for Output",
        "description": "Create a run in a new thread. Wait for the final output and then return it.",
        "operationId": "wait_run_stateless_runs_wait_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateless"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs": {
      "post": {
        "tags": [
          "Stateless Runs"
        ],
        "summary": "Create Background Run",
        "description": "Create a run in a new thread, return the run ID immediately. Don't wait for the final run output.",
        "operationId": "run_stateless_runs_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunCreateStateless"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            },
            "headers": {
              "Content-Location": {
                "description": "The URL of the run that was created. Can be used to later join the stream.",
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/batch": {
      "post": {
        "tags": [
          "Stateless Runs"
        ],
        "summary": "Create Run Batch",
        "description": "Create a batch of runs in new threads, return immediately.",
        "operationId": "run_batch_stateless_runs_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunBatchCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/runs/crons/{cron_id}": {
      "delete": {
        "tags": [
          "Crons (Plus tier)"
        ],
        "summary": "Delete Cron",
        "description": "Delete a cron by ID.",
        "operationId": "delete_cron_runs_crons__cron_id__delete",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Cron Id"
            },
            "name": "cron_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/store/items": {
      "put": {
        "tags": [
          "Store"
        ],
        "summary": "Store or update an item.",
        "operationId": "put_item",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StorePutRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Store"
        ],
        "summary": "Delete an item.",
        "operationId": "delete_item",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StoreDeleteRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Success"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Store"
        ],
        "summary": "Retrieve a single item.",
        "operationId": "get_item",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "namespace",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Item"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/store/items/search": {
      "post": {
        "tags": [
          "Store"
        ],
        "summary": "Search for items within a namespace prefix.",
        "operationId": "search_items",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StoreSearchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchItemsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/store/namespaces": {
      "post": {
        "tags": [
          "Store"
        ],
        "summary": "List namespaces with optional match conditions.",
        "operationId": "list_namespaces",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StoreListNamespacesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNamespaceResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/a2a/{assistant_id}": {
      "post": {
        "operationId": "post_a2a",
        "summary": "A2A Post",
        "description": "Communicate with an assistant using the Agent-to-Agent Protocol.\nSends a JSON-RPC 2.0 message to the assistant.\n\n- **Request**: Provide an object with `jsonrpc`, `id`, `method`, and optional `params`.\n- **Response**: Returns a JSON-RPC response with task information or error.\n\n**Supported Methods:**\n- `message/send`: Send a message to the assistant\n- `tasks/get`: Get the status and result of a task\n\n**Notes:**\n- Supports threaded conversations via thread context\n- Messages can contain text and data parts\n- Tasks run asynchronously and return completion status\n",
        "parameters": [
          {
            "name": "assistant_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The ID of the assistant to communicate with"
          },
          {
            "name": "Accept",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["application/json"]
            },
            "description": "Must be application/json"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "jsonrpc": {
                    "type": "string",
                    "enum": ["2.0"],
                    "description": "JSON-RPC version"
                  },
                  "id": {
                    "type": "string",
                    "description": "Request identifier"
                  },
                  "method": {
                    "type": "string",
                    "enum": ["message/send", "tasks/get"],
                    "description": "The method to invoke"
                  },
                  "params": {
                    "type": "object",
                    "description": "Method parameters",
                    "oneOf": [
                      {
                        "title": "Message Send Parameters",
                        "properties": {
                          "message": {
                            "type": "object",
                            "properties": {
                              "role": {
                                "type": "string",
                                "enum": ["user", "assistant"],
                                "description": "Message role"
                              },
                              "parts": {
                                "type": "array",
                                "items": {
                                  "oneOf": [
                                    {
                                      "title": "Text Part",
                                      "type": "object",
                                      "properties": {
                                        "kind": {
                                          "type": "string",
                                          "enum": ["text"]
                                        },
                                        "text": {
                                          "type": "string"
                                        }
                                      },
                                      "required": ["kind", "text"]
                                    },
                                    {
                                      "title": "Data Part", 
                                      "type": "object",
                                      "properties": {
                                        "kind": {
                                          "type": "string",
                                          "enum": ["data"]
                                        },
                                        "data": {
                                          "type": "object"
                                        }
                                      },
                                      "required": ["kind", "data"]
                                    }
                                  ]
                                },
                                "description": "Message parts"
                              },
                              "messageId": {
                                "type": "string",
                                "description": "Unique message identifier"
                              }
                            },
                            "required": ["role", "parts", "messageId"]
                          },
                          "thread": {
                            "type": "object",
                            "properties": {
                              "threadId": {
                                "type": "string",
                                "description": "Thread identifier for conversation context"
                              }
                            },
                            "description": "Optional thread context"
                          }
                        },
                        "required": ["message"]
                      },
                      {
                        "title": "Task Get Parameters",
                        "properties": {
                          "taskId": {
                            "type": "string",
                            "description": "Task identifier to retrieve"
                          }
                        },
                        "required": ["taskId"]
                      }
                    ]
                  }
                },
                "required": ["jsonrpc", "id", "method"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "JSON-RPC response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "jsonrpc": {
                      "type": "string",
                      "enum": ["2.0"]
                    },
                    "id": {
                      "type": "string"
                    },
                    "result": {
                      "type": "object",
                      "description": "Success result containing task information or task details"
                    },
                    "error": {
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer"
                        },
                        "message": {
                          "type": "string"
                        }
                      },
                      "description": "Error information if request failed"
                    }
                  },
                  "required": ["jsonrpc", "id"]
                }
              }
            }
          },
          "400": {
            "description": "Bad request - invalid JSON-RPC or missing Accept header"
          },
          "404": {
            "description": "Assistant not found"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "tags": [
          "A2A"
        ]
      }
    },
    "/mcp/": {
      "post": {
        "operationId": "post_mcp",
        "summary": "MCP Post",
        "description": "Implemented according to the Streamable HTTP Transport specification.\nSends a JSON-RPC 2.0 message to the server.\n\n- **Request**: Provide an object with `jsonrpc`, `id`, `method`, and optional `params`.\n- **Response**: Returns a JSON-RPC response or acknowledgment.\n\n**Notes:**\n- Stateless: Sessions are not persisted across requests.\n",
        "parameters": [
          {
            "name": "Accept",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "application/json, text/event-stream"
              ]
            },
            "description": "Accept header must include both 'application/json' and 'text/event-stream' media types."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              },
              "description": "A JSON-RPC 2.0 request, notification, or response object.",
              "example": {
                "jsonrpc": "2.0",
                "id": "1",
                "method": "initialize",
                "params": {
                  "clientInfo": {
                    "name": "test_client",
                    "version": "1.0.0"
                  },
                  "protocolVersion": "2024-11-05",
                  "capabilities": {}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful JSON-RPC response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "202": {
            "description": "Notification or response accepted; no content body."
          },
          "400": {
            "description": "Bad request: invalid JSON or message format, or unacceptable Accept header."
          },
          "405": {
            "description": "HTTP method not allowed."
          },
          "500": {
            "description": "Internal server error or unexpected failure."
          }
        },
        "tags": [
          "MCP"
        ]
      },
      "get": {
        "operationId": "get_mcp",
        "summary": "MCP Get",
        "description": "Implemented according to the Streamable HTTP Transport specification.",
        "responses": {
          "405": {
            "description": "GET method not allowed; streaming not supported."
          }
        },
        "tags": [
          "MCP"
        ]
      },
      "delete": {
        "operationId": "delete_mcp",
        "summary": "Terminate Session",
        "description": "Implemented according to the Streamable HTTP Transport specification.\nTerminate an MCP session. The server implementation is stateless, so this is a no-op.\n\n",
        "responses": {
          "404": {}
        },
        "tags": [
          "MCP"
        ]
      }
    },
    "/info": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "Server Information",
        "description": "Get server version information, feature flags, and metadata.",
        "operationId": "server_info_info_get",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "version": {
                      "type": "string",
                      "title": "Version",
                      "description": "LangGraph API version"
                    },
                    "langgraph_py_version": {
                      "type": "string",
                      "title": "LangGraph Python Version",
                      "description": "LangGraph Python library version"
                    },
                    "flags": {
                      "type": "object",
                      "title": "Feature Flags",
                      "description": "Enabled features and capabilities"
                    },
                    "metadata": {
                      "type": "object",
                      "title": "Metadata",
                      "description": "Server deployment metadata"
                    }
                  },
                  "required": ["version", "langgraph_py_version", "flags", "metadata"],
                  "title": "ServerInfo"
                }
              }
            }
          }
        }
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "System Metrics",
        "description": "Get system metrics in Prometheus or JSON format for monitoring and observability.",
        "operationId": "system_metrics_metrics_get",
        "parameters": [
          {
            "name": "format",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["prometheus", "json"],
              "default": "prometheus",
              "title": "Output Format",
              "description": "Response format: prometheus (default) or json"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "title": "Prometheus Metrics",
                  "description": "Metrics in Prometheus exposition format"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object",
                  "title": "JSON Metrics",
                  "description": "Metrics in JSON format including queue stats, worker stats, and HTTP metrics"
                }
              }
            }
          }
        }
      }
    },
    "/ok": {
      "get": {
        "tags": [
          "System"
        ],
        "summary": "Health Check",
        "description": "Check the health status of the server. Optionally check database connectivity.",
        "operationId": "health_check_ok_get",
        "parameters": [
          {
            "name": "check_db",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "enum": [0, 1],
              "default": 0,
              "title": "Check Database",
              "description": "Whether to check database connectivity (0=false, 1=true)"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ok": {
                      "type": "boolean",
                      "const": true,
                      "title": "OK",
                      "description": "Indicates the server is healthy"
                    }
                  },
                  "required": ["ok"],
                  "title": "HealthResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Assistant": {
        "properties": {
          "assistant_id": {
            "type": "string",
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The ID of the assistant."
          },
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph."
          },
          "config": {
            "properties": {
              "tags": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "title": "Tags"
              },
              "recursion_limit": {
                "type": "integer",
                "title": "Recursion Limit"
              },
              "configurable": {
                "type": "object",
                "title": "Configurable"
              }
            },
            "type": "object",
            "title": "Config",
            "description": "The assistant config."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "The time the assistant was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "The last time the assistant was updated."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "The assistant metadata."
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The version of the assistant"
          },
          "name": {
            "type": "string",
            "title": "Assistant Name",
            "description": "The name of the assistant"
          },
          "description": {
            "type": [
              "string",
              "null"
            ],
            "title": "Assistant Description",
            "description": "The description of the assistant"
          }
        },
        "type": "object",
        "required": [
          "assistant_id",
          "graph_id",
          "config",
          "created_at",
          "updated_at",
          "metadata"
        ],
        "title": "Assistant"
      },
      "AssistantCreate": {
        "properties": {
          "assistant_id": {
            "type": "string",
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The ID of the assistant. If not provided, a random UUID will be generated."
          },
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph the assistant should use. The graph ID is normally set in your langgraph.json configuration."
          },
          "config": {
            "type": "object",
            "title": "Config",
            "description": "Configuration to use for the graph. Useful when graph is configurable and you want to create different assistants based on different configurations."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to add to assistant."
          },
          "if_exists": {
            "type": "string",
            "enum": [
              "raise",
              "do_nothing"
            ],
            "title": "If Exists",
            "description": "How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing assistant).",
            "default": "raise"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the assistant. Defaults to 'Untitled'."
          },
          "description": {
            "type": [
              "string",
              "null"
            ],
            "title": "Description",
            "description": "The description of the assistant. Defaults to null."
          }
        },
        "type": "object",
        "required": [
          "graph_id"
        ],
        "title": "AssistantCreate",
        "description": "Payload for creating an assistant."
      },
      "AssistantPatch": {
        "properties": {
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph the assistant should use. The graph ID is normally set in your langgraph.json configuration. If not provided, assistant will keep pointing to same graph."
          },
          "config": {
            "type": "object",
            "title": "Config",
            "description": "Configuration to use for the graph. Useful when graph is configurable and you want to update the assistant's configuration."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to merge with existing assistant metadata."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The new name for the assistant. If not provided, assistant will keep its current name."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "The new description for the assistant. If not provided, assistant will keep its current description."
          }
        },
        "type": "object",
        "title": "AssistantPatch",
        "description": "Payload for updating an assistant."
      },
      "AssistantVersionChange": {
        "properties": {
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "The assistant version."
          }
        },
        "type": "object",
        "title": "AssistantVersionChange",
        "description": "Payload for changing the version of an assistant."
      },
      "Config": {
        "properties": {
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags"
          },
          "recursion_limit": {
            "type": "integer",
            "title": "Recursion Limit"
          },
          "configurable": {
            "type": "object",
            "title": "Configurable"
          }
        },
        "type": "object",
        "title": "Config"
      },
      "Cron": {
        "properties": {
          "cron_id": {
            "type": "string",
            "format": "uuid",
            "title": "Cron Id",
            "description": "The ID of the cron."
          },
          "assistant_id": {
            "type": ["string", "null"],
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The ID of the assistant."
          },
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The ID of the thread."
          },
          "end_time": {
            "type": "string",
            "format": "date-time",
            "title": "End Time",
            "description": "The end date to stop running the cron."
          },
          "schedule": {
            "type": "string",
            "title": "Schedule",
            "description": "The schedule to run, cron format."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "The time the cron was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "The last time the cron was updated."
          },
          "user_id": {
            "type": ["string", "null"],
            "title": "User Id",
            "description": "The ID of the user."
          },
          "payload": {
            "type": "object",
            "title": "Payload",
            "description": "The run payload to use for creating new run."
          },
          "next_run_date": {
            "type": ["string", "null"],
            "format": "date-time",
            "title": "Next Run Date",
            "description": "The next run date of the cron."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "The cron metadata."
          }
        },
        "type": "object",
        "required": [
          "cron_id",
          "thread_id",
          "end_time",
          "schedule",
          "created_at",
          "updated_at",
          "payload"
        ],
        "title": "Cron",
        "description": "Represents a scheduled task."
      },
      "CronCreate": {
        "properties": {
          "schedule": {
            "type": "string",
            "title": "Schedule",
            "description": "The cron schedule to execute this job on."
          },
          "end_time": {
            "type": "string",
            "format": "date-time",
            "title": "End Time",
            "description": "The end date to stop running the cron."
          },
          "assistant_id": {
            "anyOf": [
              {
                "type": "string",
                "format": "uuid",
                "title": "Assistant Id"
              },
              {
                "type": "string",
                "title": "Graph Id"
              }
            ],
            "description": "The assistant ID or graph name to run. If using graph name, will default to the assistant automatically created from that graph by the server."
          },
          "input": {
            "anyOf": [
              {
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "object"
              }
            ],
            "title": "Input",
            "description": "The input to the graph."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to assign to the cron job runs."
          },
          "config": {
            "properties": {
              "tags": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "title": "Tags"
              },
              "recursion_limit": {
                "type": "integer",
                "title": "Recursion Limit"
              },
              "configurable": {
                "type": "object",
                "title": "Configurable"
              }
            },
            "type": "object",
            "title": "Config",
            "description": "The configuration for the assistant."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "webhook": {
            "type": "string",
            "maxLength": 65536,
            "minLength": 1,
            "format": "uri-reference",
            "title": "Webhook",
            "description": "Webhook to call after LangGraph API call is done."
          },
          "interrupt_before": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt Before",
            "description": "Nodes to interrupt immediately before they get executed."
          },
          "interrupt_after": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt After",
            "description": "Nodes to interrupt immediately after they get executed."
          },
          "multitask_strategy": {
            "type": "string",
            "enum": [
              "reject",
              "rollback",
              "interrupt",
              "enqueue"
            ],
            "title": "Multitask Strategy",
            "description": "Multitask strategy to use. Must be one of 'reject', 'interrupt', 'rollback', or 'enqueue'.",
            "default": "enqueue"
          }
        },
        "type": "object",
        "required": [
          "assistant_id",
          "schedule"
        ],
        "title": "CronCreate",
        "description": "Payload for creating a cron job."
      },
      "CronSearch": {
        "properties": {
          "assistant_id": {
            "type": "string",
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The assistant ID or graph name to filter by using exact match."
          },
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The thread ID to search for."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "The maximum number of results to return.",
            "default": 10,
            "minimum": 1,
            "maximum": 1000
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "The number of results to skip.",
            "default": 0,
            "minimum": 0
          },
          "sort_by": {
            "type": "string",
            "title": "Sort By",
            "description": "The field to sort by.",
            "default": "created_at",
            "enum": ["cron_id", "assistant_id", "thread_id", "next_run_date", "end_time", "created_at", "updated_at"]
          },
          "sort_order": {
            "type": "string",
            "title": "Sort Order",
            "description": "The order to sort by.",
            "default": "desc",
            "enum": ["asc", "desc"]
          },
          "select": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "cron_id",
                "assistant_id",
                "thread_id",
                "end_time",
                "schedule",
                "created_at",
                "updated_at",
                "user_id",
                "payload",
                "next_run_date",
                "metadata",
                "now"
              ]
            },
            "title": "Select",
            "description": "Specify which fields to return. If not provided, all fields are returned."
          }
        },
        "type": "object",
        "required": [],
        "title": "CronSearch",
        "description": "Payload for listing crons"
      },
      "CronCountRequest": {
        "properties": {
          "assistant_id": {
            "type": "string",
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The assistant ID or graph name to search for."
          },
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The thread ID to search for."
          }
        },
        "type": "object",
        "title": "CronCountRequest",
        "description": "Payload for counting crons"
      },
      "GraphSchema": {
        "properties": {
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph."
          },
          "input_schema": {
            "type": "object",
            "title": "Input Schema",
            "description": "The schema for the graph input. Missing if unable to generate JSON schema from graph."
          },
          "output_schema": {
            "type": "object",
            "title": "Output Schema",
            "description": "The schema for the graph output. Missing if unable to generate JSON schema from graph."
          },
          "state_schema": {
            "type": "object",
            "title": "State Schema",
            "description": "The schema for the graph state. Missing if unable to generate JSON schema from graph."
          },
          "config_schema": {
            "type": "object",
            "title": "Config Schema",
            "description": "The schema for the graph config. Missing if unable to generate JSON schema from graph."
          },
          "context_schema": {
            "type": "object",
            "title": "Context Schema",
            "description": "The schema for the graph context. Missing if unable to generate JSON schema from graph."
          }
        },
        "type": "object",
        "required": [
          "graph_id",
          "state_schema"
        ],
        "title": "GraphSchema",
        "description": "Defines the structure and properties of a graph."
      },
      "GraphSchemaNoId": {
        "properties": {
          "input_schema": {
            "type": "object",
            "title": "Input Schema",
            "description": "The schema for the graph input. Missing if unable to generate JSON schema from graph."
          },
          "output_schema": {
            "type": "object",
            "title": "Output Schema",
            "description": "The schema for the graph output. Missing if unable to generate JSON schema from graph."
          },
          "state_schema": {
            "type": "object",
            "title": "State Schema",
            "description": "The schema for the graph state. Missing if unable to generate JSON schema from graph."
          },
          "config_schema": {
            "type": "object",
            "title": "Config Schema",
            "description": "The schema for the graph config. Missing if unable to generate JSON schema from graph."
          },
          "context_schema": {
            "type": "object",
            "title": "Context Schema",
            "description": "The schema for the graph context. Missing if unable to generate JSON schema from graph."
          }
        },
        "type": "object",
        "required": [
          "input_schema",
          "output_schema",
          "state_schema"
        ],
        "title": "GraphSchemaNoId",
        "description": "Defines the structure and properties of a graph without an ID."
      },
      "Subgraphs": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/GraphSchemaNoId"
        },
        "title": "Subgraphs",
        "description": "Map of graph name to graph schema metadata (`input_schema`, `output_schema`, `state_schema`, `config_schema`, `context_schema`)."
      },
      "Run": {
        "properties": {
          "run_id": {
            "type": "string",
            "format": "uuid",
            "title": "Run Id",
            "description": "The ID of the run."
          },
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The ID of the thread."
          },
          "assistant_id": {
            "type": "string",
            "format": "uuid",
            "title": "Assistant Id",
            "description": "The assistant that was used for this run."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "The time the run was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "The last time the run was updated."
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "running",
              "error",
              "success",
              "timeout",
              "interrupted"
            ],
            "title": "Status",
            "description": "The status of the run. One of 'pending', 'running', 'error', 'success', 'timeout', 'interrupted'."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "The run metadata."
          },
          "kwargs": {
            "type": "object",
            "title": "Kwargs"
          },
          "multitask_strategy": {
            "type": "string",
            "enum": [
              "reject",
              "rollback",
              "interrupt",
              "enqueue"
            ],
            "title": "Multitask Strategy",
            "description": "Strategy to handle concurrent runs on the same thread."
          }
        },
        "type": "object",
        "required": [
          "run_id",
          "thread_id",
          "assistant_id",
          "created_at",
          "updated_at",
          "status",
          "metadata",
          "kwargs",
          "multitask_strategy"
        ],
        "title": "Run"
      },
      "Send": {
        "type": "object",
        "title": "Send",
        "description": "A message to send to a node.",
        "properties": {
          "node": {
            "type": "string",
            "title": "Node",
            "description": "The node to send the message to."
          },
          "input": {
            "type": [
              "object",
              "array",
              "number",
              "string",
              "boolean",
              "null"
            ],
            "title": "Message",
            "description": "The message to send."
          }
        },
        "required": [
          "node",
          "input"
        ]
      },
      "Command": {
        "type": "object",
        "title": "Command",
        "description": "The command to run.",
        "properties": {
          "update": {
            "type": [
              "object",
              "array",
              "null"
            ],
            "title": "Update",
            "description": "An update to the state."
          },
          "resume": {
            "type": [
              "object",
              "array",
              "number",
              "string",
              "boolean",
              "null"
            ],
            "title": "Resume",
            "description": "A value to pass to an interrupted node."
          },
          "goto": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Send"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Send"
                }
              },
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Goto",
            "description": "Name of the node(s) to navigate to next or node(s) to be executed with a provided input."
          }
        }
      },
      "RunCreateStateful": {
        "properties": {
          "assistant_id": {
            "anyOf": [
              {
                "type": "string",
                "format": "uuid",
                "title": "Assistant Id"
              },
              {
                "type": "string",
                "title": "Graph Id"
              }
            ],
            "description": "The assistant ID or graph name to run. If using graph name, will default to first assistant created from that graph."
          },
          "checkpoint": {
            "type": "object",
            "title": "Checkpoint",
            "description": "The checkpoint to resume from.",
            "$ref": "#/components/schemas/CheckpointConfig"
          },
          "input": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "array"
              },
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input",
            "description": "The input to the graph."
          },
          "command": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Command"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input",
            "description": "The input to the graph."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to assign to the run."
          },
          "config": {
            "properties": {
              "tags": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "title": "Tags"
              },
              "recursion_limit": {
                "type": "integer",
                "title": "Recursion Limit"
              },
              "configurable": {
                "type": "object",
                "title": "Configurable"
              }
            },
            "type": "object",
            "title": "Config",
            "description": "The configuration for the assistant."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "webhook": {
            "type": "string",
            "maxLength": 65536,
            "minLength": 1,
            "format": "uri-reference",
            "title": "Webhook",
            "description": "Webhook to call after LangGraph API call is done."
          },
          "interrupt_before": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt Before",
            "description": "Nodes to interrupt immediately before they get executed."
          },
          "interrupt_after": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt After",
            "description": "Nodes to interrupt immediately after they get executed."
          },
          "stream_mode": {
            "anyOf": [
              {
                "items": {
                  "type": "string",
                  "enum": [
                    "values",
                    "messages",
                    "messages-tuple",
                    "tasks",
                    "checkpoints",
                    "updates",
                    "events",
                    "debug",
                    "custom"
                  ]
                },
                "type": "array"
              },
              {
                "type": "string",
                "enum": [
                  "values",
                  "messages",
                  "messages-tuple",
                  "tasks",
                  "checkpoints",
                  "updates",
                  "events",
                  "debug",
                  "custom"
                ]
              }
            ],
            "title": "Stream Mode",
            "description": "The stream mode(s) to use.",
            "default": [
              "values"
            ]
          },
          "stream_subgraphs": {
            "type": "boolean",
            "title": "Stream Subgraphs",
            "description": "Whether to stream output from subgraphs.",
            "default": false
          },
          "stream_resumable": {
            "type": "boolean",
            "title": "Stream Resumable",
            "description": "Whether to persist the stream chunks in order to resume the stream later.",
            "default": false
          },
          "on_disconnect": {
            "type": "string",
            "enum": [
              "cancel",
              "continue"
            ],
            "title": "On Disconnect",
            "description": "The disconnect mode to use. Must be one of 'cancel' or 'continue'.",
            "default": "cancel"
          },
          "feedback_keys": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Feedback Keys",
            "description": "Feedback keys to assign to run."
          },
          "multitask_strategy": {
            "type": "string",
            "enum": [
              "reject",
              "rollback",
              "interrupt",
              "enqueue"
            ],
            "title": "Multitask Strategy",
            "description": "Multitask strategy to use. Must be one of 'reject', 'interrupt', 'rollback', or 'enqueue'.",
            "default": "enqueue"
          },
          "if_not_exists": {
            "type": "string",
            "enum": [
              "create",
              "reject"
            ],
            "title": "If Not Exists",
            "description": "How to handle missing thread. Must be either 'reject' (raise error if missing), or 'create' (create new thread).",
            "default": "reject"
          },
          "after_seconds": {
            "type": "number",
            "title": "After Seconds",
            "description": "The number of seconds to wait before starting the run. Use to schedule future runs."
          },
          "checkpoint_during": {
            "type": "boolean",
            "title": "Checkpoint During",
            "description": "Whether to checkpoint during the run.",
            "default": false
          },
          "durability": {
            "type": "string",
            "enum": [
              "sync",
              "async",
              "exit"
            ],
            "title": "Durability",
            "description": "Durability level for the run. Must be one of 'sync', 'async', or 'exit'.",
            "default": "async"
          }
        },
        "type": "object",
        "required": [
          "assistant_id"
        ],
        "title": "RunCreateStateful",
        "description": "Payload for creating a run."
      },
      "RunBatchCreate": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/RunCreateStateless"
        },
        "minItems": 1,
        "title": "RunBatchCreate",
        "description": "Payload for creating a batch of runs."
      },
      "RunCreateStateless": {
        "properties": {
          "assistant_id": {
            "anyOf": [
              {
                "type": "string",
                "format": "uuid",
                "title": "Assistant Id"
              },
              {
                "type": "string",
                "title": "Graph Id"
              }
            ],
            "description": "The assistant ID or graph name to run. If using graph name, will default to first assistant created from that graph."
          },
          "input": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "array"
              },
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input",
            "description": "The input to the graph."
          },
          "command": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Command"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input",
            "description": "The input to the graph."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to assign to the run."
          },
          "config": {
            "properties": {
              "tags": {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "title": "Tags"
              },
              "recursion_limit": {
                "type": "integer",
                "title": "Recursion Limit"
              },
              "configurable": {
                "type": "object",
                "title": "Configurable"
              }
            },
            "type": "object",
            "title": "Config",
            "description": "The configuration for the assistant."
          },
          "context": {
            "type": "object",
            "title": "Context",
            "description": "Static context added to the assistant."
          },
          "webhook": {
            "type": "string",
            "maxLength": 65536,
            "minLength": 1,
            "format": "uri-reference",
            "title": "Webhook",
            "description": "Webhook to call after LangGraph API call is done."
          },
          "interrupt_before": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt Before",
            "description": "Nodes to interrupt immediately before they get executed."
          },
          "interrupt_after": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "*"
                ]
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Interrupt After",
            "description": "Nodes to interrupt immediately after they get executed."
          },
          "stream_mode": {
            "anyOf": [
              {
                "items": {
                  "type": "string",
                  "enum": [
                    "values",
                    "messages",
                    "messages-tuple",
                    "tasks",
                    "checkpoints",
                    "updates",
                    "events",
                    "debug",
                    "custom"
                  ]
                },
                "type": "array"
              },
              {
                "type": "string",
                "enum": [
                  "values",
                  "messages",
                  "messages-tuple",
                  "tasks",
                  "checkpoints",
                  "updates",
                  "events",
                  "debug",
                  "custom"
                ]
              }
            ],
            "title": "Stream Mode",
            "description": "The stream mode(s) to use.",
            "default": [
              "values"
            ]
          },
          "feedback_keys": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Feedback Keys",
            "description": "Feedback keys to assign to run."
          },
          "stream_subgraphs": {
            "type": "boolean",
            "title": "Stream Subgraphs",
            "description": "Whether to stream output from subgraphs.",
            "default": false
          },
          "stream_resumable": {
            "type": "boolean",
            "title": "Stream Resumable",
            "description": "Whether to persist the stream chunks in order to resume the stream later.",
            "default": false
          },
          "on_completion": {
            "type": "string",
            "enum": [
              "delete",
              "keep"
            ],
            "title": "On Completion",
            "description": "Whether to delete or keep the thread created for a stateless run. Must be one of 'delete' or 'keep'.",
            "default": "delete"
          },
          "on_disconnect": {
            "type": "string",
            "enum": [
              "cancel",
              "continue"
            ],
            "title": "On Disconnect",
            "description": "The disconnect mode to use. Must be one of 'cancel' or 'continue'.",
            "default": "cancel"
          },
          "after_seconds": {
            "type": "number",
            "title": "After Seconds",
            "description": "The number of seconds to wait before starting the run. Use to schedule future runs."
          },
          "checkpoint_during": {
            "type": "boolean",
            "title": "Checkpoint During",
            "description": "Whether to checkpoint during the run.",
            "default": false
          },
          "durability": {
            "type": "string",
            "enum": [
              "sync",
              "async",
              "exit"
            ],
            "title": "Durability",
            "description": "Durability level for the run. Must be one of 'sync', 'async', or 'exit'.",
            "default": "async"
          }
        },
        "type": "object",
        "required": [
          "assistant_id"
        ],
        "title": "RunCreateStateless",
        "description": "Payload for creating a run."
      },
      "AssistantSearchRequest": {
        "properties": {
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to filter by. Exact match filter for each KV pair."
          },
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph to filter by. The graph ID is normally set in your langgraph.json configuration."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "The maximum number of results to return.",
            "default": 10,
            "minimum": 1,
            "maximum": 1000
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "The number of results to skip.",
            "default": 0,
            "minimum": 0
          },
          "sort_by": {
            "type": "string",
            "enum": [
              "assistant_id",
              "created_at",
              "updated_at",
              "name",
              "graph_id"
            ],
            "title": "Sort By",
            "description": "The field to sort by."
          },
          "sort_order": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "title": "Sort Order",
            "description": "The order to sort by."
          },
          "select": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "assistant_id",
                "graph_id", 
                "name",
                "description",
                "config",
                "context",
                "created_at",
                "updated_at",
                "metadata",
                "version"
              ]
            },
            "title": "Select",
            "description": "Specify which fields to return. If not provided, all fields are returned."
          }
        },
        "type": "object",
        "title": "AssistantSearchRequest",
        "description": "Payload for listing assistants."
      },
      "AssistantCountRequest": {
        "properties": {
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to filter by. Exact match filter for each KV pair."
          },
          "graph_id": {
            "type": "string",
            "title": "Graph Id",
            "description": "The ID of the graph to filter by. The graph ID is normally set in your langgraph.json configuration."
          }
        },
        "type": "object",
        "title": "AssistantCountRequest",
        "description": "Payload for counting assistants."
      },
      "AssistantVersionsSearchRequest": {
        "properties": {
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to filter versions by. Exact match filter for each KV pair."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "The maximum number of versions to return.",
            "default": 10,
            "minimum": 1,
            "maximum": 1000
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "The number of versions to skip.",
            "default": 0,
            "minimum": 0
          }
        },
        "type": "object",
        "title": "SearchRequest",
        "description": "Payload for listing assistant versions."
      },
      "ThreadSearchRequest": {
        "properties": {
          "ids": {
            "type": "array",
            "items": {"type": "string", "format": "uuid"},
            "title": "Ids",
            "description": "List of thread IDs to include. Others are excluded."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Thread metadata to filter on."
          },
          "values": {
            "type": "object",
            "title": "Values",
            "description": "State values to filter on."
          },
          "status": {
            "type": "string",
            "enum": [
              "idle",
              "busy",
              "interrupted",
              "error"
            ],
            "title": "Status",
            "description": "Thread status to filter on."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Maximum number to return.",
            "default": 10,
            "minimum": 1,
            "maximum": 1000
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Offset to start from.",
            "default": 0,
            "minimum": 0
          },
          "sort_by": {
            "type": "string",
            "enum": [
              "thread_id",
              "status",
              "created_at",
              "updated_at"
            ],
            "title": "Sort By",
            "description": "Sort by field."
          },
          "sort_order": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "title": "Sort Order",
            "description": "Sort order."
          },
          "select": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "thread_id",
                "created_at",
                "updated_at",
                "metadata",
                "config",
                "context",
                "status",
                "values",
                "interrupts"
              ]
            },
            "title": "Select",
            "description": "Specify which fields to return. If not provided, all fields are returned."
          }
        },
        "type": "object",
        "title": "ThreadSearchRequest",
        "description": "Payload for listing threads."
      },
      "ThreadCountRequest": {
        "properties": {
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Thread metadata to filter on."
          },
          "values": {
            "type": "object",
            "title": "Values",
            "description": "State values to filter on."
          },
          "status": {
            "type": "string",
            "enum": [
              "idle",
              "busy",
              "interrupted",
              "error"
            ],
            "title": "Status",
            "description": "Thread status to filter on."
          }
        },
        "type": "object",
        "title": "ThreadCountRequest",
        "description": "Payload for counting threads."
      },
      "Thread": {
        "properties": {
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The ID of the thread."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "The time the thread was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "The last time the thread was updated."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "The thread metadata."
          },
          "config": {
            "type": "object",
            "title": "Config",
            "description": "The thread config."
          },
          "status": {
            "type": "string",
            "enum": [
              "idle",
              "busy",
              "interrupted",
              "error"
            ],
            "title": "Status",
            "description": "The status of the thread."
          },
          "values": {
            "type": "object",
            "title": "Values",
            "description": "The current state of the thread."
          },
          "interrupts": {
            "type": "object",
            "title": "Interrupts",
            "description": "The current interrupts of the thread."
          }
        },
        "type": "object",
        "required": [
          "thread_id",
          "created_at",
          "updated_at",
          "metadata",
          "status"
        ],
        "title": "Thread"
      },
      "ThreadCreate": {
        "properties": {
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The ID of the thread. If not provided, a random UUID will be generated."
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to add to thread."
          },
          "if_exists": {
            "type": "string",
            "enum": [
              "raise",
              "do_nothing"
            ],
            "title": "If Exists",
            "description": "How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing thread).",
            "default": "raise"
          },
          "ttl": {
            "type": "object",
            "title": "TTL",
            "description": "The time-to-live for the thread.",
            "properties": {
              "strategy": {
                "type": "string",
                "enum": [
                  "delete"
                ],
                "description": "The TTL strategy. 'delete' removes the entire thread.",
                "default": "delete"
              },
              "ttl": {
                "type": "number",
                "description": "The time-to-live in minutes from now until thread should be swept."
              }
            }
          },
          "supersteps": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "updates": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ThreadSuperstepUpdate"
                  }
                }
              },
              "required": [
                "updates"
              ]
            }
          }
        },
        "type": "object",
        "title": "ThreadCreate",
        "description": "Payload for creating a thread."
      },
      "ThreadPatch": {
        "properties": {
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Metadata to merge with existing thread metadata."
          },
          "ttl": {
            "type": "object",
            "title": "TTL",
            "description": "The time-to-live for the thread.",
            "properties": {
              "strategy": {
                "type": "string",
                "enum": [
                  "delete"
                ],
                "description": "The TTL strategy. 'delete' removes the entire thread.",
                "default": "delete"
              },
              "ttl": {
                "type": "number",
                "description": "The time-to-live in minutes from now until thread should be swept."
              }
            }
          }
        },
        "type": "object",
        "title": "ThreadPatch",
        "description": "Payload for updating a thread."
      },
      "ThreadStateCheckpointRequest": {
        "properties": {
          "checkpoint": {
            "$ref": "#/components/schemas/CheckpointConfig",
            "title": "Checkpoint",
            "description": "The checkpoint to get the state for."
          },
          "subgraphs": {
            "type": "boolean",
            "title": "Subgraphs",
            "description": "Include subgraph states."
          }
        },
        "required": [
          "checkpoint"
        ],
        "type": "object",
        "title": "ThreadStateCheckpointRequest",
        "description": "Payload for getting the state of a thread at a checkpoint."
      },
      "ThreadState": {
        "properties": {
          "values": {
            "anyOf": [
              {
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "object"
              }
            ],
            "title": "Values"
          },
          "next": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Next"
          },
          "tasks": {
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "Task Id"
                },
                "name": {
                  "type": "string",
                  "title": "Node Name"
                },
                "error": {
                  "type": "string",
                  "title": "Error"
                },
                "interrupts": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Interrupt"
                  }
                },
                "checkpoint": {
                  "$ref": "#/components/schemas/CheckpointConfig",
                  "title": "Checkpoint"
                },
                "state": {
                  "$ref": "#/components/schemas/ThreadState"
                }
              },
              "required": [
                "id",
                "name"
              ]
            },
            "type": "array",
            "title": "Tasks"
          },
          "checkpoint": {
            "$ref": "#/components/schemas/CheckpointConfig",
            "title": "Checkpoint"
          },
          "metadata": {
            "type": "object",
            "title": "Metadata"
          },
          "created_at": {
            "type": "string",
            "title": "Created At"
          },
          "parent_checkpoint": {
            "type": "object",
            "title": "Parent Checkpoint"
          },
          "interrupts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Interrupt"
            }
          }
        },
        "type": "object",
        "required": [
          "values",
          "next",
          "checkpoint",
          "metadata",
          "created_at"
        ],
        "title": "ThreadState"
      },
      "ThreadStateSearch": {
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "The maximum number of states to return.",
            "default": 1,
            "maximum": 1000,
            "minimum": 1
          },
          "before": {
            "title": "Before",
            "description": "Return states before this checkpoint.",
            "$ref": "#/components/schemas/CheckpointConfig"
          },
          "metadata": {
            "type": "object",
            "title": "Metadata",
            "description": "Filter states by metadata key-value pairs."
          },
          "checkpoint": {
            "$ref": "#/components/schemas/CheckpointConfig",
            "title": "Checkpoint",
            "description": "Return states for this subgraph."
          }
        },
        "type": "object",
        "title": "ThreadStateSearch"
      },
      "ThreadStateUpdate": {
        "properties": {
          "values": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Values",
            "description": "The values to update the state with."
          },
          "checkpoint": {
            "$ref": "#/components/schemas/CheckpointConfig",
            "title": "Checkpoint",
            "description": "The checkpoint to update the state of."
          },
          "as_node": {
            "type": "string",
            "title": "As Node",
            "description": "Update the state as if this node had just executed."
          }
        },
        "type": "object",
        "title": "ThreadStateUpdate",
        "description": "Payload for updating the state of a thread."
      },
      "ThreadSuperstepUpdate": {
        "properties": {
          "values": {
            "anyOf": [
              {
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ]
          },
          "command": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Command"
              },
              {
                "type": "null"
              }
            ],
            "description": "The command associated with the update."
          },
          "as_node": {
            "type": "string",
            "description": "Update the state as if this node had just executed."
          }
        },
        "required": [
          "as_node"
        ],
        "type": "object"
      },
      "ThreadStateUpdateResponse": {
        "properties": {
          "checkpoint": {
            "type": "object",
            "title": "Checkpoint"
          }
        },
        "type": "object",
        "title": "ThreadStateUpdateResponse",
        "description": "Response for adding state to a thread."
      },
      "CheckpointConfig": {
        "type": "object",
        "title": "CheckpointConfig",
        "description": "Checkpoint config.",
        "properties": {
          "thread_id": {
            "type": "string",
            "description": "Unique identifier for the thread associated with this checkpoint."
          },
          "checkpoint_ns": {
            "type": "string",
            "description": "Namespace for the checkpoint, used for organization and retrieval."
          },
          "checkpoint_id": {
            "type": "string",
            "description": "Optional unique identifier for the checkpoint itself."
          },
          "checkpoint_map": {
            "type": "object",
            "description": "Optional dictionary containing checkpoint-specific data."
          }
        }
      },
      "StorePutRequest": {
        "type": "object",
        "required": [
          "namespace",
          "key",
          "value"
        ],
        "properties": {
          "namespace": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Namespace",
            "description": "A list of strings representing the namespace path."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "The unique identifier for the item within the namespace."
          },
          "value": {
            "type": "object",
            "title": "Value",
            "description": "A dictionary containing the item's data."
          }
        },
        "title": "StorePutRequest",
        "description": "Request to store or update an item."
      },
      "StoreDeleteRequest": {
        "type": "object",
        "required": [
          "key"
        ],
        "properties": {
          "namespace": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Namespace",
            "description": "A list of strings representing the namespace path."
          },
          "key": {
            "type": "string",
            "title": "Key",
            "description": "The unique identifier for the item."
          }
        },
        "title": "StoreDeleteRequest",
        "description": "Request to delete an item."
      },
      "StoreSearchRequest": {
        "type": "object",
        "properties": {
          "namespace_prefix": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "title": "Namespace Prefix",
            "description": "List of strings representing the namespace prefix."
          },
          "filter": {
            "type": [
              "object",
              "null"
            ],
            "additionalProperties": true,
            "title": "Filter",
            "description": "Optional dictionary of key-value pairs to filter results."
          },
          "limit": {
            "type": "integer",
            "default": 10,
            "title": "Limit",
            "description": "Maximum number of items to return (default is 10)."
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "title": "Offset",
            "description": "Number of items to skip before returning results (default is 0)."
          },
          "query": {
            "type": [
              "string",
              "null"
            ],
            "title": "Query",
            "description": "Query string for semantic/vector search."
          }
        },
        "title": "StoreSearchRequest",
        "description": "Request to search for items within a namespace prefix."
      },
      "StoreListNamespacesRequest": {
        "type": "object",
        "properties": {
          "prefix": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Prefix",
            "description": "Optional list of strings representing the prefix to filter namespaces."
          },
          "suffix": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Suffix",
            "description": "Optional list of strings representing the suffix to filter namespaces."
          },
          "max_depth": {
            "type": "integer",
            "title": "Max Depth",
            "description": "Optional integer specifying the maximum depth of namespaces to return."
          },
          "limit": {
            "type": "integer",
            "default": 100,
            "title": "Limit",
            "description": "Maximum number of namespaces to return (default is 100)."
          },
          "offset": {
            "type": "integer",
            "default": 0,
            "title": "Offset",
            "description": "Number of namespaces to skip before returning results (default is 0)."
          }
        }
      },
      "Item": {
        "type": "object",
        "required": [
          "namespace",
          "key",
          "value",
          "created_at",
          "updated_at"
        ],
        "properties": {
          "namespace": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The namespace of the item. A namespace is analogous to a document's directory."
          },
          "key": {
            "type": "string",
            "description": "The unique identifier of the item within its namespace. In general, keys needn't be globally unique."
          },
          "value": {
            "type": "object",
            "description": "The value stored in the item. This is the document itself."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when the item was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when the item was last updated."
          }
        },
        "description": "Represents a single document or data entry in the graph's Store. Items are used to store cross-thread memories."
      },
      "RunsCancel": {
        "type": "object",
        "title": "RunsCancel",
        "description": "Payload for cancelling runs.",
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "running",
              "all"
            ],
            "title": "Status",
            "description": "Filter runs by status to cancel. Must be one of 'pending', 'running', or 'all'."
          },
          "thread_id": {
            "type": "string",
            "format": "uuid",
            "title": "Thread Id",
            "description": "The ID of the thread containing runs to cancel."
          },
          "run_ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "title": "Run Ids",
            "description": "List of run IDs to cancel."
          }
        },
        "oneOf": [
          {
            "required": [
              "status"
            ]
          },
          {
            "required": [
              "thread_id",
              "run_ids"
            ]
          }
        ]
      },
      "SearchItemsResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Item"
            }
          }
        }
      },
      "ListNamespaceResponse": {
        "type": "array",
        "items": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "ErrorResponse": {
        "type": "string",
        "title": "ErrorResponse",
        "description": "Error message returned from the server"
      }
    },
    "responses": {
      "GetItemResponse": {
        "description": "Successful retrieval of an item.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Item"
            }
          }
        }
      },
      "PutItemResponse": {
        "description": "Item successfully stored or updated.",
        "content": {}
      },
      "DeleteItemResponse": {
        "description": "Item successfully deleted.",
        "content": {}
      },
      "SearchItemsResponse": {
        "description": "Successful search operation.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/SearchItemsResponse"
            }
          }
        }
      },
      "ListNamespacesResponse": {
        "description": "Successful retrieval of namespaces.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ListNamespaceResponse"
            }
          }
        }
      },
      "ErrorResponse": {
        "description": "An error occurred.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorResponse"
            }
          }
        }
      },
      "Interrupt": {
        "type": "object",
        "properties": {
          "id": {
            "type": [
              "string",
              "null"
            ]
          },
          "value": {
            "type": "object"
          }
        },
        "title": "Interrupt",
        "required": [
          "value"
        ]
      }
    }
  }
}

```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/api/openapi_control_plane.json
```json
{
  "openapi": "3.1.0",
  "info": {
    "title": "LangGraph Control Plane API (Beta)",
    "version": "0.0.1",
    "description": "The LangGraph Control Plane API is used to programmatically create and manage LangGraph Server deployments. For example, the APIs can be orchestrated to create custom CI/CD workflows.\n\n### Beta\nThis API is currently in beta and may change or break without notice. This API documentation may not be up-to-date with actual API functionality.\n### Host\nhttps://api.host.langchain.com/\n\n### Authentication\nTo authenticate with the LangGraph Control Plane API, set the `X-Api-Key` header to a valid LangSmith API key for each request.\n\n### Versioning\nEach endpoint path is prefixed with a version (e.g. `v1`).\n\n### Quick Start\n\n1. Call `POST /{version}/projects` to create a new `Project`.\n2. Call `GET /{version}/projects` to retrieve the `Project` `id`. The `Project` `id` is needed in subsequent API calls.\n3. Call `POST /{version}/projects/{project_id}/revisions` to create a new `Revision` for the `Project`.\n4. Call `GET /{version}/projects/{project_id}/revisions` to get the latest `Revision` (first element in returned list). Get the `Revision` `id`.\n5. Poll for `Revision` `status` until `status` is `DEPLOYED` by calling `GET /{version}/projects/{project_id}/revisions/{revision_id}`."
  },
  "servers": [
    {
      "url": "https://api.host.langchain.com"
    }
  ],
  "tags": [
    {
      "name": "Projects (v1)",
      "description": "A project corresponds to a LangGraph Server deployment and the associated LangSmith tracing project.\n\nCreating a project via API is not currently supported/documented."
    },
    {
      "name": "Revisions (v1)",
      "description": "A revision is a version of a LangGraph Server deployment. Different revisions may contain different code and/or environment variables. A project can have many revisions."
    }
  ],
  "paths": {
    "/v1/projects": {
      "post": {
        "tags": ["Projects (v1)"],
        "summary": "Create Project",
        "description": "Create a new project.",
        "operationId": "create_project_projects_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProjectRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Project"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Projects (v1)"],
        "summary": "List Projects",
        "description": "List all projects.",
        "operationId": "list_projects_projects_get",
        "parameters": [
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Limit",
              "description": "Maximum number of results to return. Minimum: 1. Maximum: 100.",
              "default": 20
            },
            "name": "limit",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Offset",
              "description": "Pagination offset value. Pass this value in subsequent requests to retrieve the next page of results. Minimum: 0.",
              "default": 0
            },
            "name": "offset",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "string",
              "title": "Name Contains",
              "description": "Filter string to filter projects by `name`."
            },
            "name": "name_contains",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Project"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/projects/{project_id}": {
      "get": {
        "tags": ["Projects (v1)"],
        "summary": "Get Project",
        "description": "Get project by ID.",
        "operationId": "get_project_projects__project_id__get",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Project"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Projects (v1)"],
        "summary": "Delete Project",
        "description": "Delete project by ID.",
        "operationId": "delete_project_projects__project_id__delete",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Project"
                }
              }
            }
          }
        }
      }
    },
    "/v1/projects/{project_id}/revisions": {
      "get": {
        "tags": ["Revisions (v1)"],
        "summary": "List Revisions",
        "description": "List revisions of a project.",
        "operationId": "list_revisions_projects__project_id__revisions_get",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Limit",
              "description": "Maximum number of results to return. Minimum: 1. Maximum: 100.",
              "default": 20
            },
            "name": "limit",
            "in": "query"
          },
          {
            "required": false,
            "schema": {
              "type": "integer",
              "title": "Offset",
              "description": "Pagination offset value. Pass this value in subsequent requests to retrieve the next page of results. Minimum: 0.",
              "default": 0
            },
            "name": "offset",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Revision"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Revisions (v1)"],
        "summary": "Create Revision",
        "description": "Create a new revision for a project.",
        "operationId": "create_revision_projects__project_id__revisions_post",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateRevisionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Project"
                }
              }
            }
          }
        }
      }
    },
    "/v1/projects/{project_id}/revisions/{revision_id}": {
      "get": {
        "tags": ["Revisions (v1)"],
        "summary": "Get Revision",
        "description": "Get revision by ID.",
        "operationId": "get_revision_projects__project_id__revisions__revision_id__get",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Revision ID"
            },
            "name": "revision_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Revision"
                }
              }
            }
          }
        }
      }
    },
    "/v1/projects/{project_id}/revisions/{revision_id}/deploy": {
      "post": {
        "tags": ["Revisions (v1)"],
        "summary": "Deploy Revision",
        "description": "Deploy revision by ID.\n\nThis endpoint redeploys the deployment of a revision without rebuilding the image for the deployment. Redeploying the deployment of a revision may mitigate intermittent issues with a deployment.\n\nThe revision must be in the `DEPLOYED` status and must be the latest revision of the project.",
        "operationId": "deploy_revision_projects__project_id__revisions__revision_id__deploy_post",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Revision ID"
            },
            "name": "revision_id",
            "in": "path"
          }
        ],
        "responses": {
          "400": {
            "description": "Revision is not in DEPLOYED status or revision is not the latest revision for the project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Revision not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/projects/{project_id}/revisions/{revision_id}/interrupt": {
      "post": {
        "tags": ["Revisions (v1)"],
        "summary": "Interrupt Revision",
        "description": "Interrupt revision by ID.\n\nIf the deployment of a revision appears \"stuck\", the revision may need to be interrupted. A new revision cannot be created if the latest revision is in a non-terminal `status`. In this scenario, the revision may need to be interrupted.",
        "operationId": "interrupt_revision_projects__project_id__revisions__revision_id__interrupt_post",
        "parameters": [
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Project ID"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid",
              "title": "Revision ID"
            },
            "name": "revision_id",
            "in": "path"
          }
        ]
      }
    }
  },
  "components": {
    "securitySchemes": {
      "apiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "X-Api-Key"
      }
    },
    "schemas": {
      "ContainerSpec": {
        "type": "object",
        "description": "Container specification for a revision's deployment.\n\nIf any field is omitted or set to `null`, the internal default value is used depending on the deployment type (`dev` or `prod`).",
        "properties": {
          "min_scale": {
            "type": ["integer", "null"],
            "description": "Minimum number of replicas in deployment.",
            "default": "null"
          },
          "max_scale": {
            "type": ["integer", "null"],
            "description": "Maximum number of replicas in deployment.",
            "default": "null"
          },
          "cpu": {
            "type": ["integer", "null"],
            "description": "Number of vCPU cores per replica.",
            "default": "null"
          },
          "memory_mb": {
            "type": ["integer", "null"],
            "description": "Amount of memory in MB per replica.",
            "default": "null"
          }
        }
      },
      "CreateProjectRequest":{
        "type": "object",
        "description": "Object for creating a new project.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the project.",
            "required": true
          },
          "lc_hosted": {
            "type": "boolean",
            "description": "Whether the project is hosted on LangChain's cloud (i.e. Cloud SaaS deployment option). Set to `false` for Self-Hosted Data Plane and Self-Hosted Control Plane deployment options.",
            "default": true
          },
          "repo_url": {
            "type": ["string", "null"],
            "description": "URL of the GitHub repository to use for the project. Omit this field if creating a new project from a Docker image.",
            "default": "null"
          },
          "repo_path": {
            "type": ["string", "null"],
            "description": "Path to `langgraph.json` configuration file. For example, `langgraph.json` or `src/langgraph.json`.\n\nIf this field is omitted or set to `null`, the previous revision's `repo_path` value is used. Set this field for deployments from a GitHub repository. Omit this field if creating a new revision from a Docker image.",
            "default": "null"
          },
          "repo_commit": {
            "type": ["string", "null"],
            "description": "Git branch name of deployment.\n\nThis field only applies to deployments from a GitHub repository.",
            "default": "null"
          },
          "env_vars": {
            "type": "array",
            "description": "List of environment variables or secrets.\n\nIf this field is omitted or set to `null`, the previous revision's `env_vars` value is used.",
            "items": {
              "$ref": "#/components/schemas/EnvVar"
            },
            "default": "null"
          },
          "host_integration_id": {
            "type": ["string", "null"],
            "format": "uuid",
            "description": "Do not use."
          },
          "deployment_type": {
            "type": "string",
            "description": "Development (`dev`) or Production (`prod`) type deployment.",
            "enum": [
              "dev",
              "prod"
            ]
          },
          "shareable": {
            "type": ["boolean", "null"],
            "description": "Boolean flag to configure if a deployment is shareable through LangGraph Studio.\n\nIf this field is omitted or set to `null`, the previous revision's `shareable` value is used. This field does not apply to BYOC deployments.",
            "default": "null"
          },
          "platform": {
            "type": "object",
            "description": "Do not use.",
            "default": "null"
          },
          "image_path": {
            "type": ["string", "null"],
            "description": "URI of the Docker image to deploy.\n\nIf this field is omitted or set to `null`, the previous revision's `image_path` value is used. Set this field for BYOC deployments. Omit this field if creating a new revision from a GitHub repository.",
            "default": "null"
          },
          "build_on_push": {
            "type": "boolean",
            "description": "Boolean flag to indicate if a new revision is automatically created on push to GitHub branch (`repo_branch`).\n\nThis field does not apply for BYOC deployments.",
            "default": false
          },
          "container_spec": {
            "description": "If this field is omitted or set to `null`, the previous revision's `container_spec` value is used.",
            "$ref": "#/components/schemas/ContainerSpec",
            "default": "null"
          }
        }
      },
      "CreateRevisionRequest": {
        "type": "object",
        "description": "Object for creating a new revision.",
        "properties": {
          "image_path": {
            "type": ["string", "null"],
            "description": "URI of the Docker image to deploy.\n\nIf this field is omitted or set to `null`, the previous revision's `image_path` value is used. Set this field for BYOC deployments. Omit this field if creating a new revision from a GitHub repository.",
            "default": "null"
          },
          "repo_path": {
            "type": ["string", "null"],
            "description": "Path to `langgraph.json` configuration file. For example, `langgraph.json` or `src/langgraph.json`.\n\nIf this field is omitted or set to `null`, the previous revision's `repo_path` value is used. Set this field for deployments from a GitHub repository. Omit this field if creating a new revision from a Docker image.",
            "default": "null"
          },
          "env_vars": {
            "type": "array",
            "description": "List of environment variables or secrets.\n\nIf this field is omitted or set to `null`, the previous revision's `env_vars` value is used.",
            "items": {
              "$ref": "#/components/schemas/EnvVar"
            },
            "default": "null"
          },
          "shareable": {
            "type": ["boolean", "null"],
            "description": "Boolean flag to configure if a deployment is shareable through LangGraph Studio.\n\nIf this field is omitted or set to `null`, the previous revision's `shareable` value is used. This field does not apply to BYOC deployments.",
            "default": "null"
          },
          "container_spec": {
            "description": "If this field is omitted or set to `null`, the previous revision's `container_spec` value is used.",
            "$ref": "#/components/schemas/ContainerSpec",
            "default": "null"
          }
        }
      },
      "EnvVar": {
        "type": "object",
        "description": "An environment variable or secret.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Environment variable or secret name.",
            "required": true
          },
          "value": {
            "type": "string",
            "description": "Environment variable or secret value.",
            "required": true
          },
          "type": {
            "type": "string",
            "enum": [
              "default",
              "secret"
            ],
            "description": "Field to designate type of the environment variable (default) or secret.",
            "required": true
          }
        }
      },
      "ErrorResponse": {
        "type": "object",
        "description": "Error response.",
        "properties": {
          "detail": {
            "type": "string",
            "description": "Error details.",
            "required": true
          }
        }
      },
      "Project": {
        "type": "object",
        "description": "A project corresponds to a LangGraph Server deployment and the associated LangSmith tracing project.",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the project.",
            "required": true
          },
          "tool_name": {
            "type": ["string", "null"],
            "description": "Do not use."
          },
          "display_name": {
            "type": ["string", "null"],
            "description": "Do not use."
          },
          "description": {
            "type": ["string", "null"],
            "description": "Do not use."
          },
          "example_input": {
            "type": ["object", "null"],
            "description": "Do not use."
          },
          "tenant_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the tenant/workspace of the project.",
            "required": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of when the project was created.",
            "required": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of when the project was updated.",
            "required": true
          },
          "name": {
            "type": "string",
            "description": "Name of the project.\n\nThis is also the name of the LangSmith tracing project for the LangGraph deployment.",
            "required": true
          },
          "lc_hosted": {
            "type": "boolean",
            "description": "Boolean flag to indicate if the deployment is hosted in LangChain's cloud or an external cloud (e.g. BYOC).",
            "required": true
          },
          "repo_url": {
            "type": ["string", "null"],
            "description": "URL of the GitHub repository.\n\nThis field is not used for deployments from a Docker image."
          },
          "repo_branch": {
            "type": ["string", "null"],
            "description": "Branch of the GitHub repository.\n\nThis field is not used for deployments from a Docker image."
          },
          "tracer_session_id": {
            "type": ["string", "null"],
            "format": "uuid",
            "description": "Do not use."
          },
          "api_key_id": {
            "type": ["string", "null"],
            "format": "uuid",
            "description": "Do not use."
          },
          "build_on_push": {
            "type": "boolean",
            "description": "Boolean flag to indicate if a new revision is automatically created on push to GitHub branch (`repo_branch`).\n\nThis field does not apply for BYOC deployments."
          },
          "input_json_schemas": {
            "type": ["object", "null"],
            "description": "Do not use."
          },
          "output_json_schemas": {
            "type": ["object", "null"],
            "description": "Do not use."
          },
          "host_integration_id": {
            "type": ["string", "null"],
            "format": "uuid",
            "description": "Do not use."
          },
          "metadata": {
            "$ref": "#/components/schemas/ProjectMetadata"
          },
          "resource": {
            "$ref": "#/components/schemas/ResourceService"
          },
          "status": {
            "type": "string",
            "enum": [
              "AWAITING_DATABASE",
              "READY",
              "AWAITING_DELETE",
              "UNKNOWN"
            ],
            "description": "Deployment status of the project.\n\nNon-terminal statuses: `AWAITING_DATABASE`, `AWAITING_DELETE`. All other statuses are terminal."
          }
        }
      },
      "ProjectMetadata": {
        "type": "object",
        "description": "Metadata associated with a `Project`.",
        "properties": {
          "deployment_type": {
            "type": "string",
            "description": "Development (`dev`) or Production (`prod`) type deployment.",
            "enum": [
              "dev",
              "prod"
            ]
          },
          "image_source": {
            "type": "string",
            "description": "Do not use.",
            "enum": [
              "github",
              "internal_docker",
              "external_docker"
            ]
          },
          "shareable": {
            "type": "boolean",
            "description": "Boolean flag to configure if a deployment is shareable through LangGraph Studio.\n\nThis field does not apply to BYOC deployments."
          },
          "region": {
            "type": "string",
            "description": "Region of deployment.\n\nRegion value is cloud provider specific."
          },
          "aws_account_id": {
            "type": "string",
            "description": "AWS account ID of BYOC deployment.\n\nThis field does not apply to non-BYOC deployments."
          },
          "aws_external_id": {
            "type": "string",
            "description": "Do not use."
          }
        }
      },
      "ResourceId": {
        "type": "object",
        "description": "Internal identifier for a `ResourceRevision` or `ResourceService`.",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "revisions",
              "services"
            ]
          },
          "name": {
            "type": "string"
          }
        }
      },
      "ResourceRevision": {
        "type": "object",
        "description": "Internal revision resource for a `ResourceService`.",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ResourceId"
          },
          "env_vars": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EnvVar"
            }
          },
          "hosted_langserve_revision_id": {
            "type": "string",
            "format": "uuid",
            "description": "References `id` of a `Revision`."
          }
        }
      },
      "ResourceService": {
        "type": "object",
        "description": "Internal service resource for a `Project`.",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ResourceId"
          },
          "url": {
            "type": ["string", "null"],
            "description": "URL of LangGraph Server deployment."
          },
          "latest_revision": {
            "description": "References latest `ResourceRevision`.\n\nThe latest `ResourceRevision` may not be active if it's currently being deployed.",
            "$ref": "#/components/schemas/ResourceRevision"
          },
          "latest_active_revision": {
            "description": "References latest active `ResourceRevision`.\n\nThe latest active `ResourceRevision` is not always the latest `ResourceRevision`.",
            "$ref": "#/components/schemas/ResourceRevision"
          }
        }
      },
      "Revision": {
        "type": "object",
        "description": "A revision is a version of a LangGraph Server deployment.\n\nDifferent revisions may contain different code and/or environment variables. A project can have many revisions.",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the revision.",
            "required": true
          },
          "project_id": {
            "type": "string",
            "format": "uuid",
            "description": "References `id` of `Project`.",
            "required": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of when the revision was created.",
            "required": true
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of when the revision was updated.",
            "required": true
          },
          "repo_path": {
            "type": ["string", "null"],
            "description": "Path to `langgraph.json` configuration file. For example, `langgraph.json` or `src/langgraph.json`.\n\nThis field only applies to deployments from a GitHub repository.",
            "default": "null"
          },
          "repo_commit": {
            "type": ["string", "null"],
            "description": "Git branch name of deployment.\n\nThis field only applies to deployments from a GitHub repository.",
            "default": "null"
          },
          "status": {
            "type": "string",
            "enum": [
              "CREATING",
              "AWAITING_BUILD",
              "BUILDING",
              "AWAITING_DEPLOY",
              "DEPLOYING",
              "CREATE_FAILED",
              "BUILD_FAILED",
              "DEPLOY_FAILED",
              "DEPLOYED",
              "INTERRUPTED",
              "UNKNOWN"
            ],
            "description": "Deployment status of the revision.\n\nNon-terminal statuses: `CREATING`, `AWAITING_BUILD`, `BUILDING`, `AWAITING_DEPLOY`, `DEPLOYING`. All other statuses are terminal."
          },
          "status_message": {
            "type": "string",
            "description": "Message associated with the `status`."
          },
          "gcp_build_name": {
            "type": ["string", "null"],
            "description": "Do not use."
          },
          "metadata": {
            "$ref": "#/components/schemas/RevisionMetadata"
          },
          "image_path": {
            "type": ["string", "null"],
            "description": "URI of the Docker image to deploy.\n\nThis field does not apply to deployments from a GitHub repository.",
            "default": "null"
          },
          "container_spec": {
            "$ref": "#/components/schemas/ContainerSpec"
          },
          "resource": {
            "$ref": "#/components/schemas/ResourceRevision"
          }
        }
      },
      "RevisionMetadata": {
        "type": "object",
        "description": "Metadata associated with a `Revision`.",
        "properties": {
          "created_by": {
            "type": "object",
            "description": "Do not use."
          },
          "repo_commit_sha": {
            "type": "string",
            "description": "Git commit SHA of the deployment.\n\nThis field only applies to deployments from a GitHub repository."
          }
        }
      }
    }
  }
}
```
---
https://github.com/langchain-ai/langgraph/blob/main/docs/docs/cloud/reference/sdk/js_ts_sdk_ref.md
```md

<a name="readmemd"></a>

**[@langchain/langgraph-sdk](https://github.com/langchain-ai/langgraph/tree/main/libs/sdk-js)**

***

## [@langchain/langgraph-sdk](https://github.com/langchain-ai/langgraph/tree/main/libs/sdk-js)

### Classes

- [AssistantsClient](#classesassistantsclientmd)
- [Client](#classesclientmd)
- [CronsClient](#classescronsclientmd)
- [RunsClient](#classesrunsclientmd)
- [StoreClient](#classesstoreclientmd)
- [ThreadsClient](#classesthreadsclientmd)

### Interfaces

- [ClientConfig](#interfacesclientconfigmd)

### Functions

- [getApiKey](#functionsgetapikeymd)


<a name="authreadmemd"></a>

**@langchain/langgraph-sdk**

***

## @langchain/langgraph-sdk/auth

### Classes

- [Auth](#authclassesauthmd)
- [HTTPException](#authclasseshttpexceptionmd)

### Interfaces

- [AuthEventValueMap](#authinterfacesautheventvaluemapmd)

### Type Aliases

- [AuthFilters](#authtype-aliasesauthfiltersmd)


<a name="authclassesauthmd"></a>

[**@langchain/langgraph-sdk**](#authreadmemd)

***

[@langchain/langgraph-sdk](#authreadmemd) / Auth

## Class: Auth\<TExtra, TAuthReturn, TUser\>

Defined in: [src/auth/index.ts:11](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/index.ts#L11)

### Type Parameters

 **TExtra** = \{\}

 **TAuthReturn** *extends* `BaseAuthReturn` = `BaseAuthReturn`

 **TUser** *extends* `BaseUser` = `ToUserLike`\<`TAuthReturn`\>

### Constructors

#### new Auth()

> **new Auth**\<`TExtra`, `TAuthReturn`, `TUser`\>(): [`Auth`](#authclassesauthmd)\<`TExtra`, `TAuthReturn`, `TUser`\>

##### Returns

[`Auth`](#authclassesauthmd)\<`TExtra`, `TAuthReturn`, `TUser`\>

### Methods

#### authenticate()

> **authenticate**\<`T`\>(`cb`): [`Auth`](#authclassesauthmd)\<`TExtra`, `T`\>

Defined in: [src/auth/index.ts:25](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/index.ts#L25)

##### Type Parameters

 **T** *extends* `BaseAuthReturn`

##### Parameters

###### cb

`AuthenticateCallback`\<`T`\>

##### Returns

[`Auth`](#authclassesauthmd)\<`TExtra`, `T`\>

***

#### on()

> **on**\<`T`\>(`event`, `callback`): `this`

Defined in: [src/auth/index.ts:32](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/index.ts#L32)

##### Type Parameters

 **T** *extends* `CallbackEvent`

##### Parameters

###### event

`T`

###### callback

`OnCallback`\<`T`, `TUser`\>

##### Returns

`this`


<a name="authclasseshttpexceptionmd"></a>

[**@langchain/langgraph-sdk**](#authreadmemd)

***

[@langchain/langgraph-sdk](#authreadmemd) / HTTPException

## Class: HTTPException

Defined in: [src/auth/error.ts:66](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/error.ts#L66)

### Extends

- `Error`

### Constructors

#### new HTTPException()

> **new HTTPException**(`status`, `options`?): [`HTTPException`](#authclasseshttpexceptionmd)

Defined in: [src/auth/error.ts:70](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/error.ts#L70)

##### Parameters

###### status

`number`

###### options?

####### cause?

`unknown`

####### headers?

`HeadersInit`

####### message?

`string`

##### Returns

[`HTTPException`](#authclasseshttpexceptionmd)

##### Overrides

`Error.constructor`

### Properties

#### cause?

> `optional` **cause**: `unknown`

Defined in: node\_modules/typescript/lib/lib.es2022.error.d.ts:24

##### Inherited from

`Error.cause`

***

#### headers

> **headers**: `HeadersInit`

Defined in: [src/auth/error.ts:68](https://github.com/langchain-ai/langgraph/blob/d4f644877db6264bd46d0b00fc4c37f174e502d5/libs/sdk-js/src/auth/error.ts#L68)

***

#### message

> **message**: `string`

Defined in: node\_modules/typescript/lib/lib.es5.d.ts:1077

##### Inherited from

`Error.message`

***

#### name

> **name**: `string`

